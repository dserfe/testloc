{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25079", "model_patch": "diff --git a/lib/matplotlib/cm.py b/lib/matplotlib/cm.py\nindex 06f543d..2e78b7a 100644\n--- a/lib/matplotlib/cm.py\n+++ b/lib/matplotlib/cm.py\n@@ -614,8 +614,7 @@ class ScalarMappable:\n         if not in_init:\n             self.norm.callbacks.disconnect(self._id_norm)\n         self._norm = norm\n-        self._id_norm = self.norm.callbacks.connect('changed',\n-                                                    self.changed)\n+        self._id_norm = self.norm.callbacks.connect('changed', self._norm_changed)\n         if not in_init:\n             self.changed()\n \n@@ -657,7 +656,14 @@ class ScalarMappable:\n         # through the callbacks attached to the norm\n         self.norm.autoscale_None(self._A)\n \n-    def changed(self):\n+    def _norm_changed(self, *args, **kwargs):\n+        \"\"\"\n+        Callback for when the norm changes.\n+        \"\"\"\n+        self.set_clim(self.norm.vmin, self.norm.vmax)\n+        self.changed()\n+\n+    def changed(self, *args, **kwargs):\n         \"\"\"\n         Call this whenever the mappable is changed to notify all the\n         callbackSM listeners to the 'changed' signal.\n", "occurrence": 1, "normalized_patch": "diff --git a/lib/matplotlib/cm.py b/lib/matplotlib/cm.py\nindex f5a7578..f024def 100644\n--- a/lib/matplotlib/cm.py\n+++ b/lib/matplotlib/cm.py\n@@ -191,7 +191,7 @@ class ScalarMappable:\n         if not in_init:\n             self.norm.callbacks.disconnect(self._id_norm)\n         self._norm = norm\n-        self._id_norm = self.norm.callbacks.connect('changed', self.changed)\n+        self._id_norm = self.norm.callbacks.connect('changed', self._norm_changed)\n         if not in_init:\n             self.changed()\n     def set_norm(self, norm):\n@@ -204,7 +204,10 @@ class ScalarMappable:\n         if self._A is None:\n             raise TypeError('You must first set_array for mappable')\n         self.norm.autoscale_None(self._A)\n-    def changed(self):\n+    def _norm_changed(self, *args, **kwargs):\n+        self.set_clim(self.norm.vmin, self.norm.vmax)\n+        self.changed()\n+    def changed(self, *args, **kwargs):\n         self.callbacks.process('changed', self)\n         self.stale = True\n mpl._docstring.interpd.update(cmap_doc='cmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`\\n    The Colormap instance or registered colormap name used to map scalar data\\n    to colors.', norm_doc='norm : str or `~matplotlib.colors.Normalize`, optional\\n    The normalization method used to scale scalar data to the [0, 1] range\\n    before mapping to colors using *cmap*. By default, a linear scaling is\\n    used, mapping the lowest value to 0 and the highest to 1.\\n\\n    If given, this can be one of the following:\\n\\n    - An instance of `.Normalize` or one of its subclasses\\n      (see :doc:`/tutorials/colors/colormapnorms`).\\n    - A scale name, i.e. one of \"linear\", \"log\", \"symlog\", \"logit\", etc.  For a\\n      list of available scales, call `matplotlib.scale.get_scale_names()`.\\n      In that case, a suitable `.Normalize` subclass is dynamically generated\\n      and instantiated.', vmin_vmax_doc='vmin, vmax : float, optional\\n    When using scalar data and no explicit *norm*, *vmin* and *vmax* define\\n    the data range that the colormap covers. By default, the colormap covers\\n    the complete value range of the supplied data. It is an error to use\\n    *vmin*/*vmax* when a *norm* instance is given (but using a `str` *norm*\\n    name together with *vmin*/*vmax* is acceptable).')\n", "normalized_occurrence": 1}
