{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-16792", "model_patch": "diff --git a/sympy/utilities/autowrap.py b/sympy/utilities/autowrap.py\nindex 6b78c94..7718f16 100644\n--- a/sympy/utilities/autowrap.py\n+++ b/sympy/utilities/autowrap.py\n@@ -372,7 +372,7 @@ setup(ext_modules=cythonize(ext_mods, **cy_opts))\n \n             # Function prototype\n             name = routine.name\n-            arg_string = \", \".join(self._prototype_arg(arg) for arg in py_args)\n+            arg_string = \", \".join(self._prototype_arg(arg) for arg in routine.arguments)\n \n             # Local Declarations\n             local_decs = []\n@@ -433,7 +433,7 @@ setup(ext_modules=cythonize(ext_mods, **cy_opts))\n             if arg.name in py_inferred:\n                 py_inferred[arg] = py_inferred.pop(arg.name)\n         # Filter inferred arguments from py_args\n-        py_args = [a for a in py_args if a not in py_inferred]\n+        py_args = [a for a in py_args if a.name not in py_inferred]\n         return py_returns, py_args, py_locals, py_inferred\n \n     def _prototype_arg(self, arg):\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/utilities/autowrap.py b/sympy/utilities/autowrap.py\nindex da40c47..c2266ff 100644\n--- a/sympy/utilities/autowrap.py\n+++ b/sympy/utilities/autowrap.py\n@@ -142,7 +142,7 @@ class CythonCodeWrapper(CodeWrapper):\n             headers.append(self.pyx_header.format(header_file=prefix, prototype=prototype))\n             py_rets, py_args, py_loc, py_inf = self._partition_args(routine.arguments)\n             name = routine.name\n-            arg_string = ', '.join((self._prototype_arg(arg) for arg in py_args))\n+            arg_string = ', '.join((self._prototype_arg(arg) for arg in routine.arguments))\n             local_decs = []\n             for arg, val in py_inf.items():\n                 proto = self._prototype_arg(arg)\n@@ -188,7 +188,7 @@ class CythonCodeWrapper(CodeWrapper):\n         for arg in args:\n             if arg.name in py_inferred:\n                 py_inferred[arg] = py_inferred.pop(arg.name)\n-        py_args = [a for a in py_args if a not in py_inferred]\n+        py_args = [a for a in py_args if a.name not in py_inferred]\n         return (py_returns, py_args, py_locals, py_inferred)\n     def _prototype_arg(self, arg):\n         mat_dec = 'np.ndarray[{mtype}, ndim={ndim}] {name}'\n", "normalized_occurrence": 1}
