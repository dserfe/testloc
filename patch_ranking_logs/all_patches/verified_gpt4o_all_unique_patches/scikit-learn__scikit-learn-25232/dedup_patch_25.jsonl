{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-25232", "model_patch": "diff --git a/sklearn/impute/_iterative.py b/sklearn/impute/_iterative.py\nindex 62cdd57..d011913 100644\n--- a/sklearn/impute/_iterative.py\n+++ b/sklearn/impute/_iterative.py\n@@ -281,6 +281,7 @@ class IterativeImputer(_BaseImputer):\n         \"initial_strategy\": [\n             StrOptions({\"mean\", \"median\", \"most_frequent\", \"constant\"})\n         ],\n+        \"fill_value\": [Real, Integral, StrOptions({\"nan\"}), None],\n         \"imputation_order\": [\n             StrOptions({\"ascending\", \"descending\", \"roman\", \"arabic\", \"random\"})\n         ],\n@@ -308,8 +309,11 @@ class IterativeImputer(_BaseImputer):\n         verbose=0,\n         random_state=None,\n         add_indicator=False,\n+        fill_value=None,\n         keep_empty_features=False,\n     ):\n+        if initial_strategy == \"constant\" and fill_value is None:\n+            raise ValueError(\"fill_value must be specified when initial_strategy='constant'\")\n         super().__init__(\n             missing_values=missing_values,\n             add_indicator=add_indicator,\n@@ -615,8 +619,10 @@ class IterativeImputer(_BaseImputer):\n                 strategy=self.initial_strategy,\n                 keep_empty_features=self.keep_empty_features,\n             )\n+            self.initial_imputer_.fill_value = self.fill_value\n             X_filled = self.initial_imputer_.fit_transform(X)\n         else:\n+            self.initial_imputer_.fill_value = self.fill_value\n             X_filled = self.initial_imputer_.transform(X)\n \n         valid_mask = np.flatnonzero(\n@@ -886,4 +892,4 @@ class IterativeImputer(_BaseImputer):\n         \"\"\"\n         input_features = _check_feature_names_in(self, input_features)\n         names = self.initial_imputer_.get_feature_names_out(input_features)\n-        return self._concatenate_indicator_feature_names_out(names, input_features)\n+        return self._concatenate_indicator_feature_names_out(names, input_features)\n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/impute/_iterative.py b/sklearn/impute/_iterative.py\nindex 2f5de89..24bc229 100644\n--- a/sklearn/impute/_iterative.py\n+++ b/sklearn/impute/_iterative.py\n@@ -22,8 +22,10 @@ def _assign_where(X1, X2, cond):\n     else:\n         X1[cond] = X2[cond]\n class IterativeImputer(_BaseImputer):\n-    _parameter_constraints: dict = {**_BaseImputer._parameter_constraints, 'estimator': [None, HasMethods(['fit', 'predict'])], 'sample_posterior': ['boolean'], 'max_iter': [Interval(Integral, 0, None, closed='left')], 'tol': [Interval(Real, 0, None, closed='left')], 'n_nearest_features': [None, Interval(Integral, 1, None, closed='left')], 'initial_strategy': [StrOptions({'mean', 'median', 'most_frequent', 'constant'})], 'imputation_order': [StrOptions({'ascending', 'descending', 'roman', 'arabic', 'random'})], 'skip_complete': ['boolean'], 'min_value': [None, Interval(Real, None, None, closed='both'), 'array-like'], 'max_value': [None, Interval(Real, None, None, closed='both'), 'array-like'], 'verbose': ['verbose'], 'random_state': ['random_state']}\n-    def __init__(self, estimator=None, *, missing_values=np.nan, sample_posterior=False, max_iter=10, tol=0.001, n_nearest_features=None, initial_strategy='mean', imputation_order='ascending', skip_complete=False, min_value=-np.inf, max_value=np.inf, verbose=0, random_state=None, add_indicator=False, keep_empty_features=False):\n+    _parameter_constraints: dict = {**_BaseImputer._parameter_constraints, 'estimator': [None, HasMethods(['fit', 'predict'])], 'sample_posterior': ['boolean'], 'max_iter': [Interval(Integral, 0, None, closed='left')], 'tol': [Interval(Real, 0, None, closed='left')], 'n_nearest_features': [None, Interval(Integral, 1, None, closed='left')], 'initial_strategy': [StrOptions({'mean', 'median', 'most_frequent', 'constant'})], 'fill_value': [Real, Integral, StrOptions({'nan'}), None], 'imputation_order': [StrOptions({'ascending', 'descending', 'roman', 'arabic', 'random'})], 'skip_complete': ['boolean'], 'min_value': [None, Interval(Real, None, None, closed='both'), 'array-like'], 'max_value': [None, Interval(Real, None, None, closed='both'), 'array-like'], 'verbose': ['verbose'], 'random_state': ['random_state']}\n+    def __init__(self, estimator=None, *, missing_values=np.nan, sample_posterior=False, max_iter=10, tol=0.001, n_nearest_features=None, initial_strategy='mean', imputation_order='ascending', skip_complete=False, min_value=-np.inf, max_value=np.inf, verbose=0, random_state=None, add_indicator=False, fill_value=None, keep_empty_features=False):\n+        if initial_strategy == 'constant' and fill_value is None:\n+            raise ValueError(\"fill_value must be specified when initial_strategy='constant'\")\n         super().__init__(missing_values=missing_values, add_indicator=add_indicator, keep_empty_features=keep_empty_features)\n         self.estimator = estimator\n         self.sample_posterior = sample_posterior\n@@ -122,8 +124,10 @@ class IterativeImputer(_BaseImputer):\n         mask_missing_values = X_missing_mask.copy()\n         if self.initial_imputer_ is None:\n             self.initial_imputer_ = SimpleImputer(missing_values=self.missing_values, strategy=self.initial_strategy, keep_empty_features=self.keep_empty_features)\n+            self.initial_imputer_.fill_value = self.fill_value\n             X_filled = self.initial_imputer_.fit_transform(X)\n         else:\n+            self.initial_imputer_.fill_value = self.fill_value\n             X_filled = self.initial_imputer_.transform(X)\n         valid_mask = np.flatnonzero(np.logical_not(np.isnan(self.initial_imputer_.statistics_)))\n         if not self.keep_empty_features:\n", "normalized_occurrence": 1}
