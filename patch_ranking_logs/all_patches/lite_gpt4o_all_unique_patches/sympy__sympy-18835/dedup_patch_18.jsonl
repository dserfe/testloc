{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-18835", "model_patch": "diff --git a/sympy/utilities/iterables.py b/sympy/utilities/iterables.py\nindex 57371bf..8808253 100644\n--- a/sympy/utilities/iterables.py\n+++ b/sympy/utilities/iterables.py\n@@ -2099,6 +2099,46 @@ def uniq(seq, result=None):\n     >>> type(uniq(dat)) in (list, tuple)\n     False\n \n+    >>> list(uniq(dat))\n+    [1, 4, 5, 2]\n+    >>> list(uniq(x for x in dat))\n+    [1, 4, 5, 2]\n+    >>> list(uniq([[1], [2, 1], [1]]))\n+    [[1], [2, 1]]\n+    \"\"\"\n+    try:\n+        seen = set()\n+        result = result or []\n+        initial_size = len(seq)\n+        \n+        for i, s in enumerate(seq):\n+            if initial_size != len(seq):\n+                raise RuntimeError(\"dictionary changed size during iteration\")\n+            if not (s in seen or seen.add(s)):\n+                yield s\n+    except TypeError:\n+        if s not in result:\n+            yield s\n+            result.append(s)\n+        if hasattr(seq, '__getitem__'):\n+            for s in uniq(seq[i + 1:], result):\n+                yield s\n+        else:\n+            for s in uniq(seq, result):\n+                yield s\n+    \"\"\"\n+    Yield unique elements from ``seq`` as an iterator. The second\n+    parameter ``result``  is used internally; it is not necessary to pass\n+    anything for this.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy.utilities.iterables import uniq\n+    >>> dat = [1, 4, 1, 5, 4, 2, 1, 2]\n+    >>> type(uniq(dat)) in (list, tuple)\n+    False\n+\n     >>> list(uniq(dat))\n     [1, 4, 5, 2]\n     >>> list(uniq(x for x in dat))\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/utilities/iterables.py b/sympy/utilities/iterables.py\nindex 032766e..1656616 100644\n--- a/sympy/utilities/iterables.py\n+++ b/sympy/utilities/iterables.py\n@@ -730,6 +730,26 @@ def has_variety(seq):\n             return True\n     return False\n def uniq(seq, result=None):\n+    try:\n+        seen = set()\n+        result = result or []\n+        initial_size = len(seq)\n+        for i, s in enumerate(seq):\n+            if initial_size != len(seq):\n+                raise RuntimeError('dictionary changed size during iteration')\n+            if not (s in seen or seen.add(s)):\n+                yield s\n+    except TypeError:\n+        if s not in result:\n+            yield s\n+            result.append(s)\n+        if hasattr(seq, '__getitem__'):\n+            for s in uniq(seq[i + 1:], result):\n+                yield s\n+        else:\n+            for s in uniq(seq, result):\n+                yield s\n+    '\\n    Yield unique elements from ``seq`` as an iterator. The second\\n    parameter ``result``  is used internally; it is not necessary to pass\\n    anything for this.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.utilities.iterables import uniq\\n    >>> dat = [1, 4, 1, 5, 4, 2, 1, 2]\\n    >>> type(uniq(dat)) in (list, tuple)\\n    False\\n\\n    >>> list(uniq(dat))\\n    [1, 4, 5, 2]\\n    >>> list(uniq(x for x in dat))\\n    [1, 4, 5, 2]\\n    >>> list(uniq([[1], [2, 1], [1]]))\\n    [[1], [2, 1]]\\n    '\n     try:\n         seen = set()\n         result = result or []\n", "normalized_occurrence": 1}
