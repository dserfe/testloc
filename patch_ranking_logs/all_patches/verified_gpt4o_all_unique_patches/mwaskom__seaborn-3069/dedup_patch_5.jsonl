{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3069", "model_patch": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 1e10d58..5044bc2 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -126,6 +126,11 @@ class Scale:\n     def _identity():\n \n         class Identity(Scale):\n+            def set_default_locators_and_formatters(self, axis):\n+                axis.set_major_locator(mpl.ticker.FixedLocator(range(len(self.values))))\n+                axis.set_major_formatter(mpl.ticker.FixedFormatter(self.values))\n+                axis.set_minor_locator(mpl.ticker.NullLocator())\n+                axis.set_minor_formatter(mpl.ticker.NullFormatter())\n             _pipeline = []\n             _spacer = None\n             _legend = None\n@@ -133,6 +138,98 @@ class Scale:\n \n         return Identity()\n \n+@dataclass\n+class Nominal(Scale):\n+    \"\"\"\n+    A categorical scale without relative importance / magnitude.\n+    \"\"\"\n+    # Categorical (convert to strings), un-sortable\n+\n+    values: tuple | str | list | dict | None = None\n+    order: list | None = None\n+\n+    _priority: ClassVar[int] = 3\n+\n+    def _setup(\n+        self, data: Series, prop: Property, axis: Axis | None = None,\n+    ) -> Scale:\n+\n+        new = copy(self)\n+        if new._tick_params is None:\n+            new = new.tick()\n+        if new._label_params is None:\n+            new = new.label()\n+\n+        # TODO flexibility over format() which isn't great for numbers / dates\n+        stringify = np.vectorize(format)\n+\n+        units_seed = categorical_order(data, new.order)\n+\n+        class CatScale(mpl.scale.LinearScale):\n+            name = None  # To work around mpl<3.4 compat issues\n+\n+            def set_default_locators_and_formatters(self, axis):\n+                axis.set_major_locator(mpl.ticker.FixedLocator(range(len(units_seed))))\n+                axis.set_major_formatter(mpl.ticker.FixedFormatter(units_seed))\n+                axis.set_minor_locator(mpl.ticker.NullLocator())\n+                axis.set_minor_formatter(mpl.ticker.NullFormatter())\n+\n+        mpl_scale = CatScale(data.name)\n+        if axis is None:\n+            axis = PseudoAxis(mpl_scale)\n+            axis.set_view_interval(-0.5, len(units_seed) - 0.5)\n+\n+        new._matplotlib_scale = mpl_scale\n+\n+        axis.update_units(stringify(np.array(units_seed)))\n+\n+        def convert_units(x):\n+            keep = np.array([x_ in units_seed for x_ in x], bool)\n+            out = np.full(len(x), np.nan)\n+            out[keep] = axis.convert_units(stringify(x[keep]))\n+            return out\n+\n+        new._pipeline = [\n+            convert_units,\n+            prop.get_mapping(new, data),\n+        ]\n+\n+        def spacer(x):\n+            return 1\n+\n+        new._spacer = spacer\n+\n+        if prop.legend:\n+            new._legend = units_seed, list(stringify(units_seed))\n+\n+        return new\n+\n+    def tick(self, locator: Locator | None = None):\n+        new = copy(self)\n+        new._tick_params = {\n+            \"locator\": locator,\n+        }\n+        return new\n+\n+    def label(self, formatter: Formatter | None = None):\n+        new = copy(self)\n+        new._label_params = {\n+            \"formatter\": formatter,\n+        }\n+        return new\n+\n+    def _get_locators(self, locator):\n+        if locator is not None:\n+            return locator, None\n+        locator = mpl.category.StrCategoryLocator({})\n+        return locator, None\n+\n+    def _get_formatter(self, locator, formatter):\n+        if formatter is not None:\n+            return formatter\n+        formatter = mpl.category.StrCategoryFormatter({})\n+        return formatter\n+\n \n @dataclass\n class Nominal(Scale):\n", "occurrence": 1, "normalized_patch": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 58a2cdb..34d64bc 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -69,12 +69,73 @@ class Scale:\n     @staticmethod\n     def _identity():\n         class Identity(Scale):\n+            def set_default_locators_and_formatters(self, axis):\n+                axis.set_major_locator(mpl.ticker.FixedLocator(range(len(self.values))))\n+                axis.set_major_formatter(mpl.ticker.FixedFormatter(self.values))\n+                axis.set_minor_locator(mpl.ticker.NullLocator())\n+                axis.set_minor_formatter(mpl.ticker.NullFormatter())\n             _pipeline = []\n             _spacer = None\n             _legend = None\n             _matplotlib_scale = None\n         return Identity()\n @dataclass\n+class Nominal(Scale):\n+    values: tuple | str | list | dict | None = None\n+    order: list | None = None\n+    _priority: ClassVar[int] = 3\n+    def _setup(self, data: Series, prop: Property, axis: Axis | None=None) -> Scale:\n+        new = copy(self)\n+        if new._tick_params is None:\n+            new = new.tick()\n+        if new._label_params is None:\n+            new = new.label()\n+        stringify = np.vectorize(format)\n+        units_seed = categorical_order(data, new.order)\n+        class CatScale(mpl.scale.LinearScale):\n+            name = None\n+            def set_default_locators_and_formatters(self, axis):\n+                axis.set_major_locator(mpl.ticker.FixedLocator(range(len(units_seed))))\n+                axis.set_major_formatter(mpl.ticker.FixedFormatter(units_seed))\n+                axis.set_minor_locator(mpl.ticker.NullLocator())\n+                axis.set_minor_formatter(mpl.ticker.NullFormatter())\n+        mpl_scale = CatScale(data.name)\n+        if axis is None:\n+            axis = PseudoAxis(mpl_scale)\n+            axis.set_view_interval(-0.5, len(units_seed) - 0.5)\n+        new._matplotlib_scale = mpl_scale\n+        axis.update_units(stringify(np.array(units_seed)))\n+        def convert_units(x):\n+            keep = np.array([x_ in units_seed for x_ in x], bool)\n+            out = np.full(len(x), np.nan)\n+            out[keep] = axis.convert_units(stringify(x[keep]))\n+            return out\n+        new._pipeline = [convert_units, prop.get_mapping(new, data)]\n+        def spacer(x):\n+            return 1\n+        new._spacer = spacer\n+        if prop.legend:\n+            new._legend = (units_seed, list(stringify(units_seed)))\n+        return new\n+    def tick(self, locator: Locator | None=None):\n+        new = copy(self)\n+        new._tick_params = {'locator': locator}\n+        return new\n+    def label(self, formatter: Formatter | None=None):\n+        new = copy(self)\n+        new._label_params = {'formatter': formatter}\n+        return new\n+    def _get_locators(self, locator):\n+        if locator is not None:\n+            return (locator, None)\n+        locator = mpl.category.StrCategoryLocator({})\n+        return (locator, None)\n+    def _get_formatter(self, locator, formatter):\n+        if formatter is not None:\n+            return formatter\n+        formatter = mpl.category.StrCategoryFormatter({})\n+        return formatter\n+@dataclass\n class Nominal(Scale):\n     values: tuple | str | list | dict | None = None\n     order: list | None = None\n", "normalized_occurrence": 1}
