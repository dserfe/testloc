{"model_name_or_path": "agentless_claude", "instance_id": "django__django-12858", "model_patch": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 8f934b7..9bc562b 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -18,6 +18,44 @@ def check_all_models(app_configs=None, **kwargs):\n         models = apps.get_models()\n     else:\n         models = chain.from_iterable(app_config.get_models() for app_config in app_configs)\n+        \n+    def _is_valid_ordering(model, field_name):\n+        \"\"\"\n+        Check if a field name is valid for ordering.\n+        Handles related fields, transforms and lookups.\n+        \"\"\"\n+        # Handle reverse relations\n+        if field_name.startswith('-'):\n+            field_name = field_name[1:]\n+            \n+        parts = field_name.split('__')\n+        current_model = model\n+        \n+        # Traverse through foreign key relations\n+        for part in parts[:-1]:\n+            try:\n+                field = current_model._meta.get_field(part)\n+                if hasattr(field, 'related_model'):\n+                    current_model = field.related_model\n+                else:\n+                    return False\n+            except FieldDoesNotExist:\n+                return False\n+                \n+        # Check if the last part is a field or a valid lookup\n+        last_part = parts[-1]\n+        try:\n+            field = current_model._meta.get_field(last_part)\n+            return True\n+        except FieldDoesNotExist:\n+            # Check if it's a valid lookup (like 'isnull')\n+            if len(parts) > 1:\n+                try:\n+                    previous_field = current_model._meta.get_field(parts[-2])\n+                    return last_part in previous_field.get_lookups()\n+                except (FieldDoesNotExist, IndexError):\n+                    pass\n+            return False\n     for model in models:\n         if model._meta.managed and not model._meta.proxy:\n             db_table_models[model._meta.db_table].append(model._meta.label)\n@@ -32,6 +70,17 @@ def check_all_models(app_configs=None, **kwargs):\n             )\n         else:\n             errors.extend(model.check(**kwargs))\n+            \n+        # Check ordering fields\n+        for field_name in model._meta.ordering:\n+            if not _is_valid_ordering(model, field_name):\n+                errors.append(\n+                    Error(\n+                        \"'ordering' refers to the nonexistent field, related field, or lookup '%s'.\" % field_name,\n+                        obj=model,\n+                        id='models.E015',\n+                    )\n+                )\n         for model_index in model._meta.indexes:\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n", "occurrence": 1, "normalized_patch": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 50dfeb8..3c00f01 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -15,6 +15,32 @@ def check_all_models(app_configs=None, **kwargs):\n         models = apps.get_models()\n     else:\n         models = chain.from_iterable((app_config.get_models() for app_config in app_configs))\n+    def _is_valid_ordering(model, field_name):\n+        if field_name.startswith('-'):\n+            field_name = field_name[1:]\n+        parts = field_name.split('__')\n+        current_model = model\n+        for part in parts[:-1]:\n+            try:\n+                field = current_model._meta.get_field(part)\n+                if hasattr(field, 'related_model'):\n+                    current_model = field.related_model\n+                else:\n+                    return False\n+            except FieldDoesNotExist:\n+                return False\n+        last_part = parts[-1]\n+        try:\n+            field = current_model._meta.get_field(last_part)\n+            return True\n+        except FieldDoesNotExist:\n+            if len(parts) > 1:\n+                try:\n+                    previous_field = current_model._meta.get_field(parts[-2])\n+                    return last_part in previous_field.get_lookups()\n+                except (FieldDoesNotExist, IndexError):\n+                    pass\n+            return False\n     for model in models:\n         if model._meta.managed and (not model._meta.proxy):\n             db_table_models[model._meta.db_table].append(model._meta.label)\n@@ -22,6 +48,9 @@ def check_all_models(app_configs=None, **kwargs):\n             errors.append(Error(\"The '%s.check()' class method is currently overridden by %r.\" % (model.__name__, model.check), obj=model, id='models.E020'))\n         else:\n             errors.extend(model.check(**kwargs))\n+        for field_name in model._meta.ordering:\n+            if not _is_valid_ordering(model, field_name):\n+                errors.append(Error(\"'ordering' refers to the nonexistent field, related field, or lookup '%s'.\" % field_name, obj=model, id='models.E015'))\n         for model_index in model._meta.indexes:\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n", "normalized_occurrence": 1}
