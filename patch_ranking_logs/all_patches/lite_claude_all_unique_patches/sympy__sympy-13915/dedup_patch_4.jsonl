{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13915", "model_patch": "diff --git a/sympy/core/basic.py b/sympy/core/basic.py\nindex 0977e81..49bf1f6 100644\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -931,6 +931,9 @@ class Basic(with_metaclass(ManagedProperties)):\n         then a None is received which indicates that the fallback\n         should be applied wherein a search for replacements is made\n         amongst the arguments of self.\n+        \n+        If the substitution would result in an undefined expression\n+        (like division by zero), the original expression is returned.\n \n         >>> from sympy import Add\n         >>> from sympy.abc import x, y, z\n@@ -1027,11 +1030,25 @@ class Basic(with_metaclass(ManagedProperties)):\n             return self\n \n         if _aresame(self, old):\n-            return new\n+            try:\n+                # Check if new expression would be undefined\n+                if new.is_finite is not None and not new.is_finite:\n+                    return self\n+                return new\n+            except:\n+                return self\n \n         rv = self._eval_subs(old, new)\n         if rv is None:\n             rv = fallback(self, old, new)\n+        \n+        # Check if resulting expression would be undefined\n+        try:\n+            if rv.is_finite is not None and not rv.is_finite:\n+                return self\n+        except:\n+            pass\n+            \n         return rv\n \n     def _eval_subs(self, old, new):\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/basic.py b/sympy/core/basic.py\nindex 782db85..338e27b 100644\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -361,10 +361,20 @@ class Basic(with_metaclass(ManagedProperties)):\n                 return rv\n             return self\n         if _aresame(self, old):\n-            return new\n+            try:\n+                if new.is_finite is not None and (not new.is_finite):\n+                    return self\n+                return new\n+            except:\n+                return self\n         rv = self._eval_subs(old, new)\n         if rv is None:\n             rv = fallback(self, old, new)\n+        try:\n+            if rv.is_finite is not None and (not rv.is_finite):\n+                return self\n+        except:\n+            pass\n         return rv\n     def _eval_subs(self, old, new):\n         return None\n", "normalized_occurrence": 1}
