{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-10908", "model_patch": "diff --git a/sklearn/feature_extraction/text.py b/sklearn/feature_extraction/text.py\nindex 7e240fc..e51e0f4 100644\n--- a/sklearn/feature_extraction/text.py\n+++ b/sklearn/feature_extraction/text.py\n@@ -301,7 +301,8 @@ class VectorizerMixin(object):\n     def _check_vocabulary(self):\n         \"\"\"Check if vocabulary is empty or missing (not fit-ed)\"\"\"\n         msg = \"%(name)s - Vocabulary wasn't fitted.\"\n-        check_is_fitted(self, 'vocabulary_', msg=msg),\n+        if not hasattr(self, 'vocabulary_') and not hasattr(self, 'fixed_vocabulary_'):\n+            check_is_fitted(self, 'vocabulary_', msg=msg)\n \n         if len(self.vocabulary_) == 0:\n             raise ValueError(\"Vocabulary is empty\")\n@@ -953,6 +954,8 @@ class CountVectorizer(BaseEstimator, VectorizerMixin):\n         if not hasattr(self, 'vocabulary_'):\n             self._validate_vocabulary()\n \n+        if not hasattr(self, \"vocabulary_\"):\n+            self._validate_vocabulary()\n         self._check_vocabulary()\n \n         # use the same matrix-building strategy as fit_transform\n@@ -993,6 +996,8 @@ class CountVectorizer(BaseEstimator, VectorizerMixin):\n \n     def get_feature_names(self):\n         \"\"\"Array mapping from feature integer indices to feature name\"\"\"\n+        if not hasattr(self, \"vocabulary_\"):\n+            self._validate_vocabulary()\n         self._check_vocabulary()\n \n         return [t for t, i in sorted(six.iteritems(self.vocabulary_),\n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/feature_extraction/text.py b/sklearn/feature_extraction/text.py\nindex 583049b..f471b32 100644\n--- a/sklearn/feature_extraction/text.py\n+++ b/sklearn/feature_extraction/text.py\n@@ -165,7 +165,8 @@ class VectorizerMixin(object):\n             self.fixed_vocabulary_ = False\n     def _check_vocabulary(self):\n         msg = \"%(name)s - Vocabulary wasn't fitted.\"\n-        (check_is_fitted(self, 'vocabulary_', msg=msg),)\n+        if not hasattr(self, 'vocabulary_') and (not hasattr(self, 'fixed_vocabulary_')):\n+            check_is_fitted(self, 'vocabulary_', msg=msg)\n         if len(self.vocabulary_) == 0:\n             raise ValueError('Vocabulary is empty')\n     def _validate_params(self):\n@@ -347,6 +348,8 @@ class CountVectorizer(BaseEstimator, VectorizerMixin):\n             raise ValueError('Iterable over raw text documents expected, string object received.')\n         if not hasattr(self, 'vocabulary_'):\n             self._validate_vocabulary()\n+        if not hasattr(self, 'vocabulary_'):\n+            self._validate_vocabulary()\n         self._check_vocabulary()\n         _, X = self._count_vocab(raw_documents, fixed_vocab=True)\n         if self.binary:\n@@ -364,6 +367,8 @@ class CountVectorizer(BaseEstimator, VectorizerMixin):\n         inverse_vocabulary = terms[np.argsort(indices)]\n         return [inverse_vocabulary[X[i, :].nonzero()[1]].ravel() for i in range(n_samples)]\n     def get_feature_names(self):\n+        if not hasattr(self, 'vocabulary_'):\n+            self._validate_vocabulary()\n         self._check_vocabulary()\n         return [t for t, i in sorted(six.iteritems(self.vocabulary_), key=itemgetter(1))]\n def _make_int_array():\n", "normalized_occurrence": 1}
