{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8551", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex f44a82b..b1be0a4 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -85,11 +85,7 @@ def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xr\n     else:\n         reftype = 'class'\n \n-    if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'),\n-                  'py:class': env.ref_context.get('py:class')}\n-    else:\n-        kwargs = {}\n+    kwargs = {'py:module': env.ref_context.get('py:module')} if env else {}\n \n     return pending_xref('', nodes.Text(text),\n                         refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n@@ -1250,6 +1246,12 @@ class PythonDomain(Domain):\n \n         newname = None\n         if searchmode == 1:\n+            if modname:\n+                # Attempt to resolve within the current module first\n+                if classname and modname + '.' + classname + '.' + name in self.objects:\n+                    newname = modname + '.' + classname + '.' + name\n+                elif modname + '.' + name in self.objects:\n+                    newname = modname + '.' + name\n             if type is None:\n                 objtypes = list(self.object_types)\n             else:\n@@ -1278,7 +1280,8 @@ class PythonDomain(Domain):\n             elif type == 'mod':\n                 # only exact matches allowed for modules\n                 return []\n-            elif classname and classname + '.' + name in self.objects:\n+            elif modname and classname and modname + '.' + classname + '.' + name in self.objects:\n+                newname = modname + '.' + classname + '.' + name\n                 newname = classname + '.' + name\n             elif modname and modname + '.' + name in self.objects:\n                 newname = modname + '.' + name\n", "occurrence": 1, "normalized_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 2ce105a..b3134f6 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -39,10 +39,7 @@ def type_to_xref(text: str, env: BuildEnvironment=None) -> addnodes.pending_xref\n         reftype = 'obj'\n     else:\n         reftype = 'class'\n-    if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'), 'py:class': env.ref_context.get('py:class')}\n-    else:\n-        kwargs = {}\n+    kwargs = {'py:module': env.ref_context.get('py:module')} if env else {}\n     return pending_xref('', nodes.Text(text), refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n def _parse_annotation(annotation: str, env: BuildEnvironment=None) -> List[Node]:\n     def unparse(node: ast.AST) -> List[Node]:\n@@ -749,6 +746,11 @@ class PythonDomain(Domain):\n         matches = []\n         newname = None\n         if searchmode == 1:\n+            if modname:\n+                if classname and modname + '.' + classname + '.' + name in self.objects:\n+                    newname = modname + '.' + classname + '.' + name\n+                elif modname + '.' + name in self.objects:\n+                    newname = modname + '.' + name\n             if type is None:\n                 objtypes = list(self.object_types)\n             else:\n@@ -770,7 +772,8 @@ class PythonDomain(Domain):\n             newname = name\n         elif type == 'mod':\n             return []\n-        elif classname and classname + '.' + name in self.objects:\n+        elif modname and classname and (modname + '.' + classname + '.' + name in self.objects):\n+            newname = modname + '.' + classname + '.' + name\n             newname = classname + '.' + name\n         elif modname and modname + '.' + name in self.objects:\n             newname = modname + '.' + name\n", "normalized_occurrence": 1}
