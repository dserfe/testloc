{"model_name_or_path": "agentless_claude", "instance_id": "django__django-14997", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 8cfc221..4c4a15a 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1219,9 +1219,8 @@ class BaseDatabaseSchemaEditor:\n             not self.connection.features.supports_deferrable_unique_constraints\n         ):\n             return None\n-        if condition or include or opclasses or expressions:\n-            # Databases support conditional, covering, and functional unique\n-            # constraints via a unique index.\n+        if condition or include or opclasses:\n+            # Databases support conditional and covering unique constraints via a unique index.\n             sql = self._create_unique_sql(\n                 model,\n                 fields,\n@@ -1234,6 +1233,33 @@ class BaseDatabaseSchemaEditor:\n             if sql:\n                 self.deferred_sql.append(sql)\n             return None\n+        # Handle expressions by converting them to column references\n+        columns = []\n+        if fields:\n+            columns.extend(field.column for field in fields)\n+        if expressions:\n+            for expr in expressions:\n+                if hasattr(expr, 'refs'):  # F() expressions\n+                    columns.append(expr.refs)\n+                else:\n+                    # For other expressions, fall back to index\n+                    sql = self._create_unique_sql(\n+                        model,\n+                        fields,\n+                        name=name,\n+                        expressions=expressions,\n+                    )\n+                    if sql:\n+                        self.deferred_sql.append(sql)\n+                    return None\n+        constraint = self.sql_unique_constraint % {\n+            'columns': ', '.join([self.quote_name(col) for col in columns]),\n+            'deferrable': self._deferrable_constraint_sql(deferrable),\n+        }\n+        return self.sql_constraint % {\n+            'name': self.quote_name(name),\n+            'constraint': constraint,\n+        }\n         constraint = self.sql_unique_constraint % {\n             'columns': ', '.join([self.quote_name(field.column) for field in fields]),\n             'deferrable': self._deferrable_constraint_sql(deferrable),\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex a8d38b8..5baf3f9 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -572,11 +572,25 @@ class BaseDatabaseSchemaEditor:\n     def _unique_sql(self, model, fields, name, condition=None, deferrable=None, include=None, opclasses=None, expressions=None):\n         if deferrable and (not self.connection.features.supports_deferrable_unique_constraints):\n             return None\n-        if condition or include or opclasses or expressions:\n+        if condition or include or opclasses:\n             sql = self._create_unique_sql(model, fields, name=name, condition=condition, include=include, opclasses=opclasses, expressions=expressions)\n             if sql:\n                 self.deferred_sql.append(sql)\n             return None\n+        columns = []\n+        if fields:\n+            columns.extend((field.column for field in fields))\n+        if expressions:\n+            for expr in expressions:\n+                if hasattr(expr, 'refs'):\n+                    columns.append(expr.refs)\n+                else:\n+                    sql = self._create_unique_sql(model, fields, name=name, expressions=expressions)\n+                    if sql:\n+                        self.deferred_sql.append(sql)\n+                    return None\n+        constraint = self.sql_unique_constraint % {'columns': ', '.join([self.quote_name(col) for col in columns]), 'deferrable': self._deferrable_constraint_sql(deferrable)}\n+        return self.sql_constraint % {'name': self.quote_name(name), 'constraint': constraint}\n         constraint = self.sql_unique_constraint % {'columns': ', '.join([self.quote_name(field.column) for field in fields]), 'deferrable': self._deferrable_constraint_sql(deferrable)}\n         return self.sql_constraint % {'name': self.quote_name(name), 'constraint': constraint}\n     def _create_unique_sql(self, model, fields, name=None, condition=None, deferrable=None, include=None, opclasses=None, expressions=None):\n", "normalized_occurrence": 1}
