{"model_name_or_path": "agentless_claude", "instance_id": "django__django-14351", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 9591387..134b678 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1149,32 +1149,16 @@ class Query(BaseExpression):\n             for expr in expression.get_source_expressions():\n                 self.check_filterable(expr)\n \n-    def build_lookup(self, lookups, lhs, rhs):\n-        \"\"\"\n-        Try to extract transforms and lookup from given lhs.\n \n-        The lhs value is something that works like SQLExpression.\n-        The rhs value is what the lookup is going to compare against.\n-        The lookups is a list of names to extract using get_lookup()\n-        and get_transform().\n-        \"\"\"\n-        # __exact is the default lookup if one isn't given.\n-        *transforms, lookup_name = lookups or ['exact']\n-        for name in transforms:\n-            lhs = self.try_transform(lhs, name)\n-        # First try get_lookup() so that the lookup takes precedence if the lhs\n-        # supports both transform and lookup for the name.\n-        lookup_class = lhs.get_lookup(lookup_name)\n-        if not lookup_class:\n-            if lhs.field.is_relation:\n-                raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))\n-            # A lookup wasn't found. Try to interpret the name as a transform\n-            # and do an Exact lookup against it.\n-            lhs = self.try_transform(lhs, lookup_name)\n-            lookup_name = 'exact'\n-            lookup_class = lhs.get_lookup(lookup_name)\n-            if not lookup_class:\n-                return\n+\n+        # For __in lookups with querysets on relations, ensure only the ID field is selected\n+        if (lookup_name == 'in' and \n+            isinstance(rhs, Query) and \n+            lhs.field.is_relation and \n+            not rhs.has_select_fields):\n+            rhs.clear_select_clause()\n+            pk_field = lhs.field.remote_field.model._meta.pk\n+            rhs.add_fields([pk_field.name], allow_m2m=True)\n \n         lookup = lookup_class(lhs, rhs)\n         # Interpret '__exact=None' as the sql 'is NULL'; otherwise, reject all\n", "normalized_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ec726d6..af424f3 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -632,19 +632,10 @@ class Query(BaseExpression):\n         if hasattr(expression, 'get_source_expressions'):\n             for expr in expression.get_source_expressions():\n                 self.check_filterable(expr)\n-    def build_lookup(self, lookups, lhs, rhs):\n-        *transforms, lookup_name = lookups or ['exact']\n-        for name in transforms:\n-            lhs = self.try_transform(lhs, name)\n-        lookup_class = lhs.get_lookup(lookup_name)\n-        if not lookup_class:\n-            if lhs.field.is_relation:\n-                raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))\n-            lhs = self.try_transform(lhs, lookup_name)\n-            lookup_name = 'exact'\n-            lookup_class = lhs.get_lookup(lookup_name)\n-            if not lookup_class:\n-                return\n+        if lookup_name == 'in' and isinstance(rhs, Query) and lhs.field.is_relation and (not rhs.has_select_fields):\n+            rhs.clear_select_clause()\n+            pk_field = lhs.field.remote_field.model._meta.pk\n+            rhs.add_fields([pk_field.name], allow_m2m=True)\n         lookup = lookup_class(lhs, rhs)\n         if lookup.rhs is None and (not lookup.can_use_none_as_rhs):\n             if lookup_name not in ('exact', 'iexact'):\n", "normalized_occurrence": 1}
