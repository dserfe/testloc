{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4094", "model_patch": "diff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 7838e8d..823553a 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -1463,7 +1463,7 @@ class Variable(\n                 \"name as an existing dimension\"\n             )\n \n-        if np.prod(new_dim_sizes) != self.sizes[old_dim]:\n+        if np.prod(new_dim_sizes) != self.sizes[old_dim] and len(new_dim_sizes) != 1:\n             raise ValueError(\n                 \"the product of the new dimension sizes must \"\n                 \"equal the size of the old dimension\"\n", "occurrence": 1, "normalized_patch": "diff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 44b3a8e..beda11b 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -1113,7 +1113,7 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic, utils.NdimSi\n             raise ValueError('invalid existing dimension: %s' % old_dim)\n         if set(new_dim_names).intersection(self.dims):\n             raise ValueError('cannot create a new dimension with the same name as an existing dimension')\n-        if np.prod(new_dim_sizes) != self.sizes[old_dim]:\n+        if np.prod(new_dim_sizes) != self.sizes[old_dim] and len(new_dim_sizes) != 1:\n             raise ValueError('the product of the new dimension sizes must equal the size of the old dimension')\n         other_dims = [d for d in self.dims if d != old_dim]\n         dim_order = other_dims + [old_dim]\n", "normalized_occurrence": 1}
