{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3069", "model_patch": "diff --git a/seaborn/categorical.py b/seaborn/categorical.py\nindex ec4f4c2..ef66e2e 100644\n--- a/seaborn/categorical.py\n+++ b/seaborn/categorical.py\n@@ -192,36 +192,28 @@ class _CategoricalPlotterNew(_RelationalPlotter):\n         lum = min(light_vals) * .6\n         return (lum, lum, lum)\n \n-    def _adjust_cat_axis(self, ax, axis):\n-        \"\"\"Set ticks and limits for a categorical variable.\"\"\"\n-        # Note: in theory, this could happen in _attach for all categorical axes\n-        # But two reasons not to do that:\n-        # - If it happens before plotting, autoscaling messes up the plot limits\n-        # - It would change existing plots from other seaborn functions\n-        if self.var_types[axis] != \"categorical\":\n-            return\n-\n-        # If both x/y data are empty, the correct way to set up the plot is\n-        # somewhat undefined; because we don't add null category data to the plot in\n-        # this case we don't *have* a categorical axis (yet), so best to just bail.\n-        if self.plot_data[axis].empty:\n-            return\n-\n-        # We can infer the total number of categories (including those from previous\n-        # plots that are not part of the plot we are currently making) from the number\n-        # of ticks, which matplotlib sets up while doing unit conversion. This feels\n-        # slightly risky, as if we are relying on something that may be a matplotlib\n-        # implementation detail. But I cannot think of a better way to keep track of\n-        # the state from previous categorical calls (see GH2516 for context)\n-        n = len(getattr(ax, f\"get_{axis}ticks\")())\n-\n-        if axis == \"x\":\n-            ax.xaxis.grid(False)\n-            ax.set_xlim(-.5, n - .5, auto=None)\n-        else:\n-            ax.yaxis.grid(False)\n-            # Note limits that correspond to previously-inverted y axis\n-            ax.set_ylim(n - .5, -.5, auto=None)\n+        if self.var_types[axis] in [\"categorical\", \"nominal\"]:\n+            # If both x/y data are empty, the correct way to set up the plot is\n+            # somewhat undefined; because we don't add null category data to the plot in\n+            # this case we don't *have* a categorical axis (yet), so best to just bail.\n+            if self.plot_data[axis].empty:\n+                return\n+\n+            # We can infer the total number of categories (including those from previous\n+            # plots that are not part of the plot we are currently making) from the number\n+            # of ticks, which matplotlib sets up while doing unit conversion. This feels\n+            # slightly risky, as if we are relying on something that may be a matplotlib\n+            # implementation detail. But I cannot think of a better way to keep track of\n+            # the state from previous categorical calls (see GH2516 for context)\n+            n = len(getattr(ax, f\"get_{axis}ticks\")())\n+\n+            if axis == \"x\":\n+                ax.xaxis.grid(False)\n+                ax.set_xlim(-.5, n - .5, auto=None)\n+            else:\n+                ax.yaxis.grid(False)\n+                # Note limits that correspond to previously-inverted y axis\n+                ax.set_ylim(n - .5, -.5, auto=None)\n \n     @property\n     def _native_width(self):\n", "occurrence": 1, "normalized_patch": "diff --git a/seaborn/categorical.py b/seaborn/categorical.py\nindex 7d6d43d..ba55059 100644\n--- a/seaborn/categorical.py\n+++ b/seaborn/categorical.py\n@@ -93,18 +93,16 @@ class _CategoricalPlotterNew(_RelationalPlotter):\n         light_vals = [rgb_to_hls(*rgb[:3])[1] for rgb in unique_colors]\n         lum = min(light_vals) * 0.6\n         return (lum, lum, lum)\n-    def _adjust_cat_axis(self, ax, axis):\n-        if self.var_types[axis] != 'categorical':\n-            return\n-        if self.plot_data[axis].empty:\n-            return\n-        n = len(getattr(ax, f'get_{axis}ticks')())\n-        if axis == 'x':\n-            ax.xaxis.grid(False)\n-            ax.set_xlim(-0.5, n - 0.5, auto=None)\n-        else:\n-            ax.yaxis.grid(False)\n-            ax.set_ylim(n - 0.5, -0.5, auto=None)\n+        if self.var_types[axis] in ['categorical', 'nominal']:\n+            if self.plot_data[axis].empty:\n+                return\n+            n = len(getattr(ax, f'get_{axis}ticks')())\n+            if axis == 'x':\n+                ax.xaxis.grid(False)\n+                ax.set_xlim(-0.5, n - 0.5, auto=None)\n+            else:\n+                ax.yaxis.grid(False)\n+                ax.set_ylim(n - 0.5, -0.5, auto=None)\n     @property\n     def _native_width(self):\n         unique_values = np.unique(self.comp_data[self.cat_axis])\n", "normalized_occurrence": 1}
