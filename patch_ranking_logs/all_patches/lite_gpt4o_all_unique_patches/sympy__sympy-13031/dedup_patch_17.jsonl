{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13031", "model_patch": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex a79ab56..1dd7d46 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -18,7 +18,31 @@ from sympy.matrices.expressions.inverse import Inverse\n from sympy.matrices import Matrix, ShapeError\n from sympy.functions.elementary.complexes import re, im\n \n+from sympy.matrices import hstack as matrix_hstack\n+\n class BlockMatrix(MatrixExpr):\n+    @staticmethod\n+    def hstack(*matrices):\n+        \"\"\"Stack matrices horizontally.\n+        \n+        Examples\n+        ========\n+        \n+        >>> from sympy import Matrix\n+        >>> M1 = Matrix.zeros(0, 0)\n+        >>> M2 = Matrix.zeros(0, 1)\n+        >>> M3 = Matrix.zeros(0, 2)\n+        >>> M4 = Matrix.zeros(0, 3)\n+        >>> BlockMatrix.hstack(M1, M2, M3, M4).shape\n+        (0, 6)\n+        \"\"\"\n+        if any(m.shape[0] != matrices[0].shape[0] for m in matrices):\n+            raise ShapeError(\"Matrices must have the same number of rows to horizontally stack\")\n+            \n+        if all(m.shape[0] == 0 for m in matrices):\n+            return Matrix.zeros(0, sum(m.shape[1] for m in matrices))\n+        \n+        return matrix_hstack(*matrices)\n     \"\"\"A BlockMatrix is a Matrix composed of other smaller, submatrices\n \n     The submatrices are stored in a SymPy Matrix object but accessed as part of\n", "occurrence": 1, "normalized_patch": "--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n+from sympy.matrices import hstack as matrix_hstack\n+    @staticmethod\n+    def hstack(*matrices):\n+        if any((m.shape[0] != matrices[0].shape[0] for m in matrices)):\n+            raise ShapeError('Matrices must have the same number of rows to horizontally stack')\n+        if all((m.shape[0] == 0 for m in matrices)):\n+            return Matrix.zeros(0, sum((m.shape[1] for m in matrices)))\n+        return matrix_hstack(*matrices)\n+    \"A BlockMatrix is a Matrix composed of other smaller, submatrices\\n\\n    The submatrices are stored in a SymPy Matrix object but accessed as part of\\n    a Matrix Expression\\n\\n    >>> from sympy import (MatrixSymbol, BlockMatrix, symbols,\\n    ...     Identity, ZeroMatrix, block_collapse)\\n    >>> n,m,l = symbols('n m l')\\n    >>> X = MatrixSymbol('X', n, n)\\n    >>> Y = MatrixSymbol('Y', m ,m)\\n    >>> Z = MatrixSymbol('Z', n, m)\\n    >>> B = BlockMatrix([[X, Z], [ZeroMatrix(m,n), Y]])\\n    >>> print(B)\\n    Matrix([\\n    [X, Z],\\n    [0, Y]])\\n\\n    >>> C = BlockMatrix([[Identity(n), Z]])\\n    >>> print(C)\\n    Matrix([[I, Z]])\\n\\n    >>> print(block_collapse(C*B))\\n    Matrix([[X, Z*Y + Z]])\\n\\n    \"", "normalized_occurrence": 1}
