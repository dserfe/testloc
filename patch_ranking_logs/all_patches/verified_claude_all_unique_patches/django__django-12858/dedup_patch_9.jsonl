{"model_name_or_path": "agentless_claude", "instance_id": "django__django-12858", "model_patch": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 8f934b7..74b1445 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -6,9 +6,46 @@ from itertools import chain\n from django.apps import apps\n from django.conf import settings\n from django.core.checks import Error, Tags, Warning, register\n+from django.db.models.lookups import Lookup\n+from django.db.models.query_utils import Q\n \n \n @register(Tags.models)\n+def _check_ordering(model):\n+    \"\"\"\n+    Check that ordering refers to valid fields and lookups.\n+    \"\"\"\n+    errors = []\n+    for field_name in model._meta.ordering:\n+        if isinstance(field_name, (str, bytes)) and field_name.startswith('-'):\n+            field_name = field_name[1:]\n+        elif isinstance(field_name, Q):\n+            continue\n+        \n+        if isinstance(field_name, (str, bytes)) and field_name != '?':\n+            field, lookup_parts, has_lookup = _get_field_and_lookup(model, field_name)\n+            \n+            if field is None and not has_lookup:\n+                errors.append(\n+                    Error(\n+                        \"'ordering' refers to the nonexistent field '%s'.\" % field_name,\n+                        obj=model,\n+                        id='models.E015',\n+                    )\n+                )\n+            elif has_lookup and lookup_parts:\n+                # Validate that the lookup exists\n+                if lookup_parts[-1] not in field.get_lookups():\n+                    errors.append(\n+                        Error(\n+                            \"'ordering' refers to '%s' which is not a supported lookup.\"\n+                            % field_name,\n+                            obj=model,\n+                            id='models.E015',\n+                        )\n+                    )\n+    return errors\n+\n def check_all_models(app_configs=None, **kwargs):\n     db_table_models = defaultdict(list)\n     indexes = defaultdict(list)\n@@ -32,6 +69,7 @@ def check_all_models(app_configs=None, **kwargs):\n             )\n         else:\n             errors.extend(model.check(**kwargs))\n+            errors.extend(_check_ordering(model))\n         for model_index in model._meta.indexes:\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n@@ -86,6 +124,34 @@ def check_all_models(app_configs=None, **kwargs):\n     return errors\n \n \n+def _get_field_and_lookup(model, field_name):\n+    \"\"\"\n+    Helper to split a field name into field parts and a possible lookup.\n+    Returns a tuple of (field, lookup_parts, has_lookup).\n+    \"\"\"\n+    parts = field_name.split('__')\n+    field = None\n+    has_lookup = False\n+    lookup_parts = []\n+    \n+    for idx, part in enumerate(parts):\n+        if field is None:\n+            # First iteration\n+            try:\n+                field = model._meta.get_field(part)\n+            except Exception:\n+                break\n+        else:\n+            try:\n+                field = field.get_path_info()[-1].target_fields[-1]\n+                field = model._meta.get_field(part)\n+            except Exception:\n+                lookup_parts = parts[idx:]\n+                has_lookup = True\n+                break\n+                \n+    return field, lookup_parts, has_lookup\n+\n def _check_lazy_references(apps, ignore=None):\n     \"\"\"\n     Ensure all lazy (i.e. string) model references have been resolved.\n", "occurrence": 1, "normalized_patch": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 50dfeb8..8b9b5ac 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -5,7 +5,24 @@ from itertools import chain\n from django.apps import apps\n from django.conf import settings\n from django.core.checks import Error, Tags, Warning, register\n+from django.db.models.lookups import Lookup\n+from django.db.models.query_utils import Q\n @register(Tags.models)\n+def _check_ordering(model):\n+    errors = []\n+    for field_name in model._meta.ordering:\n+        if isinstance(field_name, (str, bytes)) and field_name.startswith('-'):\n+            field_name = field_name[1:]\n+        elif isinstance(field_name, Q):\n+            continue\n+        if isinstance(field_name, (str, bytes)) and field_name != '?':\n+            field, lookup_parts, has_lookup = _get_field_and_lookup(model, field_name)\n+            if field is None and (not has_lookup):\n+                errors.append(Error(\"'ordering' refers to the nonexistent field '%s'.\" % field_name, obj=model, id='models.E015'))\n+            elif has_lookup and lookup_parts:\n+                if lookup_parts[-1] not in field.get_lookups():\n+                    errors.append(Error(\"'ordering' refers to '%s' which is not a supported lookup.\" % field_name, obj=model, id='models.E015'))\n+    return errors\n def check_all_models(app_configs=None, **kwargs):\n     db_table_models = defaultdict(list)\n     indexes = defaultdict(list)\n@@ -22,6 +39,7 @@ def check_all_models(app_configs=None, **kwargs):\n             errors.append(Error(\"The '%s.check()' class method is currently overridden by %r.\" % (model.__name__, model.check), obj=model, id='models.E020'))\n         else:\n             errors.extend(model.check(**kwargs))\n+            errors.extend(_check_ordering(model))\n         for model_index in model._meta.indexes:\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n@@ -45,6 +63,26 @@ def check_all_models(app_configs=None, **kwargs):\n             model_labels = set(model_labels)\n             errors.append(Error(\"constraint name '%s' is not unique %s %s.\" % (constraint_name, 'for model' if len(model_labels) == 1 else 'amongst models:', ', '.join(sorted(model_labels))), id='models.E031' if len(model_labels) == 1 else 'models.E032'))\n     return errors\n+def _get_field_and_lookup(model, field_name):\n+    parts = field_name.split('__')\n+    field = None\n+    has_lookup = False\n+    lookup_parts = []\n+    for idx, part in enumerate(parts):\n+        if field is None:\n+            try:\n+                field = model._meta.get_field(part)\n+            except Exception:\n+                break\n+        else:\n+            try:\n+                field = field.get_path_info()[-1].target_fields[-1]\n+                field = model._meta.get_field(part)\n+            except Exception:\n+                lookup_parts = parts[idx:]\n+                has_lookup = True\n+                break\n+    return (field, lookup_parts, has_lookup)\n def _check_lazy_references(apps, ignore=None):\n     pending_models = set(apps._pending_operations) - (ignore or set())\n     if not pending_models:\n", "normalized_occurrence": 1}
