{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13974", "model_patch": "diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py\nindex 153c783..c6825d9 100644\n--- a/sympy/physics/quantum/tensorproduct.py\n+++ b/sympy/physics/quantum/tensorproduct.py\n@@ -272,10 +272,8 @@ def tensor_product_simp_Mul(e):\n     \"\"\"Simplify a Mul with TensorProducts.\n \n     Current the main use of this is to simplify a ``Mul`` of ``TensorProduct``s\n-    to a ``TensorProduct`` of ``Muls``. It currently only works for relatively\n-    simple cases where the initial ``Mul`` only has scalars and raw\n-    ``TensorProduct``s, not ``Add``, ``Pow``, ``Commutator``s of\n-    ``TensorProduct``s.\n+    to a ``TensorProduct`` of ``Muls``. It handles products of identical tensor\n+    products by combining their components into products.\n \n     Parameters\n     ==========\n@@ -384,7 +382,33 @@ def tensor_product_simp(e, **hints):\n     elif isinstance(e, Pow):\n         return tensor_product_simp(e.base) ** e.exp\n     elif isinstance(e, Mul):\n-        return tensor_product_simp_Mul(e)\n+        # Handle products of tensor products\n+        args = e.args\n+        tp_dict = {}\n+        scalar = []\n+        \n+        # Group identical tensor products\n+        for arg in args:\n+            if isinstance(arg, TensorProduct):\n+                key = tuple(arg.args)\n+                tp_dict[key] = tp_dict.get(key, 0) + 1\n+            else:\n+                scalar.append(arg)\n+        \n+        # If no tensor products found, return original expression\n+        if not tp_dict:\n+            return e\n+            \n+        # Combine the tensor products\n+        result_args = []\n+        for tp_args, count in tp_dict.items():\n+            new_args = tuple(arg**count for arg in tp_args)\n+            result_args.append(TensorProduct(*new_args))\n+            \n+        # Multiply all parts together\n+        if scalar:\n+            return Mul(*(scalar + result_args))\n+        return Mul(*result_args)\n     elif isinstance(e, Commutator):\n         return Commutator(*[tensor_product_simp(arg) for arg in e.args])\n     elif isinstance(e, AntiCommutator):\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py\nindex e23a275..a742732 100644\n--- a/sympy/physics/quantum/tensorproduct.py\n+++ b/sympy/physics/quantum/tensorproduct.py\n@@ -163,7 +163,24 @@ def tensor_product_simp(e, **hints):\n     elif isinstance(e, Pow):\n         return tensor_product_simp(e.base) ** e.exp\n     elif isinstance(e, Mul):\n-        return tensor_product_simp_Mul(e)\n+        args = e.args\n+        tp_dict = {}\n+        scalar = []\n+        for arg in args:\n+            if isinstance(arg, TensorProduct):\n+                key = tuple(arg.args)\n+                tp_dict[key] = tp_dict.get(key, 0) + 1\n+            else:\n+                scalar.append(arg)\n+        if not tp_dict:\n+            return e\n+        result_args = []\n+        for tp_args, count in tp_dict.items():\n+            new_args = tuple((arg ** count for arg in tp_args))\n+            result_args.append(TensorProduct(*new_args))\n+        if scalar:\n+            return Mul(*scalar + result_args)\n+        return Mul(*result_args)\n     elif isinstance(e, Commutator):\n         return Commutator(*[tensor_product_simp(arg) for arg in e.args])\n     elif isinstance(e, AntiCommutator):\n", "normalized_occurrence": 1}
