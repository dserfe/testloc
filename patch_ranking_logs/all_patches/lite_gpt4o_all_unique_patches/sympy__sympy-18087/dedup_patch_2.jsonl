{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-18087", "model_patch": "diff --git a/sympy/functions/elementary/trigonometric.py b/sympy/functions/elementary/trigonometric.py\nindex 5205b6e..111fb72 100644\n--- a/sympy/functions/elementary/trigonometric.py\n+++ b/sympy/functions/elementary/trigonometric.py\n@@ -296,10 +296,11 @@ class sin(TrigonometricFunction):\n         elif isinstance(arg, SetExpr):\n             return arg._eval_func(cls)\n \n+        if arg.is_complex and arg.has(S.ImaginaryUnit):\n+            return S.ImaginaryUnit * sinh(arg.as_coefficient(S.ImaginaryUnit)) if cls == sin else cosh(arg.as_coefficient(S.ImaginaryUnit))\n+\n         if arg.could_extract_minus_sign():\n             return -cls(-arg)\n-\n-        i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n         if i_coeff is not None:\n             return S.ImaginaryUnit * sinh(i_coeff)\n \n@@ -1007,10 +1008,11 @@ class tan(TrigonometricFunction):\n             else:\n                 return AccumBounds(tan(min), tan(max))\n \n+        if arg.is_complex and arg.has(S.ImaginaryUnit):\n+            return S.ImaginaryUnit * sinh(arg.as_coefficient(S.ImaginaryUnit)) if cls == sin else cosh(arg.as_coefficient(S.ImaginaryUnit))\n+\n         if arg.could_extract_minus_sign():\n             return -cls(-arg)\n-\n-        i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n         if i_coeff is not None:\n             return S.ImaginaryUnit * tanh(i_coeff)\n \n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/functions/elementary/trigonometric.py b/sympy/functions/elementary/trigonometric.py\nindex bfdabb3..5330409 100644\n--- a/sympy/functions/elementary/trigonometric.py\n+++ b/sympy/functions/elementary/trigonometric.py\n@@ -157,9 +157,10 @@ class sin(TrigonometricFunction):\n                 return AccumBounds(Min(sin(min), sin(max)), Max(sin(min), sin(max)))\n         elif isinstance(arg, SetExpr):\n             return arg._eval_func(cls)\n+        if arg.is_complex and arg.has(S.ImaginaryUnit):\n+            return S.ImaginaryUnit * sinh(arg.as_coefficient(S.ImaginaryUnit)) if cls == sin else cosh(arg.as_coefficient(S.ImaginaryUnit))\n         if arg.could_extract_minus_sign():\n             return -cls(-arg)\n-        i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n         if i_coeff is not None:\n             return S.ImaginaryUnit * sinh(i_coeff)\n         pi_coeff = _pi_coeff(arg)\n@@ -617,9 +618,10 @@ class tan(TrigonometricFunction):\n                 return AccumBounds(S.NegativeInfinity, S.Infinity)\n             else:\n                 return AccumBounds(tan(min), tan(max))\n+        if arg.is_complex and arg.has(S.ImaginaryUnit):\n+            return S.ImaginaryUnit * sinh(arg.as_coefficient(S.ImaginaryUnit)) if cls == sin else cosh(arg.as_coefficient(S.ImaginaryUnit))\n         if arg.could_extract_minus_sign():\n             return -cls(-arg)\n-        i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n         if i_coeff is not None:\n             return S.ImaginaryUnit * tanh(i_coeff)\n         pi_coeff = _pi_coeff(arg, 2)\n", "normalized_occurrence": 1}
