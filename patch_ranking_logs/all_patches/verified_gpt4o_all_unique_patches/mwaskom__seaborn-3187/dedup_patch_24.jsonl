{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3187", "model_patch": "diff --git a/seaborn/relational.py b/seaborn/relational.py\nindex a94a471..7321410 100644\n--- a/seaborn/relational.py\n+++ b/seaborn/relational.py\n@@ -278,10 +278,24 @@ class _RelationalPlotter(VectorPlotter):\n             size_levels, size_formatted_levels = locator_to_legend_entries(\n                 locator, limits, self.plot_data[\"size\"].infer_objects().dtype\n             )\n+            formatter = ScalarFormatter()\n+            formatter.create_offset(limits)\n+            offset_text = formatter.get_offset()\n+\n+            # Append the offset to each formatted level if applicable\n+            if offset_text:\n+                size_formatted_levels = [f\"{label} {offset_text}\" for label in size_formatted_levels]\n         elif self._size_map.levels is None:\n             size_levels = size_formatted_levels = []\n         else:\n             size_levels = size_formatted_levels = self._size_map.levels\n+            formatter = ScalarFormatter()\n+            formatter.create_offset((min(size_levels), max(size_levels)))\n+            offset_text = formatter.get_offset()\n+\n+            # Append the offset to each formatted level if applicable\n+            if offset_text:\n+                size_formatted_levels = [f\"{label} {offset_text}\" for label in size_formatted_levels]\n \n         # Add the size semantic subtitle\n         if not legend_title and self.variables.get(\"size\", None) is not None:\n", "occurrence": 1, "normalized_patch": "diff --git a/seaborn/relational.py b/seaborn/relational.py\nindex 1613149..f9854a2 100644\n--- a/seaborn/relational.py\n+++ b/seaborn/relational.py\n@@ -64,10 +64,20 @@ class _RelationalPlotter(VectorPlotter):\n                 locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)\n             limits = (min(self._size_map.levels), max(self._size_map.levels))\n             size_levels, size_formatted_levels = locator_to_legend_entries(locator, limits, self.plot_data['size'].infer_objects().dtype)\n+            formatter = ScalarFormatter()\n+            formatter.create_offset(limits)\n+            offset_text = formatter.get_offset()\n+            if offset_text:\n+                size_formatted_levels = [f'{label} {offset_text}' for label in size_formatted_levels]\n         elif self._size_map.levels is None:\n             size_levels = size_formatted_levels = []\n         else:\n             size_levels = size_formatted_levels = self._size_map.levels\n+            formatter = ScalarFormatter()\n+            formatter.create_offset((min(size_levels), max(size_levels)))\n+            offset_text = formatter.get_offset()\n+            if offset_text:\n+                size_formatted_levels = [f'{label} {offset_text}' for label in size_formatted_levels]\n         if not legend_title and self.variables.get('size', None) is not None:\n             update((self.variables['size'], 'title'), self.variables['size'], **title_kws)\n         for level, formatted_level in zip(size_levels, size_formatted_levels):\n", "normalized_occurrence": 1}
