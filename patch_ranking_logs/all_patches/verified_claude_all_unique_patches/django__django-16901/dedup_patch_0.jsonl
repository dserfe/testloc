{"model_name_or_path": "agentless_claude", "instance_id": "django__django-16901", "model_patch": "diff --git a/django/db/backends/base/operations.py b/django/db/backends/base/operations.py\nindex 5801e03..05fecca 100644\n--- a/django/db/backends/base/operations.py\n+++ b/django/db/backends/base/operations.py\n@@ -667,7 +667,23 @@ class BaseDatabaseOperations:\n         the provided connecting operator. This is required because operators\n         can vary between backends (e.g., Oracle with %% and &) and between\n         subexpression types (e.g., date expressions).\n-        \"\"\"\n+\n+        For the XOR operator, ensures proper handling of multiple terms to maintain\n+        the correct parity-based behavior (true when an odd number of arguments are true).\n+        \"\"\"\n+        if connector == '^':\n+            if len(sub_expressions) <= 2:\n+                conn = \" %s \" % connector\n+                return conn.join(sub_expressions)\n+            else:\n+                # For more than 2 expressions, we need to ensure proper XOR behavior\n+                # by counting the number of true expressions being odd\n+                # We can achieve this by combining the expressions with:\n+                # (a != b) != c != d != ... which is true when odd number are true\n+                return \" != \".join(\"(%s)\" % expr for expr in sub_expressions)\n+        else:\n+            conn = \" %s \" % connector\n+            return conn.join(sub_expressions)\n         conn = \" %s \" % connector\n         return conn.join(sub_expressions)\n \n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/backends/base/operations.py b/django/db/backends/base/operations.py\nindex ba948a6..e8ed061 100644\n--- a/django/db/backends/base/operations.py\n+++ b/django/db/backends/base/operations.py\n@@ -215,6 +215,15 @@ class BaseDatabaseOperations:\n     def conditional_expression_supported_in_where_clause(self, expression):\n         return True\n     def combine_expression(self, connector, sub_expressions):\n+        if connector == '^':\n+            if len(sub_expressions) <= 2:\n+                conn = ' %s ' % connector\n+                return conn.join(sub_expressions)\n+            else:\n+                return ' != '.join(('(%s)' % expr for expr in sub_expressions))\n+        else:\n+            conn = ' %s ' % connector\n+            return conn.join(sub_expressions)\n         conn = ' %s ' % connector\n         return conn.join(sub_expressions)\n     def combine_duration_expression(self, connector, sub_expressions):\n", "normalized_occurrence": 1}
