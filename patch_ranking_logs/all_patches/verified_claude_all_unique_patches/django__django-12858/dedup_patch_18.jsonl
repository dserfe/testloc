{"model_name_or_path": "agentless_claude", "instance_id": "django__django-12858", "model_patch": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 8f934b7..f50025d 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -8,6 +8,8 @@ from django.conf import settings\n from django.core.checks import Error, Tags, Warning, register\n \n \n+ALLOWED_ORDERINGS = {'isnull'}  # Add isnull as allowed lookup for ordering\n+\n @register(Tags.models)\n def check_all_models(app_configs=None, **kwargs):\n     db_table_models = defaultdict(list)\n@@ -32,6 +34,7 @@ def check_all_models(app_configs=None, **kwargs):\n             )\n         else:\n             errors.extend(model.check(**kwargs))\n+            errors.extend(_check_ordering_references(model))\n         for model_index in model._meta.indexes:\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n@@ -86,6 +89,55 @@ def check_all_models(app_configs=None, **kwargs):\n     return errors\n \n \n+def _check_ordering_references(model):\n+    \"\"\"\n+    Check that ordering references valid fields and lookups.\n+    \"\"\"\n+    errors = []\n+    for field_name in model._meta.ordering:\n+        if isinstance(field_name, (str, bytes)):\n+            # Skip expressions\n+            if field_name.startswith('-'):\n+                field_name = field_name[1:]\n+            if field_name == '?':\n+                continue\n+            if field_name == 'pk':\n+                continue\n+            \n+            # Allow 'isnull' lookup\n+            field_name_parts = field_name.split('__')\n+            field_name = field_name_parts[0]\n+            lookups = field_name_parts[1:]\n+            \n+            # Get the field\n+            try:\n+                field = model._meta.get_field(field_name)\n+                curr_model = field.remote_field.model if field.remote_field else model\n+                for lookup in lookups[:-1]:\n+                    field = curr_model._meta.get_field(lookup)\n+                    if field.remote_field:\n+                        curr_model = field.remote_field.model\n+                # Check if the last part is a valid transform/lookup\n+                if lookups and lookups[-1] not in ALLOWED_ORDERINGS and not hasattr(field, 'get_transform'):\n+                    errors.append(\n+                        Error(\n+                            \"'ordering' refers to '%s' which is not a supported lookup.\"\n+                            % field_name,\n+                            obj=model,\n+                            id='models.E015',\n+                        )\n+                    )\n+            except FieldDoesNotExist:\n+                errors.append(\n+                    Error(\n+                        \"'ordering' refers to the nonexistent field '%s'.\"\n+                        % field_name,\n+                        obj=model,\n+                        id='models.E015',\n+                    )\n+                )\n+    return errors\n+\n def _check_lazy_references(apps, ignore=None):\n     \"\"\"\n     Ensure all lazy (i.e. string) model references have been resolved.\n", "occurrence": 1, "normalized_patch": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 50dfeb8..b500765 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -5,6 +5,7 @@ from itertools import chain\n from django.apps import apps\n from django.conf import settings\n from django.core.checks import Error, Tags, Warning, register\n+ALLOWED_ORDERINGS = {'isnull'}\n @register(Tags.models)\n def check_all_models(app_configs=None, **kwargs):\n     db_table_models = defaultdict(list)\n@@ -22,6 +23,7 @@ def check_all_models(app_configs=None, **kwargs):\n             errors.append(Error(\"The '%s.check()' class method is currently overridden by %r.\" % (model.__name__, model.check), obj=model, id='models.E020'))\n         else:\n             errors.extend(model.check(**kwargs))\n+            errors.extend(_check_ordering_references(model))\n         for model_index in model._meta.indexes:\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n@@ -45,6 +47,31 @@ def check_all_models(app_configs=None, **kwargs):\n             model_labels = set(model_labels)\n             errors.append(Error(\"constraint name '%s' is not unique %s %s.\" % (constraint_name, 'for model' if len(model_labels) == 1 else 'amongst models:', ', '.join(sorted(model_labels))), id='models.E031' if len(model_labels) == 1 else 'models.E032'))\n     return errors\n+def _check_ordering_references(model):\n+    errors = []\n+    for field_name in model._meta.ordering:\n+        if isinstance(field_name, (str, bytes)):\n+            if field_name.startswith('-'):\n+                field_name = field_name[1:]\n+            if field_name == '?':\n+                continue\n+            if field_name == 'pk':\n+                continue\n+            field_name_parts = field_name.split('__')\n+            field_name = field_name_parts[0]\n+            lookups = field_name_parts[1:]\n+            try:\n+                field = model._meta.get_field(field_name)\n+                curr_model = field.remote_field.model if field.remote_field else model\n+                for lookup in lookups[:-1]:\n+                    field = curr_model._meta.get_field(lookup)\n+                    if field.remote_field:\n+                        curr_model = field.remote_field.model\n+                if lookups and lookups[-1] not in ALLOWED_ORDERINGS and (not hasattr(field, 'get_transform')):\n+                    errors.append(Error(\"'ordering' refers to '%s' which is not a supported lookup.\" % field_name, obj=model, id='models.E015'))\n+            except FieldDoesNotExist:\n+                errors.append(Error(\"'ordering' refers to the nonexistent field '%s'.\" % field_name, obj=model, id='models.E015'))\n+    return errors\n def _check_lazy_references(apps, ignore=None):\n     pending_models = set(apps._pending_operations) - (ignore or set())\n     if not pending_models:\n", "normalized_occurrence": 1}
