{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4094", "model_patch": "diff --git a/xarray/core/merge.py b/xarray/core/merge.py\nindex 3a09d85..7dcc876 100644\n--- a/xarray/core/merge.py\n+++ b/xarray/core/merge.py\n@@ -622,7 +622,22 @@ def merge_core(\n         combine_attrs,\n     )\n \n-    return _MergeResult(variables, coord_names, dims, out_indexes, attrs)\n+    result = _MergeResult(variables, coord_names, dims, out_indexes, attrs)\n+    \n+    # Ensure that dimensions are aligned to avoid merge conflicts\n+    for dim in result.dims:\n+        all_coords = [var.coords[dim].values for var in coerced if dim in var.coords]\n+        if len(all_coords) > 0:\n+            first_coord = all_coords[0]\n+            if not all(np.array_equal(first_coord, coord) for coord in all_coords):\n+                if compat != 'override':\n+                    raise MergeError(f\"conflicting values for variable '{dim}' on objects to be combined. You can skip this check by specifying compat='override'.\")\n+                else:\n+                    for var in coerced:\n+                        if dim in var.coords:\n+                            var.coords[dim] = first_coord\n+\n+    return result\n \n \n def merge(\n", "occurrence": 1, "normalized_patch": "diff --git a/xarray/core/merge.py b/xarray/core/merge.py\nindex 0a5d6cd..9805ff1 100644\n--- a/xarray/core/merge.py\n+++ b/xarray/core/merge.py\n@@ -433,7 +433,19 @@ def merge_core(objects: Iterable['CoercibleMapping'], compat: str='broadcast_equ\n     if ambiguous_coords:\n         raise MergeError('unable to determine if these variables should be coordinates or not in the merged result: %s' % ambiguous_coords)\n     attrs = merge_attrs([var.attrs for var in coerced if isinstance(var, Dataset) or isinstance(var, DataArray)], combine_attrs)\n-    return _MergeResult(variables, coord_names, dims, out_indexes, attrs)\n+    result = _MergeResult(variables, coord_names, dims, out_indexes, attrs)\n+    for dim in result.dims:\n+        all_coords = [var.coords[dim].values for var in coerced if dim in var.coords]\n+        if len(all_coords) > 0:\n+            first_coord = all_coords[0]\n+            if not all((np.array_equal(first_coord, coord) for coord in all_coords)):\n+                if compat != 'override':\n+                    raise MergeError(f\"conflicting values for variable '{dim}' on objects to be combined. You can skip this check by specifying compat='override'.\")\n+                else:\n+                    for var in coerced:\n+                        if dim in var.coords:\n+                            var.coords[dim] = first_coord\n+    return result\n \n def merge(objects: Iterable[Union['DataArray', 'CoercibleMapping']], compat: str='no_conflicts', join: str='outer', fill_value: object=dtypes.NA, combine_attrs: str='drop') -> 'Dataset':\n     \"\"\"Merge any number of xarray objects into a single Dataset as variables.\n", "normalized_occurrence": 1}
