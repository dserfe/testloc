{"model_name_or_path": "agentless", "instance_id": "django__django-13346", "model_patch": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex a0dea96..ac640e7 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -269,6 +269,10 @@ JSONField.register_lookup(HasAnyKeys)\n JSONField.register_lookup(JSONExact)\n \n \n+@KeyTransform.register_lookup\n+class KeyTransformIn(KeyTransformInLookupMixin, lookups.In):\n+    lookup_name = 'in'\n+\n class KeyTransform(Transform):\n     postgres_operator = '->'\n     postgres_nested_operator = '#>'\n@@ -325,6 +329,31 @@ class KeyTextTransform(KeyTransform):\n     postgres_nested_operator = '#>>'\n \n \n+class KeyTransformInLookupMixin:\n+    def get_prep_lookup(self):\n+        prepared_values = []\n+        for value in self.rhs:\n+            prepared_values.append(value)\n+        return prepared_values\n+\n+    def as_sql(self, compiler, connection):\n+        lhs, lhs_params, key_transforms = self.preprocess_lhs(compiler, connection)\n+        rhs = self.get_prep_lookup()\n+        if connection.vendor == 'mysql':\n+            json_path = compile_json_path(key_transforms)\n+            in_clause = ', '.join(['JSON_EXTRACT(%s, %%s)' % lhs] * len(rhs))\n+            return \"%s IN (%s)\" % (lhs, in_clause), tuple(lhs_params + [json_path] * len(rhs) + rhs)\n+        elif connection.vendor == 'oracle':\n+            json_path = compile_json_path(key_transforms)\n+            in_clause = ', '.join([\"COALESCE(JSON_QUERY(%s, '%s'), JSON_VALUE(%s, '%s'))\" % (lhs, json_path, lhs, json_path)] * len(rhs))\n+            return \"%s IN (%s)\" % (lhs, in_clause), tuple(lhs_params * 2 * len(rhs) + rhs)\n+        elif connection.vendor == 'sqlite':\n+            json_path = compile_json_path(key_transforms)\n+            in_clause = ', '.join(['JSON_EXTRACT(%s, %%s)' % lhs] * len(rhs))\n+            return \"%s IN (%s)\" % (lhs, in_clause), tuple(lhs_params + [json_path] * len(rhs) + rhs)\n+        else:\n+            raise NotImplementedError(\"IN lookup not implemented for this database backend\")\n+\n class KeyTransformTextLookupMixin:\n     \"\"\"\n     Mixin for combining with a lookup expecting a text lhs from a JSONField\n", "occurrence": 1, "normalized_patch": "--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n+@KeyTransform.register_lookup\n+class KeyTransformIn(KeyTransformInLookupMixin, lookups.In):\n+    lookup_name = 'in'\n+class KeyTransformInLookupMixin:\n+    def get_prep_lookup(self):\n+        prepared_values = []\n+        for value in self.rhs:\n+            prepared_values.append(value)\n+        return prepared_values\n+    def as_sql(self, compiler, connection):\n+        lhs, lhs_params, key_transforms = self.preprocess_lhs(compiler, connection)\n+        rhs = self.get_prep_lookup()\n+        if connection.vendor == 'mysql':\n+            json_path = compile_json_path(key_transforms)\n+            in_clause = ', '.join(['JSON_EXTRACT(%s, %%s)' % lhs] * len(rhs))\n+            return ('%s IN (%s)' % (lhs, in_clause), tuple(lhs_params + [json_path] * len(rhs) + rhs))\n+        elif connection.vendor == 'oracle':\n+            json_path = compile_json_path(key_transforms)\n+            in_clause = ', '.join([\"COALESCE(JSON_QUERY(%s, '%s'), JSON_VALUE(%s, '%s'))\" % (lhs, json_path, lhs, json_path)] * len(rhs))\n+            return ('%s IN (%s)' % (lhs, in_clause), tuple(lhs_params * 2 * len(rhs) + rhs))\n+        elif connection.vendor == 'sqlite':\n+            json_path = compile_json_path(key_transforms)\n+            in_clause = ', '.join(['JSON_EXTRACT(%s, %%s)' % lhs] * len(rhs))\n+            return ('%s IN (%s)' % (lhs, in_clause), tuple(lhs_params + [json_path] * len(rhs) + rhs))\n+        else:\n+            raise NotImplementedError('IN lookup not implemented for this database backend')", "normalized_occurrence": 1}
