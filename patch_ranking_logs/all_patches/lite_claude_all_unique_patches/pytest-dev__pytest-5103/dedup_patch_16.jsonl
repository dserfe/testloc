{"model_name_or_path": "agentless_claude", "instance_id": "pytest-dev__pytest-5103", "model_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 4810cdd..84f0947 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,7 +964,41 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n-    def visit_Call_35(self, call):\n+\n+        # Handle all() and any() calls specially\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and\n+            isinstance(call.args[0], (ast.GeneratorExp, ast.ListComp))):\n+            \n+            gen_or_list = call.args[0]\n+            \n+            # Create a loop that checks each element\n+            iter_var = gen_or_list.generators[0].target\n+            iter_expr = gen_or_list.generators[0].iter\n+            test_expr = gen_or_list.elt\n+            \n+            # For all(), we check that each item is True\n+            # For any(), we keep track if we found any True values\n+            if call.func.id == 'all':\n+                loop_test = test_expr\n+            else:  # any()\n+                found_true = self.helper('assign', ast.Name('False', ast.Store()))\n+                loop_test = ast.Assign(\n+                    [found_true], \n+                    ast.BoolOp(ast.Or(), [found_true, test_expr])\n+                )\n+            \n+            # Build for loop: for iter_var in iter_expr: assert test_expr\n+            loop = ast.For(\n+                iter_var,\n+                iter_expr,\n+                [ast.Assert(loop_test, None)],\n+                []\n+            )\n+            \n+            # Return the loop node and explanation\n+            return loop, \"unrolled %s() check\" % call.func.id\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n", "occurrence": 1, "normalized_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2ada5b2..dc8a846 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -543,7 +543,19 @@ class AssertionRewriter(ast.NodeVisitor):\n         explanation = '(%s %s %s)' % (left_expl, symbol, right_expl)\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return (res, explanation)\n-    def visit_Call_35(self, call):\n+        if isinstance(call.func, ast.Name) and call.func.id in ('all', 'any') and (len(call.args) == 1) and isinstance(call.args[0], (ast.GeneratorExp, ast.ListComp)):\n+            gen_or_list = call.args[0]\n+            iter_var = gen_or_list.generators[0].target\n+            iter_expr = gen_or_list.generators[0].iter\n+            test_expr = gen_or_list.elt\n+            if call.func.id == 'all':\n+                loop_test = test_expr\n+            else:\n+                found_true = self.helper('assign', ast.Name('False', ast.Store()))\n+                loop_test = ast.Assign([found_true], ast.BoolOp(ast.Or(), [found_true, test_expr]))\n+            loop = ast.For(iter_var, iter_expr, [ast.Assert(loop_test, None)], [])\n+            return (loop, 'unrolled %s() check' % call.func.id)\n+        '\\n        visit `ast.Call` nodes on Python3.5 and after\\n        '\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n", "normalized_occurrence": 1}
