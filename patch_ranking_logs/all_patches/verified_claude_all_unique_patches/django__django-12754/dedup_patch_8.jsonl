{"model_name_or_path": "agentless_claude", "instance_id": "django__django-12754", "model_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 12ebcde..32ed2fb 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -351,6 +351,14 @@ class MigrationAutodetector:\n                         for op2 in ops:\n                             if self.check_dependency(op2, dep):\n                                 dependency_graph[op].add(op2)\n+                \n+                # Ensure RemoveField operations come before AddField operations\n+                # when the field is being moved between models\n+                if isinstance(op, operations.AddField):\n+                    for op2 in ops:\n+                        if (isinstance(op2, operations.RemoveField) and\n+                            op2.name_lower == op.name_lower):\n+                            dependency_graph[op].add(op2)\n \n             # we use a stable sort for deterministic tests & general behavior\n             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)\n@@ -1326,4 +1334,4 @@ class MigrationAutodetector:\n         match = re.match(r'^\\d+', name)\n         if match:\n             return int(match[0])\n-        return None\n+        return None\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex f799cd9..e204468 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -196,6 +196,10 @@ class MigrationAutodetector:\n                         for op2 in ops:\n                             if self.check_dependency(op2, dep):\n                                 dependency_graph[op].add(op2)\n+                if isinstance(op, operations.AddField):\n+                    for op2 in ops:\n+                        if isinstance(op2, operations.RemoveField) and op2.name_lower == op.name_lower:\n+                            dependency_graph[op].add(op2)\n             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)\n     def _optimize_migrations(self):\n         for app_label, migrations in self.migrations.items():\n", "normalized_occurrence": 1}
