{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-24661", "model_patch": "diff --git a/sympy/core/relational.py b/sympy/core/relational.py\nindex c35b72b..93c9c65 100644\n--- a/sympy/core/relational.py\n+++ b/sympy/core/relational.py\n@@ -816,12 +816,15 @@ class _Inequality(Relational):\n             return NotImplemented\n \n         evaluate = options.pop('evaluate', global_parameters.evaluate)\n+\n+        # Check for NaN and non-real regardless of evaluation flag\n+        for me in (lhs, rhs):\n+            if me.is_extended_real is False:\n+                raise TypeError(\"Invalid comparison of non-real %s\" % me)\n+            if me is S.NaN:\n+                raise TypeError(\"Invalid NaN comparison\")\n+\n         if evaluate:\n-            for me in (lhs, rhs):\n-                if me.is_extended_real is False:\n-                    raise TypeError(\"Invalid comparison of non-real %s\" % me)\n-                if me is S.NaN:\n-                    raise TypeError(\"Invalid NaN comparison\")\n             # First we invoke the appropriate inequality method of `lhs`\n             # (e.g., `lhs.__lt__`).  That method will try to reduce to\n             # boolean or raise an exception.  It may keep calling\n@@ -833,7 +836,7 @@ class _Inequality(Relational):\n             return cls._eval_relation(lhs, rhs, **options)\n \n         # make a \"non-evaluated\" Expr for the inequality\n-        return Relational.__new__(cls, lhs, rhs, **options)\n+        return Relational.__new__(cls, lhs, rhs, evaluate=False, **options)\n \n     @classmethod\n     def _eval_relation(cls, lhs, rhs, **options):\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/relational.py b/sympy/core/relational.py\nindex 6f6b8fe..fd38893 100644\n--- a/sympy/core/relational.py\n+++ b/sympy/core/relational.py\n@@ -348,14 +348,14 @@ class _Inequality(Relational):\n         except SympifyError:\n             return NotImplemented\n         evaluate = options.pop('evaluate', global_parameters.evaluate)\n+        for me in (lhs, rhs):\n+            if me.is_extended_real is False:\n+                raise TypeError('Invalid comparison of non-real %s' % me)\n+            if me is S.NaN:\n+                raise TypeError('Invalid NaN comparison')\n         if evaluate:\n-            for me in (lhs, rhs):\n-                if me.is_extended_real is False:\n-                    raise TypeError('Invalid comparison of non-real %s' % me)\n-                if me is S.NaN:\n-                    raise TypeError('Invalid NaN comparison')\n             return cls._eval_relation(lhs, rhs, **options)\n-        return Relational.__new__(cls, lhs, rhs, **options)\n+        return Relational.__new__(cls, lhs, rhs, evaluate=False, **options)\n     @classmethod\n     def _eval_relation(cls, lhs, rhs, **options):\n         val = cls._eval_fuzzy_relation(lhs, rhs)\n", "normalized_occurrence": 1}
