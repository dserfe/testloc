{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13551", "model_patch": "diff --git a/sympy/concrete/products.py b/sympy/concrete/products.py\nindex 65aca3f..7333678 100644\n--- a/sympy/concrete/products.py\n+++ b/sympy/concrete/products.py\n@@ -255,24 +255,57 @@ class Product(ExprWithIntLimits):\n         if dif.is_Integer:\n             return Mul(*[term.subs(k, a + i) for i in range(dif + 1)])\n \n-        elif term.is_polynomial(k):\n-            poly = term.as_poly(k)\n+        elif term.is_Add:\n+            p, q = term.as_numer_denom()\n+            q = self._eval_product(q, (k, a, n))\n+            if q.is_Number:\n \n-            A = B = Q = S.One\n+                # There is expression, which couldn't change by\n+                # as_numer_denom(). E.g. n**(2/3) + 1 --> (n**(2/3) + 1, 1).\n+                # We have to catch this case.\n \n-            all_roots = roots(poly)\n+                p = sum([self._eval_product(i, (k, a, n)) for i in p.as_coeff_Add()])\n+            else:\n+                p = self._eval_product(p, (k, a, n))\n+            return p / q\n \n-            M = 0\n-            for r, m in all_roots.items():\n-                M += m\n-                A *= RisingFactorial(a - r, n - a + 1)**m\n-                Q *= (n - r)**m\n+        elif term.is_Mul:\n+            exclude, include = [], []\n+\n+            for t in term.args:\n+                p = self._eval_product(t, (k, a, n))\n \n-            if M < poly.degree():\n-                arg = quo(poly, Q.as_poly(k))\n+                if p is not None:\n+                    exclude.append(p)\n+                else:\n+                    include.append(t)\n+\n+            if not exclude:\n+                return None\n+            else:\n+                arg = term._new_rawargs(*include)\n+                A = Mul(*exclude)\n                 B = self.func(arg, (k, a, n)).doit()\n+                return A * B\n+\n+        elif term.is_Pow:\n+            if not term.base.has(k):\n+                s = summation(term.exp, (k, a, n))\n+\n+                return term.base**s\n+            elif not term.exp.has(k):\n+                p = self._eval_product(term.base, (k, a, n))\n+\n+                if p is not None:\n+                    return p**term.exp\n \n-            return poly.LC()**(n - a + 1) * A * B\n+        elif isinstance(term, Product):\n+            evaluated = term.doit()\n+            f = self._eval_product(evaluated, limits)\n+            if f is None:\n+                return self.func(evaluated, limits)\n+            else:\n+                return f\n \n         elif term.is_Add:\n             p, q = term.as_numer_denom()\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/concrete/products.py b/sympy/concrete/products.py\nindex f5dda77..e0d0584 100644\n--- a/sympy/concrete/products.py\n+++ b/sympy/concrete/products.py\n@@ -61,19 +61,44 @@ class Product(ExprWithIntLimits):\n         dif = n - a\n         if dif.is_Integer:\n             return Mul(*[term.subs(k, a + i) for i in range(dif + 1)])\n-        elif term.is_polynomial(k):\n-            poly = term.as_poly(k)\n-            A = B = Q = S.One\n-            all_roots = roots(poly)\n-            M = 0\n-            for r, m in all_roots.items():\n-                M += m\n-                A *= RisingFactorial(a - r, n - a + 1) ** m\n-                Q *= (n - r) ** m\n-            if M < poly.degree():\n-                arg = quo(poly, Q.as_poly(k))\n+        elif term.is_Add:\n+            p, q = term.as_numer_denom()\n+            q = self._eval_product(q, (k, a, n))\n+            if q.is_Number:\n+                p = sum([self._eval_product(i, (k, a, n)) for i in p.as_coeff_Add()])\n+            else:\n+                p = self._eval_product(p, (k, a, n))\n+            return p / q\n+        elif term.is_Mul:\n+            exclude, include = ([], [])\n+            for t in term.args:\n+                p = self._eval_product(t, (k, a, n))\n+                if p is not None:\n+                    exclude.append(p)\n+                else:\n+                    include.append(t)\n+            if not exclude:\n+                return None\n+            else:\n+                arg = term._new_rawargs(*include)\n+                A = Mul(*exclude)\n                 B = self.func(arg, (k, a, n)).doit()\n-            return poly.LC() ** (n - a + 1) * A * B\n+                return A * B\n+        elif term.is_Pow:\n+            if not term.base.has(k):\n+                s = summation(term.exp, (k, a, n))\n+                return term.base ** s\n+            elif not term.exp.has(k):\n+                p = self._eval_product(term.base, (k, a, n))\n+                if p is not None:\n+                    return p ** term.exp\n+        elif isinstance(term, Product):\n+            evaluated = term.doit()\n+            f = self._eval_product(evaluated, limits)\n+            if f is None:\n+                return self.func(evaluated, limits)\n+            else:\n+                return f\n         elif term.is_Add:\n             p, q = term.as_numer_denom()\n             q = self._eval_product(q, (k, a, n))\n", "normalized_occurrence": 1}
