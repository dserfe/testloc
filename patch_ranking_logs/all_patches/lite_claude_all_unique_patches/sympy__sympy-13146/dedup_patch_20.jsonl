{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13146", "model_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex e24efd1..e0da85f 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -693,6 +693,12 @@ def evalf_pow(v, prec, options):\n         # Positive square root\n         return mpf_sqrt(xre, prec), None, prec, None\n \n+    # Convert float exponents to rationals for consistent evaluation\n+    if exp.is_Float:\n+        from sympy import Rational\n+        exp = Rational(str(exp))\n+        return evalf_pow(v.func(base, exp), prec, options)\n+\n     # We first evaluate the exponent to find its magnitude\n     # This determines the working precision that must be used\n     prec += 10\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex 54c5b3f..9857954 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -390,6 +390,10 @@ def evalf_pow(v, prec, options):\n         if mpf_lt(xre, fzero):\n             return (None, mpf_sqrt(mpf_neg(xre), prec), None, prec)\n         return (mpf_sqrt(xre, prec), None, prec, None)\n+    if exp.is_Float:\n+        from sympy import Rational\n+        exp = Rational(str(exp))\n+        return evalf_pow(v.func(base, exp), prec, options)\n     prec += 10\n     yre, yim, _, _ = evalf(exp, prec, options)\n     if not (yre or yim):\n", "normalized_occurrence": 1}
