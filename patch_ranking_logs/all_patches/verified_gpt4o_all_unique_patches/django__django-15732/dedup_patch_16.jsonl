{"model_name_or_path": "agentless", "instance_id": "django__django-15732", "model_patch": "diff --git a/django/db/backends/postgresql/introspection.py b/django/db/backends/postgresql/introspection.py\nindex 15d7bc4..6d536c5 100644\n--- a/django/db/backends/postgresql/introspection.py\n+++ b/django/db/backends/postgresql/introspection.py\n@@ -207,7 +207,8 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n             [table_name],\n         )\n         for constraint, columns, kind, used_cols, options in cursor.fetchall():\n-            constraints[constraint] = {\n+            if constraint not in constraints:\n+                constraints[constraint] = {\n                 \"columns\": columns,\n                 \"primary_key\": kind == \"p\",\n                 \"unique\": kind in [\"p\", \"u\"],\n@@ -271,15 +272,7 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n             definition,\n             options,\n         ) in cursor.fetchall():\n-            if index not in constraints:\n-                basic_index = (\n-                    type_ == self.index_default_access_method\n-                    and\n-                    # '_btree' references\n-                    # django.contrib.postgres.indexes.BTreeIndex.suffix.\n-                    not index.endswith(\"_btree\")\n-                    and options is None\n-                )\n+            if index not in constraints or not constraints[index][\"unique\"]:\n                 constraints[index] = {\n                     \"columns\": columns if columns != [None] else [],\n                     \"orders\": orders if orders != [None] else [],\n@@ -292,4 +285,6 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n                     \"definition\": definition,\n                     \"options\": options,\n                 }\n-        return constraints\n+                if constraints[index][\"unique\"]:\n+                    constraints[index][\"unique\"] = unique\n+        return constraints\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/backends/postgresql/introspection.py b/django/db/backends/postgresql/introspection.py\nindex cdc8683..db580dc 100644\n--- a/django/db/backends/postgresql/introspection.py\n+++ b/django/db/backends/postgresql/introspection.py\n@@ -36,10 +36,12 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n         constraints = {}\n         cursor.execute(\"\\n            SELECT\\n                c.conname,\\n                array(\\n                    SELECT attname\\n                    FROM unnest(c.conkey) WITH ORDINALITY cols(colid, arridx)\\n                    JOIN pg_attribute AS ca ON cols.colid = ca.attnum\\n                    WHERE ca.attrelid = c.conrelid\\n                    ORDER BY cols.arridx\\n                ),\\n                c.contype,\\n                (SELECT fkc.relname || '.' || fka.attname\\n                FROM pg_attribute AS fka\\n                JOIN pg_class AS fkc ON fka.attrelid = fkc.oid\\n                WHERE fka.attrelid = c.confrelid AND fka.attnum = c.confkey[1]),\\n                cl.reloptions\\n            FROM pg_constraint AS c\\n            JOIN pg_class AS cl ON c.conrelid = cl.oid\\n            WHERE cl.relname = %s AND pg_catalog.pg_table_is_visible(cl.oid)\\n        \", [table_name])\n         for constraint, columns, kind, used_cols, options in cursor.fetchall():\n-            constraints[constraint] = {'columns': columns, 'primary_key': kind == 'p', 'unique': kind in ['p', 'u'], 'foreign_key': tuple(used_cols.split('.', 1)) if kind == 'f' else None, 'check': kind == 'c', 'index': False, 'definition': None, 'options': options}\n+            if constraint not in constraints:\n+                constraints[constraint] = {'columns': columns, 'primary_key': kind == 'p', 'unique': kind in ['p', 'u'], 'foreign_key': tuple(used_cols.split('.', 1)) if kind == 'f' else None, 'check': kind == 'c', 'index': False, 'definition': None, 'options': options}\n         cursor.execute(\"\\n            SELECT\\n                indexname,\\n                array_agg(attname ORDER BY arridx),\\n                indisunique,\\n                indisprimary,\\n                array_agg(ordering ORDER BY arridx),\\n                amname,\\n                exprdef,\\n                s2.attoptions\\n            FROM (\\n                SELECT\\n                    c2.relname as indexname, idx.*, attr.attname, am.amname,\\n                    CASE\\n                        WHEN idx.indexprs IS NOT NULL THEN\\n                            pg_get_indexdef(idx.indexrelid)\\n                    END AS exprdef,\\n                    CASE am.amname\\n                        WHEN %s THEN\\n                            CASE (option & 1)\\n                                WHEN 1 THEN 'DESC' ELSE 'ASC'\\n                            END\\n                    END as ordering,\\n                    c2.reloptions as attoptions\\n                FROM (\\n                    SELECT *\\n                    FROM\\n                        pg_index i,\\n                        unnest(i.indkey, i.indoption)\\n                            WITH ORDINALITY koi(key, option, arridx)\\n                ) idx\\n                LEFT JOIN pg_class c ON idx.indrelid = c.oid\\n                LEFT JOIN pg_class c2 ON idx.indexrelid = c2.oid\\n                LEFT JOIN pg_am am ON c2.relam = am.oid\\n                LEFT JOIN\\n                    pg_attribute attr ON attr.attrelid = c.oid AND attr.attnum = idx.key\\n                WHERE c.relname = %s AND pg_catalog.pg_table_is_visible(c.oid)\\n            ) s2\\n            GROUP BY indexname, indisunique, indisprimary, amname, exprdef, attoptions;\\n        \", [self.index_default_access_method, table_name])\n         for index, columns, unique, primary, orders, type_, definition, options in cursor.fetchall():\n-            if index not in constraints:\n-                basic_index = type_ == self.index_default_access_method and (not index.endswith('_btree')) and (options is None)\n+            if index not in constraints or not constraints[index]['unique']:\n                 constraints[index] = {'columns': columns if columns != [None] else [], 'orders': orders if orders != [None] else [], 'primary_key': primary, 'unique': unique, 'foreign_key': None, 'check': False, 'index': True, 'type': Index.suffix if basic_index else type_, 'definition': definition, 'options': options}\n+                if constraints[index]['unique']:\n+                    constraints[index]['unique'] = unique\n         return constraints\n\\ No newline at end of file\n", "normalized_occurrence": 1}
