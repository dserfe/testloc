{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8551", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex f44a82b..301c871 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -86,13 +86,19 @@ def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xr\n         reftype = 'class'\n \n     if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'),\n-                  'py:class': env.ref_context.get('py:class')}\n+        current_module = env.ref_context.get('py:module')\n+        current_class = env.ref_context.get('py:class')\n+        if current_module:\n+            full_name = f'{current_module}.{text}'\n+        else:\n+            full_name = text\n+        kwargs = {'py:module': current_module,\n+                  'py:class': current_class}\n     else:\n         kwargs = {}\n \n-    return pending_xref('', nodes.Text(text),\n-                        refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n+    return pending_xref('', nodes.Text(full_name if env else text),\n+                        refdomain='py', reftype=reftype, reftarget=full_name if env else text, **kwargs)\n \n \n def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\n@@ -314,6 +320,9 @@ class PyField(PyXrefMixin, Field):\n             # None is not a type, so use obj role instead.\n             rolename = 'obj'\n \n+        if env:\n+            target = f\"{env.ref_context.get('py:module')}.{target}\"\n+\n         return super().make_xref(rolename, domain, target, innernode, contnode, env)\n \n \n", "occurrence": 1, "normalized_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 2ce105a..27365d8 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -40,10 +40,16 @@ def type_to_xref(text: str, env: BuildEnvironment=None) -> addnodes.pending_xref\n     else:\n         reftype = 'class'\n     if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'), 'py:class': env.ref_context.get('py:class')}\n+        current_module = env.ref_context.get('py:module')\n+        current_class = env.ref_context.get('py:class')\n+        if current_module:\n+            full_name = f'{current_module}.{text}'\n+        else:\n+            full_name = text\n+        kwargs = {'py:module': current_module, 'py:class': current_class}\n     else:\n         kwargs = {}\n-    return pending_xref('', nodes.Text(text), refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n+    return pending_xref('', nodes.Text(full_name if env else text), refdomain='py', reftype=reftype, reftarget=full_name if env else text, **kwargs)\n def _parse_annotation(annotation: str, env: BuildEnvironment=None) -> List[Node]:\n     def unparse(node: ast.AST) -> List[Node]:\n         if isinstance(node, ast.Attribute):\n@@ -209,6 +215,8 @@ class PyField(PyXrefMixin, Field):\n     def make_xref(self, rolename: str, domain: str, target: str, innernode: 'Type[TextlikeNode]'=nodes.emphasis, contnode: Node=None, env: BuildEnvironment=None) -> Node:\n         if rolename == 'class' and target == 'None':\n             rolename = 'obj'\n+        if env:\n+            target = f\"{env.ref_context.get('py:module')}.{target}\"\n         return super().make_xref(rolename, domain, target, innernode, contnode, env)\n class PyGroupedField(PyXrefMixin, GroupedField):\n     pass\n", "normalized_occurrence": 1}
