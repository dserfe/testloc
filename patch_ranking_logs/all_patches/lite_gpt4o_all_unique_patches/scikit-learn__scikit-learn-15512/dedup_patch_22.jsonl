{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-15512", "model_patch": "diff --git a/sklearn/cluster/_affinity_propagation.py b/sklearn/cluster/_affinity_propagation.py\nindex 0511594..b0e914a 100644\n--- a/sklearn/cluster/_affinity_propagation.py\n+++ b/sklearn/cluster/_affinity_propagation.py\n@@ -197,9 +197,15 @@ def affinity_propagation(S, preference=None, convergence_iter=15, max_iter=200,\n                 if verbose:\n                     print(\"Converged after %d iterations.\" % it)\n                 break\n-    else:\n-        if verbose:\n-            print(\"Did not converge\")\n+        else:\n+            if verbose:\n+                print(\"Did not converge\")\n+            labels = np.array([-1] * n_samples)\n+            cluster_centers_indices = []\n+            if return_n_iter:\n+                return cluster_centers_indices, labels, it + 1\n+            else:\n+                return cluster_centers_indices, labels\n \n     I = np.flatnonzero(E)\n     K = I.size  # Identify exemplars\n@@ -388,8 +394,11 @@ class AffinityPropagation(ClusterMixin, BaseEstimator):\n                 convergence_iter=self.convergence_iter, damping=self.damping,\n                 copy=self.copy, verbose=self.verbose, return_n_iter=True)\n \n-        if self.affinity != \"precomputed\":\n-            self.cluster_centers_ = X[self.cluster_centers_indices_].copy()\n+        if len(self.cluster_centers_indices_) > 0:\n+            if self.affinity != \"precomputed\":\n+                self.cluster_centers_ = X[self.cluster_centers_indices_].copy()\n+        else:\n+            self.cluster_centers_ = np.array([])\n \n         return self\n \n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/cluster/_affinity_propagation.py b/sklearn/cluster/_affinity_propagation.py\nindex b441de5..939b28e 100644\n--- a/sklearn/cluster/_affinity_propagation.py\n+++ b/sklearn/cluster/_affinity_propagation.py\n@@ -68,9 +68,15 @@ def affinity_propagation(S, preference=None, convergence_iter=15, max_iter=200,\n                 if verbose:\n                     print('Converged after %d iterations.' % it)\n                 break\n-    else:\n-        if verbose:\n-            print('Did not converge')\n+        else:\n+            if verbose:\n+                print('Did not converge')\n+            labels = np.array([-1] * n_samples)\n+            cluster_centers_indices = []\n+            if return_n_iter:\n+                return (cluster_centers_indices, labels, it + 1)\n+            else:\n+                return (cluster_centers_indices, labels)\n     I = np.flatnonzero(E)\n     K = I.size\n     if K > 0:\n@@ -118,8 +124,11 @@ class AffinityPropagation(ClusterMixin, BaseEstimator):\n         else:\n             raise ValueError(\"Affinity must be 'precomputed' or 'euclidean'. Got %s instead\" % str(self.affinity))\n         self.cluster_centers_indices_, self.labels_, self.n_iter_ = affinity_propagation(self.affinity_matrix_, self.preference, max_iter=self.max_iter, convergence_iter=self.convergence_iter, damping=self.damping, copy=self.copy, verbose=self.verbose, return_n_iter=True)\n-        if self.affinity != 'precomputed':\n-            self.cluster_centers_ = X[self.cluster_centers_indices_].copy()\n+        if len(self.cluster_centers_indices_) > 0:\n+            if self.affinity != 'precomputed':\n+                self.cluster_centers_ = X[self.cluster_centers_indices_].copy()\n+        else:\n+            self.cluster_centers_ = np.array([])\n         return self\n     def predict(self, X):\n         check_is_fitted(self)\n", "normalized_occurrence": 1}
