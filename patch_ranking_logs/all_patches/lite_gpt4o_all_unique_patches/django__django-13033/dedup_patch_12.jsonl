{"model_name_or_path": "agentless", "instance_id": "django__django-13033", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 13e70df..39f7747 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -724,27 +724,29 @@ class SQLCompiler:\n         pieces = name.split(LOOKUP_SEP)\n         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n \n-        # If we get to this point and the field is a relation to another model,\n-        # append the default ordering for that model unless it is the pk\n-        # shortcut or the attribute name of the field that is specified.\n+        # If we get to this point and the field is a relation to another model\n+        # and the ordering is not explicitly specified, append the default\n+        # ordering for that model unless it is the pk shortcut or the attribute\n+        # name of the field that is specified.\n         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n-            # Firstly, avoid infinite loops.\n-            already_seen = already_seen or set()\n-            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n-            if join_tuple in already_seen:\n-                raise FieldError('Infinite loop caused by ordering.')\n-            already_seen.add(join_tuple)\n-\n-            results = []\n-            for item in opts.ordering:\n-                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n-                    item = item.desc() if descending else item.asc()\n-                if isinstance(item, OrderBy):\n-                    results.append((item, False))\n-                    continue\n-                results.extend(self.find_ordering_name(item, opts, alias,\n-                                                       order, already_seen))\n-            return results\n+            if name not in [o.expression.name for o in self.query.order_by if hasattr(o, 'expression')]:\n+                # Firstly, avoid infinite loops.\n+                already_seen = already_seen or set()\n+                join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+                if join_tuple in already_seen:\n+                    raise FieldError('Infinite loop caused by ordering.')\n+                already_seen.add(join_tuple)\n+\n+                results = []\n+                for item in opts.ordering:\n+                    if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n+                        item = item.desc() if descending else item.asc()\n+                    if isinstance(item, OrderBy):\n+                        results.append((item, False))\n+                        continue\n+                    results.extend(self.find_ordering_name(item, opts, alias,\n+                                                           order, already_seen))\n+                return results\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n \n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex d98aa67..7fd98e9 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -416,20 +416,21 @@ class SQLCompiler:\n         pieces = name.split(LOOKUP_SEP)\n         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n         if field.is_relation and opts.ordering and (getattr(field, 'attname', None) != name) and (name != 'pk'):\n-            already_seen = already_seen or set()\n-            join_tuple = tuple((getattr(self.query.alias_map[j], 'join_cols', None) for j in joins))\n-            if join_tuple in already_seen:\n-                raise FieldError('Infinite loop caused by ordering.')\n-            already_seen.add(join_tuple)\n-            results = []\n-            for item in opts.ordering:\n-                if hasattr(item, 'resolve_expression') and (not isinstance(item, OrderBy)):\n-                    item = item.desc() if descending else item.asc()\n-                if isinstance(item, OrderBy):\n-                    results.append((item, False))\n-                    continue\n-                results.extend(self.find_ordering_name(item, opts, alias, order, already_seen))\n-            return results\n+            if name not in [o.expression.name for o in self.query.order_by if hasattr(o, 'expression')]:\n+                already_seen = already_seen or set()\n+                join_tuple = tuple((getattr(self.query.alias_map[j], 'join_cols', None) for j in joins))\n+                if join_tuple in already_seen:\n+                    raise FieldError('Infinite loop caused by ordering.')\n+                already_seen.add(join_tuple)\n+                results = []\n+                for item in opts.ordering:\n+                    if hasattr(item, 'resolve_expression') and (not isinstance(item, OrderBy)):\n+                        item = item.desc() if descending else item.asc()\n+                    if isinstance(item, OrderBy):\n+                        results.append((item, False))\n+                        continue\n+                    results.extend(self.find_ordering_name(item, opts, alias, order, already_seen))\n+                return results\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n     def _setup_joins(self, pieces, opts, alias):\n", "normalized_occurrence": 1}
