{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-16792", "model_patch": "diff --git a/sympy/utilities/autowrap.py b/sympy/utilities/autowrap.py\nindex 6b78c94..5d5c025 100644\n--- a/sympy/utilities/autowrap.py\n+++ b/sympy/utilities/autowrap.py\n@@ -321,7 +321,8 @@ setup(ext_modules=cythonize(ext_mods, **cy_opts))\n         if self._need_numpy:\n             np_import = 'import numpy as np\\n'\n             self._include_dirs.append('np.get_include()')\n-        else:\n+        elif isinstance(arg, InOutArgument) or isinstance(arg, OutputArgument):\n+            return \"%s* %s\" % (t, self._string_var(arg.name))\n             np_import = ''\n \n         with open(os.path.join(build_dir, 'setup.py'), 'w') as f:\n@@ -423,7 +424,7 @@ setup(ext_modules=cythonize(ext_mods, **cy_opts))\n                 py_args.append(arg)\n         # Find arguments that are array dimensions. These can be inferred\n         # locally in the Cython code.\n-            if isinstance(arg, (InputArgument, InOutArgument)) and arg.dimensions:\n+            if isinstance(arg, (InputArgument, InOutArgument, OutputArgument)) and arg.dimensions:\n                 dims = [d[1] + 1 for d in arg.dimensions]\n                 sym_dims = [(i, d) for (i, d) in enumerate(dims) if\n                             isinstance(d, Symbol)]\n@@ -446,7 +447,8 @@ setup(ext_modules=cythonize(ext_mods, **cy_opts))\n             ndim = len(arg.dimensions)\n             mtype = np_types[t]\n             return mat_dec.format(mtype=mtype, ndim=ndim, name=self._string_var(arg.name))\n-        else:\n+        elif isinstance(arg, InOutArgument) or isinstance(arg, OutputArgument):\n+            return \"%s* %s\" % (t, self._string_var(arg.name))\n             return \"%s %s\" % (t, self._string_var(arg.name))\n \n     def _declare_arg(self, arg):\n@@ -454,7 +456,8 @@ setup(ext_modules=cythonize(ext_mods, **cy_opts))\n         if arg.dimensions:\n             shape = '(' + ','.join(self._string_var(i[1] + 1) for i in arg.dimensions) + ')'\n             return proto + \" = np.empty({shape})\".format(shape=shape)\n-        else:\n+        elif isinstance(arg, InOutArgument) or isinstance(arg, OutputArgument):\n+            return \"%s* %s\" % (t, self._string_var(arg.name))\n             return proto + \" = 0\"\n \n     def _call_arg(self, arg):\n@@ -463,7 +466,8 @@ setup(ext_modules=cythonize(ext_mods, **cy_opts))\n             return \"<{0}*> {1}.data\".format(t, self._string_var(arg.name))\n         elif isinstance(arg, ResultBase):\n             return \"&{0}\".format(self._string_var(arg.name))\n-        else:\n+        elif isinstance(arg, InOutArgument) or isinstance(arg, OutputArgument):\n+            return \"%s* %s\" % (t, self._string_var(arg.name))\n             return self._string_var(arg.name)\n \n     def _string_var(self, var):\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/utilities/autowrap.py b/sympy/utilities/autowrap.py\nindex da40c47..8bb2ec5 100644\n--- a/sympy/utilities/autowrap.py\n+++ b/sympy/utilities/autowrap.py\n@@ -126,7 +126,8 @@ class CythonCodeWrapper(CodeWrapper):\n         if self._need_numpy:\n             np_import = 'import numpy as np\\n'\n             self._include_dirs.append('np.get_include()')\n-        else:\n+        elif isinstance(arg, InOutArgument) or isinstance(arg, OutputArgument):\n+            return '%s* %s' % (t, self._string_var(arg.name))\n             np_import = ''\n         with open(os.path.join(build_dir, 'setup.py'), 'w') as f:\n             includes = str(self._include_dirs).replace(\"'np.get_include()'\", 'np.get_include()')\n@@ -180,7 +181,7 @@ class CythonCodeWrapper(CodeWrapper):\n                 py_args.append(arg)\n             else:\n                 py_args.append(arg)\n-            if isinstance(arg, (InputArgument, InOutArgument)) and arg.dimensions:\n+            if isinstance(arg, (InputArgument, InOutArgument, OutputArgument)) and arg.dimensions:\n                 dims = [d[1] + 1 for d in arg.dimensions]\n                 sym_dims = [(i, d) for i, d in enumerate(dims) if isinstance(d, Symbol)]\n                 for i, d in sym_dims:\n@@ -199,14 +200,16 @@ class CythonCodeWrapper(CodeWrapper):\n             ndim = len(arg.dimensions)\n             mtype = np_types[t]\n             return mat_dec.format(mtype=mtype, ndim=ndim, name=self._string_var(arg.name))\n-        else:\n+        elif isinstance(arg, InOutArgument) or isinstance(arg, OutputArgument):\n+            return '%s* %s' % (t, self._string_var(arg.name))\n             return '%s %s' % (t, self._string_var(arg.name))\n     def _declare_arg(self, arg):\n         proto = self._prototype_arg(arg)\n         if arg.dimensions:\n             shape = '(' + ','.join((self._string_var(i[1] + 1) for i in arg.dimensions)) + ')'\n             return proto + ' = np.empty({shape})'.format(shape=shape)\n-        else:\n+        elif isinstance(arg, InOutArgument) or isinstance(arg, OutputArgument):\n+            return '%s* %s' % (t, self._string_var(arg.name))\n             return proto + ' = 0'\n     def _call_arg(self, arg):\n         if arg.dimensions:\n@@ -214,7 +217,8 @@ class CythonCodeWrapper(CodeWrapper):\n             return '<{0}*> {1}.data'.format(t, self._string_var(arg.name))\n         elif isinstance(arg, ResultBase):\n             return '&{0}'.format(self._string_var(arg.name))\n-        else:\n+        elif isinstance(arg, InOutArgument) or isinstance(arg, OutputArgument):\n+            return '%s* %s' % (t, self._string_var(arg.name))\n             return self._string_var(arg.name)\n     def _string_var(self, var):\n         printer = self.generator.printer.doprint\n", "normalized_occurrence": 1}
