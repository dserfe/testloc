{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13146", "model_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex e24efd1..64715e7 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -643,6 +643,12 @@ def evalf_pow(v, prec, options):\n     target_prec = prec\n     base, exp = v.args\n \n+    # Convert Float exponents to Rational to ensure consistent handling\n+    if exp.is_Float:\n+        from sympy import nsimplify\n+        exp = nsimplify(exp, rational=True)\n+        v = v.func(base, exp)\n+\n     # We handle x**n separately. This has two purposes: 1) it is much\n     # faster, because we avoid calling evalf on the exponent, and 2) it\n     # allows better handling of real/imaginary parts that are exactly zero\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex 54c5b3f..433106c 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -357,6 +357,10 @@ def evalf_mul(v, prec, options):\n def evalf_pow(v, prec, options):\n     target_prec = prec\n     base, exp = v.args\n+    if exp.is_Float:\n+        from sympy import nsimplify\n+        exp = nsimplify(exp, rational=True)\n+        v = v.func(base, exp)\n     if exp.is_Integer:\n         p = exp.p\n         if not p:\n", "normalized_occurrence": 4}
