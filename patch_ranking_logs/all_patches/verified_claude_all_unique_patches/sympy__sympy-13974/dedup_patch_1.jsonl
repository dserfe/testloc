{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13974", "model_patch": "diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py\nindex 153c783..1af9136 100644\n--- a/sympy/physics/quantum/tensorproduct.py\n+++ b/sympy/physics/quantum/tensorproduct.py\n@@ -272,9 +272,10 @@ def tensor_product_simp_Mul(e):\n     \"\"\"Simplify a Mul with TensorProducts.\n \n     Current the main use of this is to simplify a ``Mul`` of ``TensorProduct``s\n-    to a ``TensorProduct`` of ``Muls``. It currently only works for relatively\n-    simple cases where the initial ``Mul`` only has scalars and raw\n-    ``TensorProduct``s, not ``Add``, ``Pow``, ``Commutator``s of\n+    to a ``TensorProduct`` of ``Muls``. This includes handling repeated tensor\n+    products (powers) by multiplying the corresponding elements. It currently only\n+    works for relatively simple cases where the initial ``Mul`` only has scalars\n+    and raw ``TensorProduct``s, not ``Add``, ``Pow``, ``Commutator``s of\n     ``TensorProduct``s.\n \n     Parameters\n@@ -335,10 +336,15 @@ def tensor_product_simp_Mul(e):\n                 for i in range(len(new_args)):\n                     new_args[i] = new_args[i] * next.args[i]\n             else:\n-                # this won't quite work as we don't want next in the\n-                # TensorProduct\n-                for i in range(len(new_args)):\n-                    new_args[i] = new_args[i] * next\n+                # Handle both regular multiplication and powers\n+                if current.args == next.args:\n+                    # Same tensor product components - multiply elements\n+                    for i in range(len(new_args)):\n+                        new_args[i] = new_args[i] * current.args[i]\n+                else:\n+                    # Different tensor products - multiply corresponding positions\n+                    for i in range(len(new_args)):\n+                        new_args[i] = new_args[i] * next.args[i]\n             current = next\n         return Mul(*c_part) * TensorProduct(*new_args)\n     else:\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py\nindex e23a275..f86c512 100644\n--- a/sympy/physics/quantum/tensorproduct.py\n+++ b/sympy/physics/quantum/tensorproduct.py\n@@ -150,9 +150,12 @@ def tensor_product_simp_Mul(e):\n                     raise QuantumError('TensorProducts of different lengths: %r and %r' % (current, next))\n                 for i in range(len(new_args)):\n                     new_args[i] = new_args[i] * next.args[i]\n+            elif current.args == next.args:\n+                for i in range(len(new_args)):\n+                    new_args[i] = new_args[i] * current.args[i]\n             else:\n                 for i in range(len(new_args)):\n-                    new_args[i] = new_args[i] * next\n+                    new_args[i] = new_args[i] * next.args[i]\n             current = next\n         return Mul(*c_part) * TensorProduct(*new_args)\n     else:\n", "normalized_occurrence": 1}
