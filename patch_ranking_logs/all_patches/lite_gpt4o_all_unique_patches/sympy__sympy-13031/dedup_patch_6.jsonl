{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13031", "model_patch": "diff --git a/sympy/matrices/dense.py b/sympy/matrices/dense.py\nindex 7b0ad01..51fc421 100644\n--- a/sympy/matrices/dense.py\n+++ b/sympy/matrices/dense.py\n@@ -170,29 +170,28 @@ class DenseMatrix(MatrixBase):\n         new_mat_cols = other.cols\n \n         # preallocate the array\n-        new_mat = [S.Zero]*new_mat_rows*new_mat_cols\n-\n-        # if we multiply an n x 0 with a 0 x m, the\n-        # expected behavior is to produce an n x m matrix of zeros\n-        if self.cols != 0 and other.rows != 0:\n-            # cache self._mat and other._mat for performance\n-            mat = self._mat\n-            other_mat = other._mat\n-            for i in range(len(new_mat)):\n-                row, col = i // new_mat_cols, i % new_mat_cols\n-                row_indices = range(self_cols*row, self_cols*(row+1))\n-                col_indices = range(col, other_len, other_cols)\n+        # if either matrix has zero dimension, the result is a zero matrix\n+        if self.cols == 0 or other.rows == 0:\n+            return classof(self, other)._new(new_mat_rows, new_mat_cols, [])\n+\n+        # cache self._mat and other._mat for performance\n+        mat = self._mat\n+        other_mat = other._mat\n+        for i in range(len(new_mat)):\n+            row, col = i // new_mat_cols, i % new_mat_cols\n+            row_indices = range(self_cols*row, self_cols*(row+1))\n+            col_indices = range(col, other_len, other_cols)\n+            vec = (mat[a]*other_mat[b] for a,b in zip(row_indices, col_indices))\n+            try:\n+                new_mat[i] = Add(*vec)\n+            except (TypeError, SympifyError):\n+                # Block matrices don't work with `sum` or `Add` (ISSUE #11599)\n+                # They don't work with `sum` because `sum` tries to add `0`\n+                # initially, and for a matrix, that is a mix of a scalar and\n+                # a matrix, which raises a TypeError. Fall back to a\n+                # block-matrix-safe way to multiply if the `sum` fails.\n                 vec = (mat[a]*other_mat[b] for a,b in zip(row_indices, col_indices))\n-                try:\n-                    new_mat[i] = Add(*vec)\n-                except (TypeError, SympifyError):\n-                    # Block matrices don't work with `sum` or `Add` (ISSUE #11599)\n-                    # They don't work with `sum` because `sum` tries to add `0`\n-                    # initially, and for a matrix, that is a mix of a scalar and\n-                    # a matrix, which raises a TypeError. Fall back to a\n-                    # block-matrix-safe way to multiply if the `sum` fails.\n-                    vec = (mat[a]*other_mat[b] for a,b in zip(row_indices, col_indices))\n-                    new_mat[i] = reduce(lambda a,b: a + b, vec)\n+                new_mat[i] = reduce(lambda a,b: a + b, vec)\n         return classof(self, other)._new(new_mat_rows, new_mat_cols, new_mat, copy=False)\n \n     def _eval_matrix_mul_elementwise(self, other):\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/matrices/dense.py b/sympy/matrices/dense.py\nindex edd691e..4125cd2 100644\n--- a/sympy/matrices/dense.py\n+++ b/sympy/matrices/dense.py\n@@ -91,20 +91,20 @@ class DenseMatrix(MatrixBase):\n         other_len = other_rows * other_cols\n         new_mat_rows = self.rows\n         new_mat_cols = other.cols\n-        new_mat = [S.Zero] * new_mat_rows * new_mat_cols\n-        if self.cols != 0 and other.rows != 0:\n-            mat = self._mat\n-            other_mat = other._mat\n-            for i in range(len(new_mat)):\n-                row, col = (i // new_mat_cols, i % new_mat_cols)\n-                row_indices = range(self_cols * row, self_cols * (row + 1))\n-                col_indices = range(col, other_len, other_cols)\n+        if self.cols == 0 or other.rows == 0:\n+            return classof(self, other)._new(new_mat_rows, new_mat_cols, [])\n+        mat = self._mat\n+        other_mat = other._mat\n+        for i in range(len(new_mat)):\n+            row, col = (i // new_mat_cols, i % new_mat_cols)\n+            row_indices = range(self_cols * row, self_cols * (row + 1))\n+            col_indices = range(col, other_len, other_cols)\n+            vec = (mat[a] * other_mat[b] for a, b in zip(row_indices, col_indices))\n+            try:\n+                new_mat[i] = Add(*vec)\n+            except (TypeError, SympifyError):\n                 vec = (mat[a] * other_mat[b] for a, b in zip(row_indices, col_indices))\n-                try:\n-                    new_mat[i] = Add(*vec)\n-                except (TypeError, SympifyError):\n-                    vec = (mat[a] * other_mat[b] for a, b in zip(row_indices, col_indices))\n-                    new_mat[i] = reduce(lambda a, b: a + b, vec)\n+                new_mat[i] = reduce(lambda a, b: a + b, vec)\n         return classof(self, other)._new(new_mat_rows, new_mat_cols, new_mat, copy=False)\n     def _eval_matrix_mul_elementwise(self, other):\n         mat = [a * b for a, b in zip(self._mat, other._mat)]\n", "normalized_occurrence": 1}
