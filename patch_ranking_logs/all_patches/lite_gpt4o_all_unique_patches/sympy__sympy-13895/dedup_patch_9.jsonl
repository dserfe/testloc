{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13895", "model_patch": "diff --git a/sympy/core/power.py b/sympy/core/power.py\nindex 53e26ca..edd5a70 100644\n--- a/sympy/core/power.py\n+++ b/sympy/core/power.py\n@@ -211,22 +211,17 @@ class Pow(Expr):\n                     return S.NaN\n                 return S.One\n             else:\n-                # recognize base as E\n-                if not e.is_Atom and b is not S.Exp1 and not isinstance(b, exp_polar):\n-                    from sympy import numer, denom, log, sign, im, factor_terms\n-                    c, ex = factor_terms(e, sign=False).as_coeff_Mul()\n-                    den = denom(ex)\n-                    if isinstance(den, log) and den.args[0] == b:\n-                        return S.Exp1**(c*numer(ex))\n-                    elif den.is_Add:\n-                        s = sign(im(b))\n-                        if s.is_Number and s and den == \\\n-                                log(-factor_terms(b, sign=False)) + s*S.ImaginaryUnit*S.Pi:\n-                            return S.Exp1**(c*numer(ex))\n-\n-                obj = b._eval_power(e)\n-                if obj is not None:\n-                    return obj\n+                # Only perform autosimplification if exponent or base is a Symbol or number\n+                if (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number):\n+                    if e.is_integer and _coeff_isneg(b):\n+                        if e.is_even:\n+                            b = -b\n+                        elif e.is_odd:\n+                            return -Pow(-b, e)\n+                    elif e.is_rational:  # fix for negative base with fractional exponent\n+                        n, d = e.as_numer_denom()\n+                        if _coeff_isneg(b) and d % 2 == 1:\n+                            return S.ImaginaryUnit**n * Pow(-b, e)\n         obj = Expr.__new__(cls, b, e)\n         obj = cls._exec_constructor_postprocessors(obj)\n         if not isinstance(obj, Pow):\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/power.py b/sympy/core/power.py\nindex 7698f23..d0d8fa9 100644\n--- a/sympy/core/power.py\n+++ b/sympy/core/power.py\n@@ -83,20 +83,16 @@ class Pow(Expr):\n                 if abs(e).is_infinite:\n                     return S.NaN\n                 return S.One\n-            else:\n-                if not e.is_Atom and b is not S.Exp1 and (not isinstance(b, exp_polar)):\n-                    from sympy import numer, denom, log, sign, im, factor_terms\n-                    c, ex = factor_terms(e, sign=False).as_coeff_Mul()\n-                    den = denom(ex)\n-                    if isinstance(den, log) and den.args[0] == b:\n-                        return S.Exp1 ** (c * numer(ex))\n-                    elif den.is_Add:\n-                        s = sign(im(b))\n-                        if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):\n-                            return S.Exp1 ** (c * numer(ex))\n-                obj = b._eval_power(e)\n-                if obj is not None:\n-                    return obj\n+            elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number):\n+                if e.is_integer and _coeff_isneg(b):\n+                    if e.is_even:\n+                        b = -b\n+                    elif e.is_odd:\n+                        return -Pow(-b, e)\n+                elif e.is_rational:\n+                    n, d = e.as_numer_denom()\n+                    if _coeff_isneg(b) and d % 2 == 1:\n+                        return S.ImaginaryUnit ** n * Pow(-b, e)\n         obj = Expr.__new__(cls, b, e)\n         obj = cls._exec_constructor_postprocessors(obj)\n         if not isinstance(obj, Pow):\n", "normalized_occurrence": 1}
