{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-24661", "model_patch": "diff --git a/sympy/core/relational.py b/sympy/core/relational.py\nindex c35b72b..8f25fb8 100644\n--- a/sympy/core/relational.py\n+++ b/sympy/core/relational.py\n@@ -147,7 +147,7 @@ class Relational(Boolean, EvalfMixin):\n     # ValidRelationOperator - Defined below, because the necessary classes\n     #   have not yet been defined\n \n-    def __new__(cls, lhs, rhs, rop=None, **assumptions):\n+    def __new__(cls, lhs, rhs, rop=None, evaluate=True, **assumptions):\n         # If called by a subclass, do nothing special and pass on to Basic.\n         if cls is not Relational:\n             return Basic.__new__(cls, lhs, rhs, **assumptions)\n@@ -615,12 +615,10 @@ class Equality(Relational):\n         rhs = _sympify(rhs)\n         if evaluate:\n             val = is_eq(lhs, rhs)\n-            if val is None:\n-                return cls(lhs, rhs, evaluate=False)\n-            else:\n+            if val is not None:\n                 return _sympify(val)\n \n-        return Relational.__new__(cls, lhs, rhs)\n+        return Relational.__new__(cls, lhs, rhs, evaluate=evaluate)\n \n     @classmethod\n     def _eval_relation(cls, lhs, rhs):\n@@ -766,12 +764,10 @@ class Unequality(Relational):\n         evaluate = options.pop('evaluate', global_parameters.evaluate)\n         if evaluate:\n             val = is_neq(lhs, rhs)\n-            if val is None:\n-                return cls(lhs, rhs, evaluate=False)\n-            else:\n+            if val is not None:\n                 return _sympify(val)\n \n-        return Relational.__new__(cls, lhs, rhs, **options)\n+        return Relational.__new__(cls, lhs, rhs, evaluate=evaluate)\n \n     @classmethod\n     def _eval_relation(cls, lhs, rhs):\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/relational.py b/sympy/core/relational.py\nindex 6f6b8fe..d920f9f 100644\n--- a/sympy/core/relational.py\n+++ b/sympy/core/relational.py\n@@ -34,7 +34,7 @@ class Relational(Boolean, EvalfMixin):\n     __slots__ = ()\n     ValidRelationOperator: dict[str | None, type[Relational]] = {}\n     is_Relational = True\n-    def __new__(cls, lhs, rhs, rop=None, **assumptions):\n+    def __new__(cls, lhs, rhs, rop=None, evaluate=True, **assumptions):\n         if cls is not Relational:\n             return Basic.__new__(cls, lhs, rhs, **assumptions)\n         cls = cls.ValidRelationOperator.get(rop, None)\n@@ -248,11 +248,9 @@ class Equality(Relational):\n         rhs = _sympify(rhs)\n         if evaluate:\n             val = is_eq(lhs, rhs)\n-            if val is None:\n-                return cls(lhs, rhs, evaluate=False)\n-            else:\n+            if val is not None:\n                 return _sympify(val)\n-        return Relational.__new__(cls, lhs, rhs)\n+        return Relational.__new__(cls, lhs, rhs, evaluate=evaluate)\n     @classmethod\n     def _eval_relation(cls, lhs, rhs):\n         return _sympify(lhs == rhs)\n@@ -317,11 +315,9 @@ class Unequality(Relational):\n         evaluate = options.pop('evaluate', global_parameters.evaluate)\n         if evaluate:\n             val = is_neq(lhs, rhs)\n-            if val is None:\n-                return cls(lhs, rhs, evaluate=False)\n-            else:\n+            if val is not None:\n                 return _sympify(val)\n-        return Relational.__new__(cls, lhs, rhs, **options)\n+        return Relational.__new__(cls, lhs, rhs, evaluate=evaluate)\n     @classmethod\n     def _eval_relation(cls, lhs, rhs):\n         return _sympify(lhs != rhs)\n", "normalized_occurrence": 1}
