{"model_name_or_path": "agentless", "instance_id": "psf__requests-6028", "model_patch": "diff --git a/requests/adapters.py b/requests/adapters.py\nindex d47134b..b3d34ef 100644\n--- a/requests/adapters.py\n+++ b/requests/adapters.py\n@@ -370,7 +370,7 @@ class HTTPAdapter(BaseAdapter):\n         \"\"\"\n         pass\n \n-    def proxy_headers(self, proxy):\n+    def proxy_headers(self, proxy, request):\n         \"\"\"Returns a dictionary of the headers to add to any request sent\n         through a proxy. This works with urllib3 magic to ensure that they are\n         correctly sent to the proxy, rather than in a tunnelled request if\n@@ -381,6 +381,7 @@ class HTTPAdapter(BaseAdapter):\n         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n \n         :param proxy: The url of the proxy being used for this request.\n+        :param request: The PreparedRequest to which the headers will be added.\n         :rtype: dict\n         \"\"\"\n         headers = {}\n@@ -390,6 +391,9 @@ class HTTPAdapter(BaseAdapter):\n             headers['Proxy-Authorization'] = _basic_auth_str(username,\n                                                              password)\n \n+        # Copy over any existing proxy headers\n+        headers.update(request.headers.get('Proxy-Authorization', {}))\n+\n         return headers\n \n     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n@@ -417,6 +421,12 @@ class HTTPAdapter(BaseAdapter):\n         self.cert_verify(conn, request.url, verify, cert)\n         url = self.request_url(request, proxies)\n         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\n+        \n+        # Add proxy headers to the request\n+        if proxies and 'https' in proxies:\n+            request.headers.update(self.proxy_headers(proxies['https'], request))\n+        elif proxies and 'http' in proxies:\n+            request.headers.update(self.proxy_headers(proxies['http'], request))\n \n         chunked = not (request.body is None or 'Content-Length' in request.headers)\n \n@@ -535,4 +545,4 @@ class HTTPAdapter(BaseAdapter):\n             else:\n                 raise\n \n-        return self.build_response(request, resp)\n+        return self.build_response(request, resp)\n", "occurrence": 1, "normalized_patch": "diff --git a/requests/adapters.py b/requests/adapters.py\nindex 8bf110e..4dfbd51 100644\n--- a/requests/adapters.py\n+++ b/requests/adapters.py\n@@ -153,11 +153,12 @@ class HTTPAdapter(BaseAdapter):\n         return url\n     def add_headers(self, request, **kwargs):\n         pass\n-    def proxy_headers(self, proxy):\n+    def proxy_headers(self, proxy, request):\n         headers = {}\n         username, password = get_auth_from_url(proxy)\n         if username:\n             headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n+        headers.update(request.headers.get('Proxy-Authorization', {}))\n         return headers\n     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n         try:\n@@ -167,6 +168,10 @@ class HTTPAdapter(BaseAdapter):\n         self.cert_verify(conn, request.url, verify, cert)\n         url = self.request_url(request, proxies)\n         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\n+        if proxies and 'https' in proxies:\n+            request.headers.update(self.proxy_headers(proxies['https'], request))\n+        elif proxies and 'http' in proxies:\n+            request.headers.update(self.proxy_headers(proxies['http'], request))\n         chunked = not (request.body is None or 'Content-Length' in request.headers)\n         if isinstance(timeout, tuple):\n             try:\n", "normalized_occurrence": 1}
