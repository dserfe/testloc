{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-20801", "model_patch": "diff --git a/sympy/core/numbers.py b/sympy/core/numbers.py\nindex ecd2cce..e45a670 100644\n--- a/sympy/core/numbers.py\n+++ b/sympy/core/numbers.py\n@@ -1400,14 +1400,19 @@ class Float(Number):\n             return self._mpf_ == other._mpf_\n         if other.is_Rational:\n             return other.__eq__(self)\n-        if other.is_Number:\n-            # numbers should compare at the same precision;\n-            # all _as_mpf_val routines should be sure to abide\n-            # by the request to change the prec if necessary; if\n-            # they don't, the equality test will fail since it compares\n-            # the mpf tuples\n-            ompf = other._as_mpf_val(self._prec)\n-            return bool(mlib.mpf_eq(self._mpf_, ompf))\n+        if other.is_Number or other == False or other == True:\n+            if other == S.false:\n+                return self.is_zero\n+            if other == S.true:\n+                return not self.is_zero\n+            if other.is_Number:\n+                # numbers should compare at the same precision;\n+                # all _as_mpf_val routines should be sure to abide\n+                # by the request to change the prec if necessary; if\n+                # they don't, the equality test will fail since it compares\n+                # the mpf tuples\n+                ompf = other._as_mpf_val(self._prec)\n+                return bool(mlib.mpf_eq(self._mpf_, ompf))\n         return False    # Float != non-Number\n \n     def __ne__(self, other):\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/numbers.py b/sympy/core/numbers.py\nindex c5d42bc..5a0e51b 100644\n--- a/sympy/core/numbers.py\n+++ b/sympy/core/numbers.py\n@@ -1203,9 +1203,14 @@ class Float(Number):\n             return self._mpf_ == other._mpf_\n         if other.is_Rational:\n             return other.__eq__(self)\n-        if other.is_Number:\n-            ompf = other._as_mpf_val(self._prec)\n-            return bool(mlib.mpf_eq(self._mpf_, ompf))\n+        if other.is_Number or other == False or other == True:\n+            if other == S.false:\n+                return self.is_zero\n+            if other == S.true:\n+                return not self.is_zero\n+            if other.is_Number:\n+                ompf = other._as_mpf_val(self._prec)\n+                return bool(mlib.mpf_eq(self._mpf_, ompf))\n         return False\n \n     def __ne__(self, other):\n", "normalized_occurrence": 1}
