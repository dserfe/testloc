{"model_name_or_path": "agentless_claude", "instance_id": "sphinx-doc__sphinx-9591", "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 08b07d9..b63f7ee 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -2708,34 +2708,7 @@ class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  #\n         real_modname = self.get_attr(self.parent or self.object, '__module__', None)\n         return real_modname or self.modname\n \n-    def add_directive_header(self, sig: str) -> None:\n-        super().add_directive_header(sig)\n-        sourcename = self.get_sourcename()\n-        if inspect.isabstractmethod(self.object):\n-            self.add_line('   :abstractmethod:', sourcename)\n-        if self.isclassmethod:\n-            self.add_line('   :classmethod:', sourcename)\n-\n-        if safe_getattr(self.object, 'fget', None):  # property\n-            func = self.object.fget\n-        elif safe_getattr(self.object, 'func', None):  # cached_property\n-            func = self.object.func\n-        else:\n-            func = None\n \n-        if func and self.config.autodoc_typehints != 'none':\n-            try:\n-                signature = inspect.signature(func,\n-                                              type_aliases=self.config.autodoc_type_aliases)\n-                if signature.return_annotation is not Parameter.empty:\n-                    objrepr = stringify_typehint(signature.return_annotation)\n-                    self.add_line('   :type: ' + objrepr, sourcename)\n-            except TypeError as exc:\n-                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n-                               self.fullname, exc)\n-                return None\n-            except ValueError:\n-                return None\n \n \n class NewTypeAttributeDocumenter(AttributeDocumenter):\n", "occurrence": 1, "normalized_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 3c49975..2a8c5a5 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1629,30 +1629,6 @@ class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):\n     def get_real_modname(self) -> str:\n         real_modname = self.get_attr(self.parent or self.object, '__module__', None)\n         return real_modname or self.modname\n-    def add_directive_header(self, sig: str) -> None:\n-        super().add_directive_header(sig)\n-        sourcename = self.get_sourcename()\n-        if inspect.isabstractmethod(self.object):\n-            self.add_line('   :abstractmethod:', sourcename)\n-        if self.isclassmethod:\n-            self.add_line('   :classmethod:', sourcename)\n-        if safe_getattr(self.object, 'fget', None):\n-            func = self.object.fget\n-        elif safe_getattr(self.object, 'func', None):\n-            func = self.object.func\n-        else:\n-            func = None\n-        if func and self.config.autodoc_typehints != 'none':\n-            try:\n-                signature = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)\n-                if signature.return_annotation is not Parameter.empty:\n-                    objrepr = stringify_typehint(signature.return_annotation)\n-                    self.add_line('   :type: ' + objrepr, sourcename)\n-            except TypeError as exc:\n-                logger.warning(__('Failed to get a function signature for %s: %s'), self.fullname, exc)\n-                return None\n-            except ValueError:\n-                return None\n class NewTypeAttributeDocumenter(AttributeDocumenter):\n     objtype = 'newvarattribute'\n     directivetype = 'attribute'\n", "normalized_occurrence": 1}
