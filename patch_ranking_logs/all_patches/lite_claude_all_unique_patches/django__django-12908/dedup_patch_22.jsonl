{"model_name_or_path": "agentless_claude", "instance_id": "django__django-12908", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex a26bee7..91897e6 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -512,6 +512,10 @@ class SQLCompiler:\n                 params = []\n \n                 if self.query.distinct:\n+                    if combinator:\n+                        # For combined queries (e.g. UNION), wrap in a subquery before applying DISTINCT\n+                        inner_query = ' '.join(result)\n+                        result = ['SELECT']\n                     distinct_result, distinct_params = self.connection.ops.distinct_sql(\n                         distinct_fields,\n                         distinct_params,\n@@ -601,13 +605,14 @@ class SQLCompiler:\n             if for_update_part and not self.connection.features.for_update_after_from:\n                 result.append(for_update_part)\n \n-            if self.query.subquery and extra_select:\n-                # If the query is used as a subquery, the extra selects would\n-                # result in more columns than the left-hand side expression is\n-                # expecting. This can happen when a subquery uses a combination\n-                # of order_by() and distinct(), forcing the ordering expressions\n-                # to be selected as well. Wrap the query in another subquery\n-                # to exclude extraneous selects.\n+            if (self.query.subquery and extra_select) or (combinator and self.query.distinct):\n+                # Wrap in subquery if:\n+                # 1. Query is a subquery with extra selects\n+                # 2. Query is a combinator (e.g. UNION) with DISTINCT\n+                # For subqueries, the extra selects would result in more columns than \n+                # the left-hand side expression is expecting. This can happen when a \n+                # subquery uses a combination of order_by() and distinct(), forcing \n+                # the ordering expressions to be selected as well.\n                 sub_selects = []\n                 sub_params = []\n                 for index, (select, _, alias) in enumerate(self.select, start=1):\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex e6a07a3..243fbce 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -292,6 +292,9 @@ class SQLCompiler:\n                 result = ['SELECT']\n                 params = []\n                 if self.query.distinct:\n+                    if combinator:\n+                        inner_query = ' '.join(result)\n+                        result = ['SELECT']\n                     distinct_result, distinct_params = self.connection.ops.distinct_sql(distinct_fields, distinct_params)\n                     result += distinct_result\n                     params += distinct_params\n@@ -353,7 +356,7 @@ class SQLCompiler:\n                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))\n             if for_update_part and (not self.connection.features.for_update_after_from):\n                 result.append(for_update_part)\n-            if self.query.subquery and extra_select:\n+            if self.query.subquery and extra_select or (combinator and self.query.distinct):\n                 sub_selects = []\n                 sub_params = []\n                 for index, (select, _, alias) in enumerate(self.select, start=1):\n", "normalized_occurrence": 1}
