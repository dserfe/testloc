{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-22080", "model_patch": "diff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex ca33049..8e33286 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.numbers import nan\n from .function import Function\n from .kind import NumberKind\n@@ -42,6 +43,7 @@ class Mod(Function):\n         from sympy.core.exprtools import gcd_terms\n         from sympy.polys.polyerrors import PolynomialError\n         from sympy.polys.polytools import gcd\n+        from sympy.core.numbers import NegativeOne\n \n         def doit(p, q):\n             \"\"\"Try to return p % q if both are numbers or +/-p is known\n@@ -209,6 +211,9 @@ class Mod(Function):\n         # simple -1 extraction\n         if p.could_extract_minus_sign() and q.could_extract_minus_sign():\n             G, p, q = [-i for i in (G, p, q)]\n+        # Handle negation specifically to avoid moving it inside modulo\n+        if p.could_extract_minus_sign():\n+            return -cls(-p, q, evaluate=False)\n \n         # check again to see if p and q can now be handled as numbers\n         rv = doit(p, q)\n@@ -240,4 +245,4 @@ class Mod(Function):\n \n     def _eval_rewrite_as_floor(self, a, b, **kwargs):\n         from sympy.functions.elementary.integers import floor\n-        return a - b*floor(a/b)\n+        return a - b*floor(a/b)\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex 57d2396..60640bc 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -11,6 +11,7 @@ class Mod(Function):\n         from sympy.core.exprtools import gcd_terms\n         from sympy.polys.polyerrors import PolynomialError\n         from sympy.polys.polytools import gcd\n+        from sympy.core.numbers import NegativeOne\n         def doit(p, q):\n             if q.is_zero:\n                 raise ZeroDivisionError('Modulo by zero')\n@@ -139,6 +140,8 @@ class Mod(Function):\n                 q = cq * q\n         if p.could_extract_minus_sign() and q.could_extract_minus_sign():\n             G, p, q = [-i for i in (G, p, q)]\n+        if p.could_extract_minus_sign():\n+            return -cls(-p, q, evaluate=False)\n         rv = doit(p, q)\n         if rv is not None:\n             return rv * G\n", "normalized_occurrence": 1}
