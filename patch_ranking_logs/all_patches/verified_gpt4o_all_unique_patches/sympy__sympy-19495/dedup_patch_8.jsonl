{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-19495", "model_patch": "diff --git a/sympy/sets/conditionset.py b/sympy/sets/conditionset.py\nindex 934bff8..3fa8f53 100644\n--- a/sympy/sets/conditionset.py\n+++ b/sympy/sets/conditionset.py\n@@ -211,24 +211,30 @@ class ConditionSet(Set):\n             # that should go away, eventually.\n             return self\n         sym, cond, base = self.args\n+        # Substitute in the condition and the base set\n+        cond = self.condition.subs(old, new)\n+        base = self.base_set.subs(old, new)\n+\n+        # If the substitution results in True condition, return a new ConditionSet\n+        if cond is S.true:\n+            return ConditionSet(self.sym, Contains(self.sym, base), base)\n+\n+        # If the old symbol being replaced is the bound variable, handle separately\n         if old == sym:\n-            # we try to be as lenient as possible to allow\n-            # the dummy symbol to be changed\n+            # Substitute in the base set\n             base = base.subs(old, new)\n+\n+            # If new is a Symbol, handle assumptions and substitution specifically\n             if isinstance(new, Symbol):\n-                # if the assumptions don't match, the cond\n-                # might evaluate or change\n+                # Check assumptions compatibility\n                 if (new.assumptions0 == old.assumptions0 or\n                         len(new.assumptions0) == 1 and\n                         old.is_commutative == new.is_commutative):\n+                    # If the base set changes, keep the original bound variable\n                     if base != self.base_set:\n-                        # it will be aggravating to have the dummy\n-                        # symbol change if you are trying to target\n-                        # the base set so if the base set is changed\n-                        # leave the dummy symbol alone -- a second\n-                        # subs will be needed to change the dummy\n                         return self.func(sym, cond, base)\n                     else:\n+                        # Substitute in the condition and return new ConditionSet\n                         return self.func(new, cond.subs(old, new), base)\n                 raise ValueError(filldedent('''\n                     A dummy symbol can only be\n@@ -236,10 +242,10 @@ class ConditionSet(Set):\n                     assumptions or one having a single assumption\n                     having the same commutativity.\n                 '''))\n-            # don't target cond: it is there to tell how\n-            # the base set should be filtered and if new is not in\n-            # the base set then this substitution is ignored\n+            # Substitute in the base set only if new is not in the base set\n             return self.func(sym, cond, base)\n+\n+        # Return a new ConditionSet with the substituted condition and base set\n         cond = self.condition.subs(old, new)\n         base = self.base_set.subs(old, new)\n         if cond is S.true:\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/sets/conditionset.py b/sympy/sets/conditionset.py\nindex c7937ea..151a6e0 100644\n--- a/sympy/sets/conditionset.py\n+++ b/sympy/sets/conditionset.py\n@@ -79,6 +79,10 @@ class ConditionSet(Set):\n         if not isinstance(self.sym, Expr):\n             return self\n         sym, cond, base = self.args\n+        cond = self.condition.subs(old, new)\n+        base = self.base_set.subs(old, new)\n+        if cond is S.true:\n+            return ConditionSet(self.sym, Contains(self.sym, base), base)\n         if old == sym:\n             base = base.subs(old, new)\n             if isinstance(new, Symbol):\n", "normalized_occurrence": 1}
