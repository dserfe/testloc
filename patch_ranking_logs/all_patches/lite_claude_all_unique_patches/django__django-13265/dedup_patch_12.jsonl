{"model_name_or_path": "agentless_claude", "instance_id": "django__django-13265", "model_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 8c23741..a784cdd 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -113,6 +113,28 @@ class MigrationAutodetector:\n         graph is an optional argument that, if provided, can help improve\n         dependency generation and avoid potential circular dependencies.\n         \"\"\"\n+        def _reorder_operations(operations):\n+            \"\"\"Helper to reorder operations to handle _order field dependencies.\"\"\"\n+            # Find AlterOrderWithRespectTo and related AddIndex operations\n+            alter_order_ops = []\n+            index_ops = []\n+            other_ops = []\n+            \n+            for op in operations:\n+                if isinstance(op, migrations.AlterOrderWithRespectTo):\n+                    alter_order_ops.append(op)\n+                elif isinstance(op, migrations.AddIndex):\n+                    # Check if index references _order field\n+                    if '_order' in op.index.fields:\n+                        index_ops.append(op)\n+                    else:\n+                        other_ops.append(op)\n+                else:\n+                    other_ops.append(op)\n+            \n+            # Return operations with AlterOrderWithRespectTo before dependent indexes\n+            return alter_order_ops + other_ops + index_ops\n+\n         # The first phase is generating all the operations for each app\n         # and gathering them into a big per-app list.\n         # Then go through that list, order it, and split into migrations to\n@@ -120,6 +142,7 @@ class MigrationAutodetector:\n         self.generated_operations = {}\n         self.altered_indexes = {}\n         self.altered_constraints = {}\n+        self.order_with_respect_to_ops = {}  # Track order_with_respect_to operations\n \n         # Prepare some old/new state and model lists, separating\n         # proxy models and ignoring unmigrated apps.\n@@ -137,6 +160,8 @@ class MigrationAutodetector:\n                 self.old_unmanaged_keys.add((al, mn))\n             elif al not in self.from_state.real_apps:\n                 if model._meta.proxy:\n+                    # After collecting operations, reorder them\n+                    self.generated_operations[al] = _reorder_operations(self.generated_operations.get(al, []))\n                     self.old_proxy_keys.add((al, mn))\n                 else:\n                     self.old_model_keys.add((al, mn))\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 48a2b0b..d88f0d9 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -52,9 +52,25 @@ class MigrationAutodetector:\n             fields_def.append(deconstruction)\n         return fields_def\n     def _detect_changes(self, convert_apps=None, graph=None):\n+        def _reorder_operations(operations):\n+            alter_order_ops = []\n+            index_ops = []\n+            other_ops = []\n+            for op in operations:\n+                if isinstance(op, migrations.AlterOrderWithRespectTo):\n+                    alter_order_ops.append(op)\n+                elif isinstance(op, migrations.AddIndex):\n+                    if '_order' in op.index.fields:\n+                        index_ops.append(op)\n+                    else:\n+                        other_ops.append(op)\n+                else:\n+                    other_ops.append(op)\n+            return alter_order_ops + other_ops + index_ops\n         self.generated_operations = {}\n         self.altered_indexes = {}\n         self.altered_constraints = {}\n+        self.order_with_respect_to_ops = {}\n         self.old_apps = self.from_state.concrete_apps\n         self.new_apps = self.to_state.apps\n         self.old_model_keys = set()\n@@ -69,6 +85,7 @@ class MigrationAutodetector:\n                 self.old_unmanaged_keys.add((al, mn))\n             elif al not in self.from_state.real_apps:\n                 if model._meta.proxy:\n+                    self.generated_operations[al] = _reorder_operations(self.generated_operations.get(al, []))\n                     self.old_proxy_keys.add((al, mn))\n                 else:\n                     self.old_model_keys.add((al, mn))\n", "normalized_occurrence": 1}
