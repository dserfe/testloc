{"model_name_or_path": "agentless_claude", "instance_id": "sphinx-doc__sphinx-9602", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex fbfe7b9..930530e 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -80,31 +80,7 @@ class ModuleEntry(NamedTuple):\n     deprecated: bool\n \n \n-def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n-    \"\"\"Convert a type string to a cross reference node.\"\"\"\n-    if text == 'None':\n-        reftype = 'obj'\n-    else:\n-        reftype = 'class'\n-\n-    if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'),\n-                  'py:class': env.ref_context.get('py:class')}\n-    else:\n-        kwargs = {}\n-\n-    if env.config.python_use_unqualified_type_names:\n-        # Note: It would be better to use qualname to describe the object to support support\n-        # nested classes.  But python domain can't access the real python object because this\n-        # module should work not-dynamically.\n-        shortname = text.split('.')[-1]\n-        contnodes: List[Node] = [pending_xref_condition('', shortname, condition='resolved'),\n-                                 pending_xref_condition('', text, condition='*')]\n-    else:\n-        contnodes = [nodes.Text(text)]\n \n-    return pending_xref('', *contnodes,\n-                        refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n \n \n def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\n", "occurrence": 2, "normalized_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 6040d43..d29b316 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -42,21 +42,6 @@ class ModuleEntry(NamedTuple):\n     synopsis: str\n     platform: str\n     deprecated: bool\n-def type_to_xref(text: str, env: BuildEnvironment=None) -> addnodes.pending_xref:\n-    if text == 'None':\n-        reftype = 'obj'\n-    else:\n-        reftype = 'class'\n-    if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'), 'py:class': env.ref_context.get('py:class')}\n-    else:\n-        kwargs = {}\n-    if env.config.python_use_unqualified_type_names:\n-        shortname = text.split('.')[-1]\n-        contnodes: List[Node] = [pending_xref_condition('', shortname, condition='resolved'), pending_xref_condition('', text, condition='*')]\n-    else:\n-        contnodes = [nodes.Text(text)]\n-    return pending_xref('', *contnodes, refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n def _parse_annotation(annotation: str, env: BuildEnvironment=None) -> List[Node]:\n     def unparse(node: ast.AST) -> List[Node]:\n         if isinstance(node, ast.Attribute):\n", "normalized_occurrence": 2}
