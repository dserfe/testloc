{"model_name_or_path": "agentless_claude", "instance_id": "django__django-14500", "model_patch": "diff --git a/django/db/migrations/executor.py b/django/db/migrations/executor.py\nindex 9e05ef1..1f29016 100644\n--- a/django/db/migrations/executor.py\n+++ b/django/db/migrations/executor.py\n@@ -163,10 +163,19 @@ class MigrationExecutor:\n         # Holds all migration states prior to the migrations being unapplied\n         states = {}\n         state = self._create_project_state()\n-        applied_migrations = {\n-            self.loader.graph.nodes[key] for key in self.loader.applied_migrations\n-            if key in self.loader.graph.nodes\n-        }\n+        applied_migrations = set()\n+        for key in self.loader.applied_migrations:\n+            if key not in self.loader.graph.nodes:\n+                continue\n+            migration = self.loader.graph.nodes[key]\n+            # Include the migration if it's in the graph\n+            applied_migrations.add(migration)\n+            # If this is a squashed migration, ensure it stays applied\n+            # when only unapplying its replaced migrations\n+            if hasattr(migration, 'replaces') and migration.replaces:\n+                replaced_nodes = {self.loader.graph.nodes[n] for n in migration.replaces if n in self.loader.graph.nodes}\n+                if not replaced_nodes - migrations_to_run:\n+                    applied_migrations.add(migration)\n         if self.progress_callback:\n             self.progress_callback(\"render_start\")\n         for migration, _ in full_plan:\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/migrations/executor.py b/django/db/migrations/executor.py\nindex d5a1e7d..16d2949 100644\n--- a/django/db/migrations/executor.py\n+++ b/django/db/migrations/executor.py\n@@ -85,7 +85,16 @@ class MigrationExecutor:\n         migrations_to_run = {m[0] for m in plan}\n         states = {}\n         state = self._create_project_state()\n-        applied_migrations = {self.loader.graph.nodes[key] for key in self.loader.applied_migrations if key in self.loader.graph.nodes}\n+        applied_migrations = set()\n+        for key in self.loader.applied_migrations:\n+            if key not in self.loader.graph.nodes:\n+                continue\n+            migration = self.loader.graph.nodes[key]\n+            applied_migrations.add(migration)\n+            if hasattr(migration, 'replaces') and migration.replaces:\n+                replaced_nodes = {self.loader.graph.nodes[n] for n in migration.replaces if n in self.loader.graph.nodes}\n+                if not replaced_nodes - migrations_to_run:\n+                    applied_migrations.add(migration)\n         if self.progress_callback:\n             self.progress_callback('render_start')\n         for migration, _ in full_plan:\n", "normalized_occurrence": 1}
