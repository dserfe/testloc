{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8548", "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 60d49fe..9dd86c3 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -667,27 +667,33 @@ class Documenter:\n         ``autodoc-skip-member`` event.\n         \"\"\"\n         def is_filtered_inherited_member(name: str) -> bool:\n-            if inspect.isclass(self.object):\n-                for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n-                        # given member is a member of specified *super class*\n+            if inspect.isclass(self.object) and self.options.inherited_members:\n+                for base in self.object.__mro__:\n+                    if base == self.object:\n+                        continue\n+                    if name in base.__dict__:\n+                        return True\n+                    if name in self.get_attr(base, '__annotations__', {}):\n                         return True\n-                    elif name in cls.__dict__:\n-                        return False\n-                    elif name in self.get_attr(cls, '__annotations__', {}):\n-                        return False\n \n             return False\n \n         ret = []\n \n         # search for members in source code too\n-        namespace = '.'.join(self.objpath)  # will be empty for modules\n+        namespaces = ['.'.join(self.objpath)]\n \n-        if self.analyzer:\n-            attr_docs = self.analyzer.find_attr_docs()\n-        else:\n-            attr_docs = {}\n+        # Add base class namespaces if inherited_members is set\n+        if self.options.inherited_members and inspect.isclass(self.object):\n+            for base in self.object.__bases__:\n+                base_path = getattr(base, '__module__', None)\n+                if base_path:\n+                    namespaces.append(base_path + '.' + base.__name__)\n+\n+        attr_docs = {}\n+        for namespace in namespaces:\n+            if self.analyzer:\n+                attr_docs.update(self.analyzer.find_attr_docs(namespace))\n \n         # process members and determine which to skip\n         for obj in members:\n", "occurrence": 1, "normalized_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex c754f31..2e89c2d 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -341,21 +341,26 @@ class Documenter:\n             return (False, [(m.name, m.value) for m in members.values() if m.directly_defined])\n     def filter_members(self, members: ObjectMembers, want_all: bool) -> List[Tuple[str, Any, bool]]:\n         def is_filtered_inherited_member(name: str) -> bool:\n-            if inspect.isclass(self.object):\n-                for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n+            if inspect.isclass(self.object) and self.options.inherited_members:\n+                for base in self.object.__mro__:\n+                    if base == self.object:\n+                        continue\n+                    if name in base.__dict__:\n+                        return True\n+                    if name in self.get_attr(base, '__annotations__', {}):\n                         return True\n-                    elif name in cls.__dict__:\n-                        return False\n-                    elif name in self.get_attr(cls, '__annotations__', {}):\n-                        return False\n             return False\n         ret = []\n-        namespace = '.'.join(self.objpath)\n-        if self.analyzer:\n-            attr_docs = self.analyzer.find_attr_docs()\n-        else:\n-            attr_docs = {}\n+        namespaces = ['.'.join(self.objpath)]\n+        if self.options.inherited_members and inspect.isclass(self.object):\n+            for base in self.object.__bases__:\n+                base_path = getattr(base, '__module__', None)\n+                if base_path:\n+                    namespaces.append(base_path + '.' + base.__name__)\n+        attr_docs = {}\n+        for namespace in namespaces:\n+            if self.analyzer:\n+                attr_docs.update(self.analyzer.find_attr_docs(namespace))\n         for obj in members:\n             membername, member = obj\n             if member is INSTANCEATTR:\n", "normalized_occurrence": 1}
