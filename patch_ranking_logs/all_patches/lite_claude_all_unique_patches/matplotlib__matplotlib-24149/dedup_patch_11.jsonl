{"model_name_or_path": "agentless_claude", "instance_id": "matplotlib__matplotlib-24149", "model_patch": "diff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 63a9e60..a6f77c0 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -1715,6 +1715,10 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n     This is an type-independent way of obtaining the first non-None element,\n     supporting both index access and the iterator protocol.\n     The first non-None element will be obtained when skip_none is True.\n+\n+    When skip_nonfinite is False, returns the first element regardless of whether\n+    it is finite or not. When skip_nonfinite is True, returns the first finite\n+    value, raising StopIteration if no finite values are found.\n     \"\"\"\n     def safe_isfinite(val):\n         if val is None:\n@@ -1725,26 +1729,22 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n             # This is something that numpy can not make heads or tails\n             # of, assume \"finite\"\n             return True\n+\n+    if isinstance(obj, collections.abc.Iterator) and not isinstance(obj, np.flatiter):\n+        # needed to accept `array.flat` as input.\n+        # np.flatiter reports as an instance of collections.Iterator\n+        # but can still be indexed via [].\n+        try:\n+            return obj[0]\n+        except TypeError:\n+            raise RuntimeError(\"matplotlib does not support generators as input\")\n+\n     if skip_nonfinite is False:\n-        if isinstance(obj, collections.abc.Iterator):\n-            # needed to accept `array.flat` as input.\n-            # np.flatiter reports as an instance of collections.Iterator\n-            # but can still be indexed via [].\n-            # This has the side effect of re-setting the iterator, but\n-            # that is acceptable.\n-            try:\n-                return obj[0]\n-            except TypeError:\n-                pass\n-            raise RuntimeError(\"matplotlib does not support generators \"\n-                               \"as input\")\n+        # When not skipping non-finite values, just return the first element\n         return next(iter(obj))\n     elif isinstance(obj, np.flatiter):\n         # TODO do the finite filtering on this\n         return obj[0]\n-    elif isinstance(obj, collections.abc.Iterator):\n-        raise RuntimeError(\"matplotlib does not \"\n-                           \"support generators as input\")\n     else:\n         return next(val for val in obj if safe_isfinite(val))\n \n", "occurrence": 1, "normalized_patch": "diff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex d655165..9a90917 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -737,18 +737,15 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n             return np.isfinite(val) if np.isscalar(val) else True\n         except TypeError:\n             return True\n-    if skip_nonfinite is False:\n-        if isinstance(obj, collections.abc.Iterator):\n-            try:\n-                return obj[0]\n-            except TypeError:\n-                pass\n+    if isinstance(obj, collections.abc.Iterator) and (not isinstance(obj, np.flatiter)):\n+        try:\n+            return obj[0]\n+        except TypeError:\n             raise RuntimeError('matplotlib does not support generators as input')\n+    if skip_nonfinite is False:\n         return next(iter(obj))\n     elif isinstance(obj, np.flatiter):\n         return obj[0]\n-    elif isinstance(obj, collections.abc.Iterator):\n-        raise RuntimeError('matplotlib does not support generators as input')\n     else:\n         return next((val for val in obj if safe_isfinite(val)))\n def sanitize_sequence(data):\n", "normalized_occurrence": 1}
