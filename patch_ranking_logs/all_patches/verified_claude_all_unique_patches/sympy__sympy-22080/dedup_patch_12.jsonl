{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-22080", "model_patch": "diff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex ca33049..35cf2a4 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.numbers import nan\n from .function import Function\n from .kind import NumberKind\n@@ -36,6 +37,11 @@ class Mod(Function):\n \n     @classmethod\n     def eval(cls, p, q):\n+        # Handle negative coefficients properly\n+        if p.could_extract_minus_sign():\n+            if q.could_extract_minus_sign():\n+                return cls(-p, -q)\n+            return -cls(-p, q)\n         from sympy.core.add import Add\n         from sympy.core.mul import Mul\n         from sympy.core.singleton import S\n@@ -240,4 +246,23 @@ class Mod(Function):\n \n     def _eval_rewrite_as_floor(self, a, b, **kwargs):\n         from sympy.functions.elementary.integers import floor\n-        return a - b*floor(a/b)\n+        return a - b*floor(a/b)\n+        \n+    def as_coeff_Mod(self):\n+        \"\"\"Separate the expression as a tuple (coeff, Mod).\n+        \n+        This is used to ensure proper handling when the Mod is\n+        part of a multiplication or negation.\n+        \"\"\"\n+        if self.args[0].is_Mul:\n+            nonmod_terms = []\n+            mod_terms = []\n+            for arg in self.args[0].args:\n+                if isinstance(arg, type(self)):\n+                    mod_terms.append(arg)\n+                else:\n+                    nonmod_terms.append(arg)\n+            if mod_terms:\n+                return (self.args[0].func(*nonmod_terms), \n+                       self.func(self.args[0].func(*mod_terms), self.args[1]))\n+        return (S.One, self)\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex 57d2396..0d53889 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -5,6 +5,10 @@ class Mod(Function):\n     kind = NumberKind\n     @classmethod\n     def eval(cls, p, q):\n+        if p.could_extract_minus_sign():\n+            if q.could_extract_minus_sign():\n+                return cls(-p, -q)\n+            return -cls(-p, q)\n         from sympy.core.add import Add\n         from sympy.core.mul import Mul\n         from sympy.core.singleton import S\n@@ -162,4 +166,16 @@ class Mod(Function):\n             return True\n     def _eval_rewrite_as_floor(self, a, b, **kwargs):\n         from sympy.functions.elementary.integers import floor\n-        return a - b * floor(a / b)\n\\ No newline at end of file\n+        return a - b * floor(a / b)\n+    def as_coeff_Mod(self):\n+        if self.args[0].is_Mul:\n+            nonmod_terms = []\n+            mod_terms = []\n+            for arg in self.args[0].args:\n+                if isinstance(arg, type(self)):\n+                    mod_terms.append(arg)\n+                else:\n+                    nonmod_terms.append(arg)\n+            if mod_terms:\n+                return (self.args[0].func(*nonmod_terms), self.func(self.args[0].func(*mod_terms), self.args[1]))\n+        return (S.One, self)\n\\ No newline at end of file\n", "normalized_occurrence": 1}
