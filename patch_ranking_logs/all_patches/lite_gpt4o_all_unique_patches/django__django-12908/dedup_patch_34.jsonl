{"model_name_or_path": "agentless", "instance_id": "django__django-12908", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex a26bee7..a1fd799 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -438,7 +438,7 @@ class SQLCompiler:\n                     raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')\n                 if compiler.get_order_by():\n                     raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')\n-        parts = ()\n+        parts = []\n         for compiler in compilers:\n             try:\n                 # If the columns list is limited, then all combined queries\n@@ -479,6 +479,10 @@ class SQLCompiler:\n         params = []\n         for part in args_parts:\n             params.extend(part)\n+        if self.query.combinator and self.query.distinct_fields:\n+            distinct_fields = self.get_distinct()\n+            result.insert(0, 'DISTINCT ON (%s)' % ', '.join(distinct_fields[0]))\n+            params = distinct_fields[1] + params\n         return result, params\n \n     def as_sql(self, with_limits=True, with_col_aliases=False):\n@@ -699,6 +703,10 @@ class SQLCompiler:\n                     r, p = self.compile(transform_function(target, alias))\n                     result.append(r)\n                     params.append(p)\n+        if self.query.combinator and self.query.distinct_fields:\n+            distinct_fields = self.get_distinct()\n+            result.insert(0, 'DISTINCT ON (%s)' % ', '.join(distinct_fields[0]))\n+            params = distinct_fields[1] + params\n         return result, params\n \n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex e6a07a3..473125a 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -243,7 +243,7 @@ class SQLCompiler:\n                     raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')\n                 if compiler.get_order_by():\n                     raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')\n-        parts = ()\n+        parts = []\n         for compiler in compilers:\n             try:\n                 if not compiler.query.values_select and self.query.values_select:\n@@ -271,6 +271,10 @@ class SQLCompiler:\n         params = []\n         for part in args_parts:\n             params.extend(part)\n+        if self.query.combinator and self.query.distinct_fields:\n+            distinct_fields = self.get_distinct()\n+            result.insert(0, 'DISTINCT ON (%s)' % ', '.join(distinct_fields[0]))\n+            params = distinct_fields[1] + params\n         return (result, params)\n     def as_sql(self, with_limits=True, with_col_aliases=False):\n         refcounts_before = self.query.alias_refcount.copy()\n@@ -404,6 +408,10 @@ class SQLCompiler:\n                     r, p = self.compile(transform_function(target, alias))\n                     result.append(r)\n                     params.append(p)\n+        if self.query.combinator and self.query.distinct_fields:\n+            distinct_fields = self.get_distinct()\n+            result.insert(0, 'DISTINCT ON (%s)' % ', '.join(distinct_fields[0]))\n+            params = distinct_fields[1] + params\n         return (result, params)\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC', already_seen=None):\n         name, order = get_order_dir(name, default_order)\n", "normalized_occurrence": 1}
