{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-5103", "model_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 4810cdd..e80b1d6 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -841,7 +841,11 @@ class AssertionRewriter(ast.NodeVisitor):\n         self.push_format_context()\n         # Rewrite assert into a bunch of statements.\n         top_condition, explanation = self.visit(assert_.test)\n-        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n+        # Special handling for all() and any() calls\n+        if isinstance(assert_.test, ast.Call) and isinstance(assert_.test.func, ast.Name):\n+            if assert_.test.func.id in ('all', 'any'):\n+                self._rewrite_all_any(assert_)\n+                return self.statements\n         if self.module_path is not None:\n             self.statements.append(\n                 self.warn_about_none_ast(\n@@ -905,7 +909,41 @@ warn_explicit(\n         ).body\n         return ast.If(val_is_none, send_warning, [])\n \n-    def visit_Name(self, name):\n+    def _rewrite_all_any(self, assert_):\n+        \"\"\"Special handling for all() and any() calls to provide detailed failure messages.\"\"\"\n+        func_name = assert_.test.func.id\n+        is_all = func_name == 'all'\n+        iterable = assert_.test.args[0]\n+\n+        # Create a variable to store the result of the iterable\n+        iter_var = self.variable()\n+        self.statements.append(ast.Assign([ast.Name(iter_var, ast.Store())], iterable))\n+\n+        # Create a for loop to iterate over the elements\n+        loop_var = self.variable()\n+        loop = ast.For(\n+            target=ast.Name(loop_var, ast.Store()),\n+            iter=ast.Name(iter_var, ast.Load()),\n+            body=[],\n+            orelse=[]\n+        )\n+\n+        # Create the condition to check each element\n+        condition = ast.Call(\n+            func=assert_.test.args[0].elt.func,\n+            args=[ast.Name(loop_var, ast.Load())],\n+            keywords=[]\n+        )\n+        if not is_all:\n+            condition = ast.UnaryOp(op=ast.Not(), operand=condition)\n+\n+        # Create the assert statement inside the loop\n+        loop.body.append(ast.Assert(\n+            test=condition,\n+            msg=ast.Str(s=f\"Failed element in {func_name}() call: {{}}\".format(loop_var))\n+        ))\n+\n+        self.statements.append(loop)\n         # Display the repr of the name if it's a local variable or\n         # _should_repr_global_name() thinks it's acceptable.\n         locs = ast_Call(self.builtin(\"locals\"), [], [])\n@@ -1081,4 +1119,4 @@ warn_explicit(\n             res = ast.BoolOp(ast.And(), load_names)\n         else:\n             res = load_names[0]\n-        return res, self.explanation_param(self.pop_format_context(expl_call))\n+        return res, self.explanation_param(self.pop_format_context(expl_call))\n", "occurrence": 1, "normalized_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2ada5b2..7b6e263 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -459,6 +459,10 @@ class AssertionRewriter(ast.NodeVisitor):\n         self.on_failure = []\n         self.push_format_context()\n         top_condition, explanation = self.visit(assert_.test)\n+        if isinstance(assert_.test, ast.Call) and isinstance(assert_.test.func, ast.Name):\n+            if assert_.test.func.id in ('all', 'any'):\n+                self._rewrite_all_any(assert_)\n+                return self.statements\n         if self.module_path is not None:\n             self.statements.append(self.warn_about_none_ast(top_condition, module_path=self.module_path, lineno=assert_.lineno))\n         body = self.on_failure\n@@ -492,7 +496,19 @@ class AssertionRewriter(ast.NodeVisitor):\n         val_is_none = ast.Compare(node, [ast.Is()], [AST_NONE])\n         send_warning = ast.parse('\\nfrom _pytest.warning_types import PytestAssertRewriteWarning\\nfrom warnings import warn_explicit\\nwarn_explicit(\\n    PytestAssertRewriteWarning(\\'asserting the value None, please use \"assert is None\"\\'),\\n    category=None,\\n    filename={filename!r},\\n    lineno={lineno},\\n)\\n            '.format(filename=module_path.strpath, lineno=lineno)).body\n         return ast.If(val_is_none, send_warning, [])\n-    def visit_Name(self, name):\n+    def _rewrite_all_any(self, assert_):\n+        func_name = assert_.test.func.id\n+        is_all = func_name == 'all'\n+        iterable = assert_.test.args[0]\n+        iter_var = self.variable()\n+        self.statements.append(ast.Assign([ast.Name(iter_var, ast.Store())], iterable))\n+        loop_var = self.variable()\n+        loop = ast.For(target=ast.Name(loop_var, ast.Store()), iter=ast.Name(iter_var, ast.Load()), body=[], orelse=[])\n+        condition = ast.Call(func=assert_.test.args[0].elt.func, args=[ast.Name(loop_var, ast.Load())], keywords=[])\n+        if not is_all:\n+            condition = ast.UnaryOp(op=ast.Not(), operand=condition)\n+        loop.body.append(ast.Assert(test=condition, msg=ast.Str(s=f'Failed element in {func_name}() call: {{}}'.format(loop_var))))\n+        self.statements.append(loop)\n         locs = ast_Call(self.builtin('locals'), [], [])\n         inlocs = ast.Compare(ast.Str(name.id), [ast.In()], [locs])\n         dorepr = self.helper('_should_repr_global_name', name)\n", "normalized_occurrence": 1}
