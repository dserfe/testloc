{"model_name_or_path": "agentless_claude", "instance_id": "astropy__astropy-13398", "model_patch": "diff --git a/astropy/coordinates/builtin_frames/icrs_observed_transforms.py b/astropy/coordinates/builtin_frames/icrs_observed_transforms.py\nindex a2d1d97..8d92653 100644\n--- a/astropy/coordinates/builtin_frames/icrs_observed_transforms.py\n+++ b/astropy/coordinates/builtin_frames/icrs_observed_transforms.py\n@@ -60,6 +60,52 @@ def observed_to_icrs(observed_coo, icrs_frame):\n     is_unitspherical = (isinstance(observed_coo.data, UnitSphericalRepresentation) or\n                         observed_coo.cartesian.x.unit == u.one)\n \n+def itrs_to_observed_mat(observed_frame):\n+    lon, lat, height = observed_frame.location.to_geodetic('WGS84')\n+    elong = lon.to_value(u.radian)\n+\n+    if isinstance(observed_frame, AltAz):\n+        # form ITRS to AltAz matrix\n+        elat = lat.to_value(u.radian)\n+        # AltAz frame is left handed\n+        minus_x = np.eye(3)\n+        minus_x[0][0] = -1.0\n+        mat = (minus_x\n+               @ rotation_matrix(PIOVER2 - elat, 'y', unit=u.radian)\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+    else:\n+        # form ITRS to HADec matrix\n+        # HADec frame is left handed\n+        minus_y = np.eye(3)\n+        minus_y[1][1] = -1.0\n+        mat = (minus_y\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+    return mat\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, AltAz)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, HADec)\n+def itrs_to_observed(itrs_coo, observed_frame):\n+    # Trying to synchronize the obstimes here makes no sense. In fact,\n+    # it's a real gotcha as doing an ITRS->ITRS transform references \n+    # ITRS coordinates, which should be tied to the Earth, to the SSB.\n+    # Instead, we treat ITRS coordinates as time invariant here.\n+\n+    # form the Topocentric ITRS position\n+    topocentric_itrs_repr = (itrs_coo.cartesian\n+                             - observed_frame.location.get_itrs().cartesian)\n+    rep = topocentric_itrs_repr.transform(itrs_to_observed_mat(observed_frame))\n+    return observed_frame.realize_frame(rep)\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, AltAz, ITRS)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, HADec, ITRS)\n+def observed_to_itrs(observed_coo, itrs_frame):\n+    # form the Topocentric ITRS position\n+    topocentric_itrs_repr = observed_coo.cartesian.transform(matrix_transpose(\n+                            itrs_to_observed_mat(observed_coo)))\n+    # form the Geocentric ITRS position\n+    rep = topocentric_itrs_repr + observed_coo.location.get_itrs().cartesian\n+    return itrs_frame.realize_frame(rep)\n+\n     usrepr = observed_coo.represent_as(UnitSphericalRepresentation)\n     lon = usrepr.lon.to_value(u.radian)\n     lat = usrepr.lat.to_value(u.radian)\n@@ -98,12 +144,5 @@ def observed_to_icrs(observed_coo, icrs_frame):\n     return icrs_frame.realize_frame(icrs_srepr)\n \n \n-# Create loopback transformations\n-frame_transform_graph._add_merged_transform(AltAz, ICRS, AltAz)\n-frame_transform_graph._add_merged_transform(HADec, ICRS, HADec)\n-# for now we just implement this through ICRS to make sure we get everything\n-# covered\n-# Before, this was using CIRS as intermediate frame, however this is much\n-# slower than the direct observed<->ICRS transform added in 4.3\n-# due to how the frame attribute broadcasting works, see\n+\n # https://github.com/astropy/astropy/pull/10994#issuecomment-722617041\n", "occurrence": 1, "normalized_patch": "diff --git a/astropy/coordinates/builtin_frames/icrs_observed_transforms.py b/astropy/coordinates/builtin_frames/icrs_observed_transforms.py\nindex bdbec4d..90fc2bf 100644\n--- a/astropy/coordinates/builtin_frames/icrs_observed_transforms.py\n+++ b/astropy/coordinates/builtin_frames/icrs_observed_transforms.py\n@@ -34,6 +34,31 @@ def icrs_to_observed(icrs_coo, observed_frame):\n @frame_transform_graph.transform(FunctionTransformWithFiniteDifference, HADec, ICRS)\n def observed_to_icrs(observed_coo, icrs_frame):\n     is_unitspherical = isinstance(observed_coo.data, UnitSphericalRepresentation) or observed_coo.cartesian.x.unit == u.one\n+def itrs_to_observed_mat(observed_frame):\n+    lon, lat, height = observed_frame.location.to_geodetic('WGS84')\n+    elong = lon.to_value(u.radian)\n+    if isinstance(observed_frame, AltAz):\n+        elat = lat.to_value(u.radian)\n+        minus_x = np.eye(3)\n+        minus_x[0][0] = -1.0\n+        mat = minus_x @ rotation_matrix(PIOVER2 - elat, 'y', unit=u.radian) @ rotation_matrix(elong, 'z', unit=u.radian)\n+    else:\n+        minus_y = np.eye(3)\n+        minus_y[1][1] = -1.0\n+        mat = minus_y @ rotation_matrix(elong, 'z', unit=u.radian)\n+    return mat\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, AltAz)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, HADec)\n+def itrs_to_observed(itrs_coo, observed_frame):\n+    topocentric_itrs_repr = itrs_coo.cartesian - observed_frame.location.get_itrs().cartesian\n+    rep = topocentric_itrs_repr.transform(itrs_to_observed_mat(observed_frame))\n+    return observed_frame.realize_frame(rep)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, AltAz, ITRS)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, HADec, ITRS)\n+def observed_to_itrs(observed_coo, itrs_frame):\n+    topocentric_itrs_repr = observed_coo.cartesian.transform(matrix_transpose(itrs_to_observed_mat(observed_coo)))\n+    rep = topocentric_itrs_repr + observed_coo.location.get_itrs().cartesian\n+    return itrs_frame.realize_frame(rep)\n     usrepr = observed_coo.represent_as(UnitSphericalRepresentation)\n     lon = usrepr.lon.to_value(u.radian)\n     lat = usrepr.lat.to_value(u.radian)\n@@ -56,6 +81,4 @@ def observed_to_icrs(observed_coo, icrs_frame):\n         observer_icrs = CartesianRepresentation(astrom['eb'], unit=u.au, xyz_axis=-1, copy=False)\n         newrepr = icrs_srepr.to_cartesian() + observer_icrs\n         icrs_srepr = newrepr.represent_as(SphericalRepresentation)\n-    return icrs_frame.realize_frame(icrs_srepr)\n-frame_transform_graph._add_merged_transform(AltAz, ICRS, AltAz)\n-frame_transform_graph._add_merged_transform(HADec, ICRS, HADec)\n\\ No newline at end of file\n+    return icrs_frame.realize_frame(icrs_srepr)\n\\ No newline at end of file\n", "normalized_occurrence": 1}
