{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-11897", "model_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 6f6ac51..b43de84 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -346,96 +346,17 @@ class LatexPrinter(Printer):\n             return str_real\n \n     def _print_Mul(self, expr):\n-        include_parens = False\n-        if _coeff_isneg(expr):\n-            expr = -expr\n-            tex = \"- \"\n-            if expr.is_Add:\n-                tex += \"(\"\n-                include_parens = True\n-        else:\n-            tex = \"\"\n-\n         from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n-        separator = self._settings['mul_symbol_latex']\n-        numbersep = self._settings['mul_symbol_latex_numbers']\n-\n-        def convert(expr):\n-            if not expr.is_Mul:\n-                return str(self._print(expr))\n-            else:\n-                _tex = last_term_tex = \"\"\n-\n-                if self.order not in ('old', 'none'):\n-                    args = expr.as_ordered_factors()\n-                else:\n-                    args = expr.args\n-\n-                for i, term in enumerate(args):\n-                    term_tex = self._print(term)\n \n-                    if self._needs_mul_brackets(term, first=(i == 0),\n-                                                last=(i == len(args) - 1)):\n-                        term_tex = r\"\\left(%s\\right)\" % term_tex\n-\n-                    if _between_two_numbers_p[0].search(last_term_tex) and \\\n-                            _between_two_numbers_p[1].match(term_tex):\n-                        # between two numbers\n-                        _tex += numbersep\n-                    elif _tex:\n-                        _tex += separator\n-\n-                    _tex += term_tex\n-                    last_term_tex = term_tex\n-                return _tex\n+        numer, denom = fraction(expr)\n \n         if denom is S.One:\n-            # use the original expression here, since fraction() may have\n-            # altered it when producing numer and denom\n-            tex += convert(expr)\n-        else:\n-            snumer = convert(numer)\n-            sdenom = convert(denom)\n-            ldenom = len(sdenom.split())\n-            ratio = self._settings['long_frac_ratio']\n-            if self._settings['fold_short_frac'] \\\n-                    and ldenom <= 2 and not \"^\" in sdenom:\n-                # handle short fractions\n-                if self._needs_mul_brackets(numer, last=False):\n-                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n-                else:\n-                    tex += r\"%s / %s\" % (snumer, sdenom)\n-            elif len(snumer.split()) > ratio*ldenom:\n-                # handle long fractions\n-                if self._needs_mul_brackets(numer, last=True):\n-                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n-                        % (sdenom, separator, snumer)\n-                elif numer.is_Mul:\n-                    # split a long numerator\n-                    a = S.One\n-                    b = S.One\n-                    for x in numer.args:\n-                        if self._needs_mul_brackets(x, last=False) or \\\n-                                len(convert(a*x).split()) > ratio*ldenom or \\\n-                                (b.is_commutative is x.is_commutative is False):\n-                            b *= x\n-                        else:\n-                            a *= x\n-                    if self._needs_mul_brackets(b, last=True):\n-                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n-                            % (convert(a), sdenom, separator, convert(b))\n-                    else:\n-                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n-                            % (convert(a), sdenom, separator, convert(b))\n-                else:\n-                    tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n-            else:\n-                tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n+            return self._print(numer)\n \n-        if include_parens:\n-            tex += \")\"\n-        return tex\n+        snumer = self._print(numer)\n+        sdenom = self._print(denom)\n+\n+        return r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n \n     def _print_Pow(self, expr):\n         # Treat x**Rational(1,n) as special case\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex df1a5c2..7eb7b20 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -156,73 +156,13 @@ class LatexPrinter(Printer):\n         else:\n             return str_real\n     def _print_Mul(self, expr):\n-        include_parens = False\n-        if _coeff_isneg(expr):\n-            expr = -expr\n-            tex = '- '\n-            if expr.is_Add:\n-                tex += '('\n-                include_parens = True\n-        else:\n-            tex = ''\n         from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n-        separator = self._settings['mul_symbol_latex']\n-        numbersep = self._settings['mul_symbol_latex_numbers']\n-        def convert(expr):\n-            if not expr.is_Mul:\n-                return str(self._print(expr))\n-            else:\n-                _tex = last_term_tex = ''\n-                if self.order not in ('old', 'none'):\n-                    args = expr.as_ordered_factors()\n-                else:\n-                    args = expr.args\n-                for i, term in enumerate(args):\n-                    term_tex = self._print(term)\n-                    if self._needs_mul_brackets(term, first=i == 0, last=i == len(args) - 1):\n-                        term_tex = '\\\\left(%s\\\\right)' % term_tex\n-                    if _between_two_numbers_p[0].search(last_term_tex) and _between_two_numbers_p[1].match(term_tex):\n-                        _tex += numbersep\n-                    elif _tex:\n-                        _tex += separator\n-                    _tex += term_tex\n-                    last_term_tex = term_tex\n-                return _tex\n+        numer, denom = fraction(expr)\n         if denom is S.One:\n-            tex += convert(expr)\n-        else:\n-            snumer = convert(numer)\n-            sdenom = convert(denom)\n-            ldenom = len(sdenom.split())\n-            ratio = self._settings['long_frac_ratio']\n-            if self._settings['fold_short_frac'] and ldenom <= 2 and (not '^' in sdenom):\n-                if self._needs_mul_brackets(numer, last=False):\n-                    tex += '\\\\left(%s\\\\right) / %s' % (snumer, sdenom)\n-                else:\n-                    tex += '%s / %s' % (snumer, sdenom)\n-            elif len(snumer.split()) > ratio * ldenom:\n-                if self._needs_mul_brackets(numer, last=True):\n-                    tex += '\\\\frac{1}{%s}%s\\\\left(%s\\\\right)' % (sdenom, separator, snumer)\n-                elif numer.is_Mul:\n-                    a = S.One\n-                    b = S.One\n-                    for x in numer.args:\n-                        if self._needs_mul_brackets(x, last=False) or len(convert(a * x).split()) > ratio * ldenom or b.is_commutative is x.is_commutative is False:\n-                            b *= x\n-                        else:\n-                            a *= x\n-                    if self._needs_mul_brackets(b, last=True):\n-                        tex += '\\\\frac{%s}{%s}%s\\\\left(%s\\\\right)' % (convert(a), sdenom, separator, convert(b))\n-                    else:\n-                        tex += '\\\\frac{%s}{%s}%s%s' % (convert(a), sdenom, separator, convert(b))\n-                else:\n-                    tex += '\\\\frac{1}{%s}%s%s' % (sdenom, separator, snumer)\n-            else:\n-                tex += '\\\\frac{%s}{%s}' % (snumer, sdenom)\n-        if include_parens:\n-            tex += ')'\n-        return tex\n+            return self._print(numer)\n+        snumer = self._print(numer)\n+        sdenom = self._print(denom)\n+        return '\\\\frac{%s}{%s}' % (snumer, sdenom)\n     def _print_Pow(self, expr):\n         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and (expr.exp.q != 1):\n             base = self._print(expr.base)\n", "normalized_occurrence": 1}
