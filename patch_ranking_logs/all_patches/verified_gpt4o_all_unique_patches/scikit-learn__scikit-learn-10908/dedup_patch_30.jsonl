{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-10908", "model_patch": "diff --git a/sklearn/feature_extraction/text.py b/sklearn/feature_extraction/text.py\nindex 7e240fc..cde94ea 100644\n--- a/sklearn/feature_extraction/text.py\n+++ b/sklearn/feature_extraction/text.py\n@@ -736,6 +736,8 @@ class CountVectorizer(BaseEstimator, VectorizerMixin):\n                     % max_features)\n         self.ngram_range = ngram_range\n         self.vocabulary = vocabulary\n+        if vocabulary is not None:\n+            self.vocabulary_ = vocabulary\n         self.binary = binary\n         self.dtype = dtype\n \n@@ -953,7 +955,8 @@ class CountVectorizer(BaseEstimator, VectorizerMixin):\n         if not hasattr(self, 'vocabulary_'):\n             self._validate_vocabulary()\n \n-        self._check_vocabulary()\n+        if not hasattr(self, 'vocabulary_'):\n+            self._validate_vocabulary()\n \n         # use the same matrix-building strategy as fit_transform\n         _, X = self._count_vocab(raw_documents, fixed_vocab=True)\n@@ -973,7 +976,8 @@ class CountVectorizer(BaseEstimator, VectorizerMixin):\n         X_inv : list of arrays, len = n_samples\n             List of arrays of terms.\n         \"\"\"\n-        self._check_vocabulary()\n+        if not hasattr(self, 'vocabulary_'):\n+            self._validate_vocabulary()\n \n         if sp.issparse(X):\n             # We need CSR format for fast row manipulations.\n@@ -993,7 +997,8 @@ class CountVectorizer(BaseEstimator, VectorizerMixin):\n \n     def get_feature_names(self):\n         \"\"\"Array mapping from feature integer indices to feature name\"\"\"\n-        self._check_vocabulary()\n+        if not hasattr(self, 'vocabulary_'):\n+            self._validate_vocabulary()\n \n         return [t for t, i in sorted(six.iteritems(self.vocabulary_),\n                                      key=itemgetter(1))]\n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/feature_extraction/text.py b/sklearn/feature_extraction/text.py\nindex 583049b..e2e12a5 100644\n--- a/sklearn/feature_extraction/text.py\n+++ b/sklearn/feature_extraction/text.py\n@@ -239,6 +239,8 @@ class CountVectorizer(BaseEstimator, VectorizerMixin):\n                 raise ValueError('max_features=%r, neither a positive integer nor None' % max_features)\n         self.ngram_range = ngram_range\n         self.vocabulary = vocabulary\n+        if vocabulary is not None:\n+            self.vocabulary_ = vocabulary\n         self.binary = binary\n         self.dtype = dtype\n     def _sort_features(self, X, vocabulary):\n@@ -347,13 +349,15 @@ class CountVectorizer(BaseEstimator, VectorizerMixin):\n             raise ValueError('Iterable over raw text documents expected, string object received.')\n         if not hasattr(self, 'vocabulary_'):\n             self._validate_vocabulary()\n-        self._check_vocabulary()\n+        if not hasattr(self, 'vocabulary_'):\n+            self._validate_vocabulary()\n         _, X = self._count_vocab(raw_documents, fixed_vocab=True)\n         if self.binary:\n             X.data.fill(1)\n         return X\n     def inverse_transform(self, X):\n-        self._check_vocabulary()\n+        if not hasattr(self, 'vocabulary_'):\n+            self._validate_vocabulary()\n         if sp.issparse(X):\n             X = X.tocsr()\n         else:\n@@ -364,7 +368,8 @@ class CountVectorizer(BaseEstimator, VectorizerMixin):\n         inverse_vocabulary = terms[np.argsort(indices)]\n         return [inverse_vocabulary[X[i, :].nonzero()[1]].ravel() for i in range(n_samples)]\n     def get_feature_names(self):\n-        self._check_vocabulary()\n+        if not hasattr(self, 'vocabulary_'):\n+            self._validate_vocabulary()\n         return [t for t, i in sorted(six.iteritems(self.vocabulary_), key=itemgetter(1))]\n def _make_int_array():\n     return array.array(str('i'))\n", "normalized_occurrence": 1}
