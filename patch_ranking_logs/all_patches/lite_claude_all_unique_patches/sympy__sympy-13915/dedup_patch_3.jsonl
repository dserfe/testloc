{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13915", "model_patch": "diff --git a/sympy/core/basic.py b/sympy/core/basic.py\nindex 0977e81..446b7d3 100644\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -995,6 +995,54 @@ class Basic(with_metaclass(ManagedProperties)):\n         \"\"\"\n \n         def fallback(self, old, new):\n+            \"\"\"\n+            Try to replace old with new in any of self's arguments.\n+            \"\"\"\n+            from sympy.core.numbers import Nan\n+            \n+            # First try substitution in arguments\n+            hit = False\n+            args = list(self.args)\n+            for i, arg in enumerate(args):\n+                if not hasattr(arg, '_eval_subs'):\n+                    continue\n+                arg = arg._subs(old, new, **hints)\n+                if not _aresame(arg, args[i]):\n+                    hit = True\n+                    args[i] = arg\n+            \n+            if hit:\n+                # Create new expression with substituted arguments\n+                rv = self.func(*args)\n+                \n+                # Check for undefined expressions (0/0 form)\n+                if self.is_Add or self.is_Mul:\n+                    try:\n+                        # Try evaluation - will raise ZeroDivisionError for 0/0\n+                        evaluated = rv.doit()\n+                        if evaluated.has(Nan):\n+                            from sympy.core.numbers import nan\n+                            return nan\n+                    except ZeroDivisionError:\n+                        from sympy.core.numbers import nan\n+                        return nan\n+                \n+                hack2 = hints.get('hack2', False)\n+                if hack2 and self.is_Mul and not rv.is_Mul:  # 2-arg hack\n+                    coeff = S.One\n+                    nonnumber = []\n+                    for i in args:\n+                        if i.is_Number:\n+                            coeff *= i\n+                        else:\n+                            nonnumber.append(i)\n+                    nonnumber = self.func(*nonnumber)\n+                    if coeff is S.One:\n+                        return nonnumber\n+                    else:\n+                        return self.func(coeff, nonnumber, evaluate=False)\n+                return rv\n+            return self\n             \"\"\"\n             Try to replace old with new in any of self's arguments.\n             \"\"\"\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/basic.py b/sympy/core/basic.py\nindex 782db85..b4b35c0 100644\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -333,6 +333,43 @@ class Basic(with_metaclass(ManagedProperties)):\n     @cacheit\n     def _subs(self, old, new, **hints):\n         def fallback(self, old, new):\n+            from sympy.core.numbers import Nan\n+            hit = False\n+            args = list(self.args)\n+            for i, arg in enumerate(args):\n+                if not hasattr(arg, '_eval_subs'):\n+                    continue\n+                arg = arg._subs(old, new, **hints)\n+                if not _aresame(arg, args[i]):\n+                    hit = True\n+                    args[i] = arg\n+            if hit:\n+                rv = self.func(*args)\n+                if self.is_Add or self.is_Mul:\n+                    try:\n+                        evaluated = rv.doit()\n+                        if evaluated.has(Nan):\n+                            from sympy.core.numbers import nan\n+                            return nan\n+                    except ZeroDivisionError:\n+                        from sympy.core.numbers import nan\n+                        return nan\n+                hack2 = hints.get('hack2', False)\n+                if hack2 and self.is_Mul and (not rv.is_Mul):\n+                    coeff = S.One\n+                    nonnumber = []\n+                    for i in args:\n+                        if i.is_Number:\n+                            coeff *= i\n+                        else:\n+                            nonnumber.append(i)\n+                    nonnumber = self.func(*nonnumber)\n+                    if coeff is S.One:\n+                        return nonnumber\n+                    else:\n+                        return self.func(coeff, nonnumber, evaluate=False)\n+                return rv\n+            return self\n             hit = False\n             args = list(self.args)\n             for i, arg in enumerate(args):\n", "normalized_occurrence": 1}
