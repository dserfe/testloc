{"model_name_or_path": "agentless_claude", "instance_id": "sphinx-doc__sphinx-7748", "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 5ead82c..ca6c64a 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1037,39 +1037,7 @@ class DocstringSignatureMixin:\n     feature of reading the signature from the docstring.\n     \"\"\"\n \n-    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n-        if encoding is not None:\n-            warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n-                          \"deprecated.\" % self.__class__.__name__,\n-                          RemovedInSphinx40Warning, stacklevel=2)\n-        docstrings = self.get_doc()\n-        self._new_docstrings = docstrings[:]\n-        result = None\n-        for i, doclines in enumerate(docstrings):\n-            # no lines in docstring, no match\n-            if not doclines:\n-                continue\n-            # match first line of docstring against signature RE\n-            match = py_ext_sig_re.match(doclines[0])\n-            if not match:\n-                continue\n-            exmod, path, base, args, retann = match.groups()\n-            # the base name must match ours\n-            valid_names = [self.objpath[-1]]  # type: ignore\n-            if isinstance(self, ClassDocumenter):\n-                valid_names.append('__init__')\n-                if hasattr(self.object, '__mro__'):\n-                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n-            if base not in valid_names:\n-                continue\n-            # re-prepare docstring to ignore more leading indentation\n-            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n-            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n-                                                        tabsize=tab_width)\n-            result = args, retann\n-            # don't look any further\n-            break\n-        return result\n+\n \n     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n         if encoding is not None:\n@@ -1081,13 +1049,71 @@ class DocstringSignatureMixin:\n             return lines\n         return super().get_doc(None, ignore)  # type: ignore\n \n+    def _find_signature(self, encoding: str = None) -> List[Tuple[str, str]]:\n+        if encoding is not None:\n+            warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                          \"deprecated.\" % self.__class__.__name__,\n+                          RemovedInSphinx40Warning, stacklevel=2)\n+        docstrings = self.get_doc()\n+        self._new_docstrings = docstrings[:]\n+        results = []\n+        last_processed_i = -1\n+        \n+        for i, doclines in enumerate(docstrings):\n+            # Skip already processed sections\n+            if i <= last_processed_i:\n+                continue\n+                \n+            # no lines in docstring, no match\n+            if not doclines:\n+                continue\n+                \n+            # Try to match consecutive lines as signatures\n+            current_i = i\n+            while current_i < len(docstrings) and doclines:\n+                match = py_ext_sig_re.match(doclines[0])\n+                if not match:\n+                    break\n+                    \n+                exmod, path, base, args, retann = match.groups()\n+                # the base name must match ours\n+                valid_names = [self.objpath[-1]]  # type: ignore\n+                if isinstance(self, ClassDocumenter):\n+                    valid_names.append('__init__')\n+                    if hasattr(self.object, '__mro__'):\n+                        valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+                if base not in valid_names:\n+                    break\n+                    \n+                results.append((args, retann))\n+                current_i += 1\n+                if current_i < len(docstrings):\n+                    doclines = docstrings[current_i]\n+                \n+            if results:  # If we found signatures, process the rest of the docstring\n+                # re-prepare docstring to ignore more leading indentation\n+                tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n+                remaining_lines = []\n+                for j in range(current_i, len(docstrings)):\n+                    remaining_lines.extend(docstrings[j])\n+                self._new_docstrings[i] = prepare_docstring('\\n'.join(remaining_lines),\n+                                                          tabsize=tab_width)\n+                # Clear the processed sections\n+                for j in range(i + 1, current_i):\n+                    self._new_docstrings[j] = []\n+                last_processed_i = current_i - 1\n+                \n+        return results\n+\n     def format_signature(self, **kwargs: Any) -> str:\n         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore\n             # only act if a signature is not explicitly given already, and if\n             # the feature is enabled\n-            result = self._find_signature()\n-            if result is not None:\n-                self.args, self.retann = result\n+            results = self._find_signature()\n+            if results:\n+                # For now, just use the first signature\n+                # TODO: Future enhancement could be to show all signatures\n+                self.args, self.retann = results[0]\n         return super().format_signature(**kwargs)  # type: ignore\n \n \n", "occurrence": 1, "normalized_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 4087d22..2dd45c6 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -754,32 +754,6 @@ class DocstringSignatureMixin:\n     feature of reading the signature from the docstring.\n     \"\"\"\n \n-    def _find_signature(self, encoding: str=None) -> Tuple[str, str]:\n-        if encoding is not None:\n-            warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is deprecated.\" % self.__class__.__name__, RemovedInSphinx40Warning, stacklevel=2)\n-        docstrings = self.get_doc()\n-        self._new_docstrings = docstrings[:]\n-        result = None\n-        for i, doclines in enumerate(docstrings):\n-            if not doclines:\n-                continue\n-            match = py_ext_sig_re.match(doclines[0])\n-            if not match:\n-                continue\n-            exmod, path, base, args, retann = match.groups()\n-            valid_names = [self.objpath[-1]]\n-            if isinstance(self, ClassDocumenter):\n-                valid_names.append('__init__')\n-                if hasattr(self.object, '__mro__'):\n-                    valid_names.extend((cls.__name__ for cls in self.object.__mro__))\n-            if base not in valid_names:\n-                continue\n-            tab_width = self.directive.state.document.settings.tab_width\n-            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]), tabsize=tab_width)\n-            result = (args, retann)\n-            break\n-        return result\n-\n     def get_doc(self, encoding: str=None, ignore: int=None) -> List[List[str]]:\n         if encoding is not None:\n             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\" % self.__class__.__name__, RemovedInSphinx40Warning, stacklevel=2)\n@@ -788,11 +762,51 @@ class DocstringSignatureMixin:\n             return lines\n         return super().get_doc(None, ignore)\n \n+    def _find_signature(self, encoding: str=None) -> List[Tuple[str, str]]:\n+        if encoding is not None:\n+            warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is deprecated.\" % self.__class__.__name__, RemovedInSphinx40Warning, stacklevel=2)\n+        docstrings = self.get_doc()\n+        self._new_docstrings = docstrings[:]\n+        results = []\n+        last_processed_i = -1\n+        for i, doclines in enumerate(docstrings):\n+            if i <= last_processed_i:\n+                continue\n+            if not doclines:\n+                continue\n+            current_i = i\n+            while current_i < len(docstrings) and doclines:\n+                match = py_ext_sig_re.match(doclines[0])\n+                if not match:\n+                    break\n+                exmod, path, base, args, retann = match.groups()\n+                valid_names = [self.objpath[-1]]\n+                if isinstance(self, ClassDocumenter):\n+                    valid_names.append('__init__')\n+                    if hasattr(self.object, '__mro__'):\n+                        valid_names.extend((cls.__name__ for cls in self.object.__mro__))\n+                if base not in valid_names:\n+                    break\n+                results.append((args, retann))\n+                current_i += 1\n+                if current_i < len(docstrings):\n+                    doclines = docstrings[current_i]\n+            if results:\n+                tab_width = self.directive.state.document.settings.tab_width\n+                remaining_lines = []\n+                for j in range(current_i, len(docstrings)):\n+                    remaining_lines.extend(docstrings[j])\n+                self._new_docstrings[i] = prepare_docstring('\\n'.join(remaining_lines), tabsize=tab_width)\n+                for j in range(i + 1, current_i):\n+                    self._new_docstrings[j] = []\n+                last_processed_i = current_i - 1\n+        return results\n+\n     def format_signature(self, **kwargs: Any) -> str:\n         if self.args is None and self.env.config.autodoc_docstring_signature:\n-            result = self._find_signature()\n-            if result is not None:\n-                self.args, self.retann = result\n+            results = self._find_signature()\n+            if results:\n+                self.args, self.retann = results[0]\n         return super().format_signature(**kwargs)\n \n class DocstringStripSignatureMixin(DocstringSignatureMixin):\n", "normalized_occurrence": 1}
