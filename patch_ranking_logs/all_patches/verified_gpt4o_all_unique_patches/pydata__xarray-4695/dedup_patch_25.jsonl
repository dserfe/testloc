{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4695", "model_patch": "diff --git a/xarray/core/indexing.py b/xarray/core/indexing.py\nindex 4b06bfd..1521d9a 100644\n--- a/xarray/core/indexing.py\n+++ b/xarray/core/indexing.py\n@@ -105,7 +105,7 @@ def get_indexer_nd(index, labels, method=None, tolerance=None):\n     return indexer\n \n \n-def convert_label_indexer(index, label, index_name=\"\", method=None, tolerance=None):\n+def convert_label_indexer(index, label, index_name=\"\", method=None, tolerance=None, dim_method_name=\"method\"):\n     \"\"\"Given a pandas.Index and labels (e.g., from __getitem__) for one\n     dimension, return an indexer suitable for indexing an ndarray along that\n     dimension. If `index` is a pandas.MultiIndex and depending on `label`,\n@@ -132,7 +132,7 @@ def convert_label_indexer(index, label, index_name=\"\", method=None, tolerance=No\n                 \"unsorted or non-unique\"\n             )\n \n-    elif is_dict_like(label):\n+    elif is_dict_like(label) and index_name != dim_method_name:\n         is_nested_vals = _is_nested_tuple(tuple(label.values()))\n         if not isinstance(index, pd.MultiIndex):\n             raise ValueError(\n@@ -203,7 +203,7 @@ def convert_label_indexer(index, label, index_name=\"\", method=None, tolerance=No\n     return indexer, new_index\n \n \n-def get_dim_indexers(data_obj, indexers):\n+def get_dim_indexers(data_obj, indexers, dim_method_name=\"method\"):\n     \"\"\"Given a xarray data object and label based indexers, return a mapping\n     of label indexers with only dimension names as keys.\n \n", "occurrence": 1, "normalized_patch": "diff --git a/xarray/core/indexing.py b/xarray/core/indexing.py\nindex 27ac399..5b9b332 100644\n--- a/xarray/core/indexing.py\n+++ b/xarray/core/indexing.py\n@@ -57,7 +57,7 @@ def get_indexer_nd(index, labels, method=None, tolerance=None):\n     flat_indexer = index.get_indexer(flat_labels, method=method, tolerance=tolerance)\n     indexer = flat_indexer.reshape(labels.shape)\n     return indexer\n-def convert_label_indexer(index, label, index_name='', method=None, tolerance=None):\n+def convert_label_indexer(index, label, index_name='', method=None, tolerance=None, dim_method_name='method'):\n     new_index = None\n     if isinstance(label, slice):\n         if method is not None or tolerance is not None:\n@@ -65,7 +65,7 @@ def convert_label_indexer(index, label, index_name='', method=None, tolerance=No\n         indexer = index.slice_indexer(_sanitize_slice_element(label.start), _sanitize_slice_element(label.stop), _sanitize_slice_element(label.step))\n         if not isinstance(indexer, slice):\n             raise KeyError(f'cannot represent labeled-based slice indexer for dimension {index_name!r} with a slice over integer positions; the index is unsorted or non-unique')\n-    elif is_dict_like(label):\n+    elif is_dict_like(label) and index_name != dim_method_name:\n         is_nested_vals = _is_nested_tuple(tuple(label.values()))\n         if not isinstance(index, pd.MultiIndex):\n             raise ValueError('cannot use a dict-like object for selection on a dimension that does not have a MultiIndex')\n@@ -108,7 +108,7 @@ def convert_label_indexer(index, label, index_name='', method=None, tolerance=No\n             if np.any(indexer < 0):\n                 raise KeyError(f'not all values found in index {index_name!r}')\n     return (indexer, new_index)\n-def get_dim_indexers(data_obj, indexers):\n+def get_dim_indexers(data_obj, indexers, dim_method_name='method'):\n     invalid = [k for k in indexers if k not in data_obj.dims and k not in data_obj._level_coords]\n     if invalid:\n         raise ValueError(f'dimensions or multi-index levels {invalid!r} do not exist')\n", "normalized_occurrence": 1}
