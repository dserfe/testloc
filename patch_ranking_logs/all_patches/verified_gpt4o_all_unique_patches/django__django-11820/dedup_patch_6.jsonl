{"model_name_or_path": "agentless", "instance_id": "django__django-11820", "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 4c7a87c..fc1cc42 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1708,7 +1708,10 @@ class Model(metaclass=ModelBase):\n             fld = None\n             for part in field.split(LOOKUP_SEP):\n                 try:\n-                    fld = _cls._meta.get_field(part)\n+                    if part == 'pk':\n+                        fld = _cls._meta.pk\n+                    else:\n+                        fld = _cls._meta.get_field(part)\n                     if fld.is_relation:\n                         _cls = fld.get_path_info()[-1].to_opts.model\n                 except (FieldDoesNotExist, AttributeError):\n@@ -1724,7 +1727,7 @@ class Model(metaclass=ModelBase):\n \n         # Skip ordering on pk. This is always a valid order_by field\n         # but is an alias and therefore won't be found by opts.get_field.\n-        fields = {f for f in fields if f != 'pk'}\n+        fields = {f for f in fields if f != 'pk' and not f.endswith('__pk')}\n \n         # Check for invalid or nonexistent fields in ordering.\n         invalid_fields = []\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex d3d0e2f..f64f794 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -874,13 +874,16 @@ class Model(metaclass=ModelBase):\n             fld = None\n             for part in field.split(LOOKUP_SEP):\n                 try:\n-                    fld = _cls._meta.get_field(part)\n+                    if part == 'pk':\n+                        fld = _cls._meta.pk\n+                    else:\n+                        fld = _cls._meta.get_field(part)\n                     if fld.is_relation:\n                         _cls = fld.get_path_info()[-1].to_opts.model\n                 except (FieldDoesNotExist, AttributeError):\n                     if fld is None or fld.get_transform(part) is None:\n                         errors.append(checks.Error(\"'ordering' refers to the nonexistent field, related field, or lookup '%s'.\" % field, obj=cls, id='models.E015'))\n-        fields = {f for f in fields if f != 'pk'}\n+        fields = {f for f in fields if f != 'pk' and (not f.endswith('__pk'))}\n         invalid_fields = []\n         opts = cls._meta\n         valid_fields = set(chain.from_iterable(((f.name, f.attname) if not (f.auto_created and (not f.concrete)) else (f.field.related_query_name(),) for f in chain(opts.fields, opts.related_objects))))\n", "normalized_occurrence": 1}
