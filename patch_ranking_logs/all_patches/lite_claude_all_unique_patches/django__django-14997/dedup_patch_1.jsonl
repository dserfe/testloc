{"model_name_or_path": "agentless_claude", "instance_id": "django__django-14997", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 8cfc221..73379bb 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1219,6 +1219,11 @@ class BaseDatabaseSchemaEditor:\n             not self.connection.features.supports_deferrable_unique_constraints\n         ):\n             return None\n+        if expressions and self.connection.vendor == 'sqlite':\n+            raise NotImplementedError(\n+                \"SQLite does not support using expressions in unique constraints. \"\n+                \"Use field names as strings instead.\"\n+            )\n         if condition or include or opclasses or expressions:\n             # Databases support conditional, covering, and functional unique\n             # constraints via a unique index.\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex a8d38b8..ab79b0b 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -572,6 +572,8 @@ class BaseDatabaseSchemaEditor:\n     def _unique_sql(self, model, fields, name, condition=None, deferrable=None, include=None, opclasses=None, expressions=None):\n         if deferrable and (not self.connection.features.supports_deferrable_unique_constraints):\n             return None\n+        if expressions and self.connection.vendor == 'sqlite':\n+            raise NotImplementedError('SQLite does not support using expressions in unique constraints. Use field names as strings instead.')\n         if condition or include or opclasses or expressions:\n             sql = self._create_unique_sql(model, fields, name=name, condition=condition, include=include, opclasses=opclasses, expressions=expressions)\n             if sql:\n", "normalized_occurrence": 1}
