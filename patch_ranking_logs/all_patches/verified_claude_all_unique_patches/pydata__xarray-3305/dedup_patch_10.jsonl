{"model_name_or_path": "agentless_claude", "instance_id": "pydata__xarray-3305", "model_patch": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex baab678..928cd17 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -2824,58 +2824,7 @@ class DataArray(AbstractArray, DataWithCoords):\n         ds = self._to_temp_dataset().sortby(variables, ascending=ascending)\n         return self._from_temp_dataset(ds)\n \n-    def quantile(\n-        self,\n-        q: Any,\n-        dim: Union[Hashable, Sequence[Hashable], None] = None,\n-        interpolation: str = \"linear\",\n-        keep_attrs: bool = None,\n-    ) -> \"DataArray\":\n-        \"\"\"Compute the qth quantile of the data along the specified dimension.\n \n-        Returns the qth quantiles(s) of the array elements.\n-\n-        Parameters\n-        ----------\n-        q : float in range of [0,1] or array-like of floats\n-            Quantile to compute, which must be between 0 and 1 inclusive.\n-        dim : hashable or sequence of hashable, optional\n-            Dimension(s) over which to apply quantile.\n-        interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n-            This optional parameter specifies the interpolation method to\n-            use when the desired quantile lies between two data points\n-            ``i < j``:\n-\n-                - linear: ``i + (j - i) * fraction``, where ``fraction`` is\n-                  the fractional part of the index surrounded by ``i`` and\n-                  ``j``.\n-                - lower: ``i``.\n-                - higher: ``j``.\n-                - nearest: ``i`` or ``j``, whichever is nearest.\n-                - midpoint: ``(i + j) / 2``.\n-        keep_attrs : bool, optional\n-            If True, the dataset's attributes (`attrs`) will be copied from\n-            the original object to the new one.  If False (default), the new\n-            object will be returned without attributes.\n-\n-        Returns\n-        -------\n-        quantiles : DataArray\n-            If `q` is a single quantile, then the result\n-            is a scalar. If multiple percentiles are given, first axis of\n-            the result corresponds to the quantile and a quantile dimension\n-            is added to the return array. The other dimensions are the\n-             dimensions that remain after the reduction of the array.\n-\n-        See Also\n-        --------\n-        numpy.nanpercentile, pandas.Series.quantile, Dataset.quantile\n-        \"\"\"\n-\n-        ds = self._to_temp_dataset().quantile(\n-            q, dim=dim, keep_attrs=keep_attrs, interpolation=interpolation\n-        )\n-        return self._from_temp_dataset(ds)\n \n     def rank(\n         self, dim: Hashable, pct: bool = False, keep_attrs: bool = None\n", "occurrence": 2, "normalized_patch": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex 85617db..8f9cd73 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -755,9 +755,6 @@ class DataArray(AbstractArray, DataWithCoords):\n     def sortby(self, variables: Union[Hashable, 'DataArray', Sequence[Union[Hashable, 'DataArray']]], ascending: bool=True) -> 'DataArray':\n         ds = self._to_temp_dataset().sortby(variables, ascending=ascending)\n         return self._from_temp_dataset(ds)\n-    def quantile(self, q: Any, dim: Union[Hashable, Sequence[Hashable], None]=None, interpolation: str='linear', keep_attrs: bool=None) -> 'DataArray':\n-        ds = self._to_temp_dataset().quantile(q, dim=dim, keep_attrs=keep_attrs, interpolation=interpolation)\n-        return self._from_temp_dataset(ds)\n     def rank(self, dim: Hashable, pct: bool=False, keep_attrs: bool=None) -> 'DataArray':\n         ds = self._to_temp_dataset().rank(dim, pct=pct, keep_attrs=keep_attrs)\n         return self._from_temp_dataset(ds)\n", "normalized_occurrence": 2}
