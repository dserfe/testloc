{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-11040", "model_patch": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 01d85d0..ac1eb57 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -100,6 +100,10 @@ def _get_weights(dist, weights):\n \n \n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n+    def _validate_n_neighbors(self, n_neighbors):\n+        if n_neighbors is not None and not isinstance(n_neighbors, int):\n+            raise ValueError(\"n_neighbors should be an integer, got %s\" % type(n_neighbors).__name__)\n+        return n_neighbors\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n     @abstractmethod\n@@ -107,7 +111,7 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n-        self.n_neighbors = n_neighbors\n+        self.n_neighbors = self._validate_n_neighbors(n_neighbors)\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -252,7 +256,8 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n             raise ValueError(\"algorithm = '%s' not recognized\"\n                              % self.algorithm)\n \n-        if self.n_neighbors is not None:\n+        if self.n_neighbors is not None and not isinstance(self.n_neighbors, int):\n+            raise ValueError(\"n_neighbors should be an integer, got %s\" % type(self.n_neighbors).__name__)\n             if self.n_neighbors <= 0:\n                 raise ValueError(\n                     \"Expected n_neighbors > 0. Got %d\" %\n@@ -327,6 +332,9 @@ class KNeighborsMixin(object):\n \n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n+        if not isinstance(n_neighbors, int):\n+            raise ValueError(\"n_neighbors should be an integer, got %s\" % type(n_neighbors).__name__)\n+            n_neighbors = self.n_neighbors\n \n         if X is not None:\n             query_is_train = False\n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex ddfefae..7628530 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -45,9 +45,14 @@ def _get_weights(dist, weights):\n     else:\n         raise ValueError(\"weights not recognized: should be 'uniform', 'distance', or a callable function\")\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n+    def _validate_n_neighbors(self, n_neighbors):\n+        if n_neighbors is not None and (not isinstance(n_neighbors, int)):\n+            raise ValueError('n_neighbors should be an integer, got %s' % type(n_neighbors).__name__)\n+        return n_neighbors\n+    'Base class for nearest neighbors estimators.'\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None, algorithm='auto', leaf_size=30, metric='minkowski', p=2, metric_params=None, n_jobs=1):\n-        self.n_neighbors = n_neighbors\n+        self.n_neighbors = self._validate_n_neighbors(n_neighbors)\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -150,7 +155,8 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n             self._tree = None\n         else:\n             raise ValueError(\"algorithm = '%s' not recognized\" % self.algorithm)\n-        if self.n_neighbors is not None:\n+        if self.n_neighbors is not None and (not isinstance(self.n_neighbors, int)):\n+            raise ValueError('n_neighbors should be an integer, got %s' % type(self.n_neighbors).__name__)\n             if self.n_neighbors <= 0:\n                 raise ValueError('Expected n_neighbors > 0. Got %d' % self.n_neighbors)\n         return self\n@@ -162,6 +168,9 @@ class KNeighborsMixin(object):\n         check_is_fitted(self, '_fit_method')\n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n+        if not isinstance(n_neighbors, int):\n+            raise ValueError('n_neighbors should be an integer, got %s' % type(n_neighbors).__name__)\n+            n_neighbors = self.n_neighbors\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n", "normalized_occurrence": 1}
