{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-24066", "model_patch": "diff --git a/sympy/physics/units/dimensions.py b/sympy/physics/units/dimensions.py\nindex d505a16..69b0484 100644\n--- a/sympy/physics/units/dimensions.py\n+++ b/sympy/physics/units/dimensions.py\n@@ -401,19 +401,23 @@ class DimensionSystem(Basic, _QuantityMapper):\n \n             dicts = [get_for_name(i) for i in dimension.name.args]\n \n-            if isinstance(result, Dimension):\n-                return self.get_dimensional_dependencies(result)\n-            elif result.func == dimension.name.func:\n+            # For transcendental functions (exp, log, etc.) and trigonometric functions,\n+            # check dimensionality of arguments first\n+            if isinstance(dimension.name, (TrigonometricFunction, exp, log)):\n                 if isinstance(dimension.name, TrigonometricFunction):\n-                    if dicts[0] in ({}, {Dimension('angle'): 1}):\n-                        return {}\n-                    else:\n+                    if dicts[0] not in ({}, {Dimension('angle'): 1}):\n                         raise TypeError(\"The input argument for the function {} must be dimensionless or have dimensions of angle.\".format(dimension.func))\n                 else:\n-                    if all(item == {} for item in dicts):\n-                        return {}\n-                    else:\n+                    if not all(item == {} for item in dicts):\n                         raise TypeError(\"The input arguments for the function {} must be dimensionless.\".format(dimension.func))\n+                return {}\n+            elif isinstance(result, Dimension):\n+                return self.get_dimensional_dependencies(result)\n+            elif result.func == dimension.name.func:\n+                if all(item == {} for item in dicts):\n+                    return {}\n+                else:\n+                    raise TypeError(\"The input arguments for the function {} must be dimensionless.\".format(dimension.func))\n             else:\n                 return get_for_name(result)\n \n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/physics/units/dimensions.py b/sympy/physics/units/dimensions.py\nindex 14cb605..df01475 100644\n--- a/sympy/physics/units/dimensions.py\n+++ b/sympy/physics/units/dimensions.py\n@@ -228,15 +228,17 @@ class DimensionSystem(Basic, _QuantityMapper):\n             args = (Dimension._from_dimensional_dependencies(get_for_name(arg)) for arg in dimension.name.args)\n             result = dimension.name.func(*args)\n             dicts = [get_for_name(i) for i in dimension.name.args]\n-            if isinstance(result, Dimension):\n-                return self.get_dimensional_dependencies(result)\n-            elif result.func == dimension.name.func:\n+            if isinstance(dimension.name, (TrigonometricFunction, exp, log)):\n                 if isinstance(dimension.name, TrigonometricFunction):\n-                    if dicts[0] in ({}, {Dimension('angle'): 1}):\n-                        return {}\n-                    else:\n+                    if dicts[0] not in ({}, {Dimension('angle'): 1}):\n                         raise TypeError('The input argument for the function {} must be dimensionless or have dimensions of angle.'.format(dimension.func))\n-                elif all((item == {} for item in dicts)):\n+                elif not all((item == {} for item in dicts)):\n+                    raise TypeError('The input arguments for the function {} must be dimensionless.'.format(dimension.func))\n+                return {}\n+            elif isinstance(result, Dimension):\n+                return self.get_dimensional_dependencies(result)\n+            elif result.func == dimension.name.func:\n+                if all((item == {} for item in dicts)):\n                     return {}\n                 else:\n                     raise TypeError('The input arguments for the function {} must be dimensionless.'.format(dimension.func))\n", "normalized_occurrence": 1}
