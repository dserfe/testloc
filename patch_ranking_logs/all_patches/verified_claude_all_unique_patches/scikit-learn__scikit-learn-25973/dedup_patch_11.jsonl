{"model_name_or_path": "agentless_claude", "instance_id": "scikit-learn__scikit-learn-25973", "model_patch": "diff --git a/sklearn/feature_selection/_sequential.py b/sklearn/feature_selection/_sequential.py\nindex 2854ca5..65ed388 100644\n--- a/sklearn/feature_selection/_sequential.py\n+++ b/sklearn/feature_selection/_sequential.py\n@@ -291,6 +291,15 @@ class SequentialFeatureSelector(SelectorMixin, MetaEstimatorMixin, BaseEstimator\n \n         return self\n \n+    def __init__(self, estimator, *, n_features_to_select=None, tol=None, direction=\"forward\", scoring=None, cv=5, n_jobs=None):\n+        self.estimator = estimator\n+        self.n_features_to_select = n_features_to_select\n+        self.tol = tol\n+        self.direction = direction\n+        self.scoring = scoring\n+        self.cv = list(cv) if hasattr(cv, '__iter__') and not isinstance(cv, (str, int)) else cv\n+        self.n_jobs = n_jobs\n+\n     def _get_best_new_feature_score(self, estimator, X, y, current_mask):\n         # Return the best new feature and its score to add to the current_mask,\n         # i.e. return the best new feature and its score to add (resp. remove)\n@@ -323,4 +332,4 @@ class SequentialFeatureSelector(SelectorMixin, MetaEstimatorMixin, BaseEstimator\n     def _more_tags(self):\n         return {\n             \"allow_nan\": _safe_tags(self.estimator, key=\"allow_nan\"),\n-        }\n+        }\n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/feature_selection/_sequential.py b/sklearn/feature_selection/_sequential.py\nindex f5583ad..50d6203 100644\n--- a/sklearn/feature_selection/_sequential.py\n+++ b/sklearn/feature_selection/_sequential.py\n@@ -60,6 +60,14 @@ class SequentialFeatureSelector(SelectorMixin, MetaEstimatorMixin, BaseEstimator\n         self.support_ = current_mask\n         self.n_features_to_select_ = self.support_.sum()\n         return self\n+    def __init__(self, estimator, *, n_features_to_select=None, tol=None, direction='forward', scoring=None, cv=5, n_jobs=None):\n+        self.estimator = estimator\n+        self.n_features_to_select = n_features_to_select\n+        self.tol = tol\n+        self.direction = direction\n+        self.scoring = scoring\n+        self.cv = list(cv) if hasattr(cv, '__iter__') and (not isinstance(cv, (str, int))) else cv\n+        self.n_jobs = n_jobs\n     def _get_best_new_feature_score(self, estimator, X, y, current_mask):\n         candidate_feature_indices = np.flatnonzero(~current_mask)\n         scores = {}\n", "normalized_occurrence": 1}
