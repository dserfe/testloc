{"model_name_or_path": "agentless_claude", "instance_id": "matplotlib__matplotlib-22835", "model_patch": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 1878dd6..e7cc28b 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1903,13 +1903,35 @@ class BoundaryNorm(Normalize):\n \n     def inverse(self, value):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Compute an approximate inverse of the normalization.\n+\n+        Parameters\n+        ----------\n+        value : array-like\n+            The normalized values between 0 and 1.\n+\n+        Returns\n+        -------\n+        scalar or array-like\n+            The approximate boundary middle points corresponding to *value*.\n+\n+        Notes\n+        -----\n+        This method assumes that *value* is monotonically increasing with the\n+        values used to initialize the normalization. The returned values are\n+        the centers of the boundary regions.\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        # Convert from [0, 1] to boundary indices\n+        value = np.asarray(value)\n+        fx = value * (self.boundaries.size - 1)\n+        ix = fx.astype(int).clip(0, self.boundaries.size - 2)\n+\n+        # Return the center point of each bounded region\n+        result = (self.boundaries[ix] + self.boundaries[ix + 1]) / 2\n+        # Handle scalar inputs\n+        if result.ndim == 0 or (result.size == 1 and not isinstance(value, np.ndarray)):\n+            result = float(result)\n+        return result\n \n \n class NoNorm(Normalize):\n", "occurrence": 1, "normalized_patch": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex b4a7c6b..7b83e02 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1631,13 +1631,31 @@ class BoundaryNorm(Normalize):\n \n     def inverse(self, value):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Compute an approximate inverse of the normalization.\n+\n+        Parameters\n+        ----------\n+        value : array-like\n+            The normalized values between 0 and 1.\n+\n+        Returns\n+        -------\n+        scalar or array-like\n+            The approximate boundary middle points corresponding to *value*.\n+\n+        Notes\n+        -----\n+        This method assumes that *value* is monotonically increasing with the\n+        values used to initialize the normalization. The returned values are\n+        the centers of the boundary regions.\n         \"\"\"\n-        raise ValueError('BoundaryNorm is not invertible')\n+        value = np.asarray(value)\n+        fx = value * (self.boundaries.size - 1)\n+        ix = fx.astype(int).clip(0, self.boundaries.size - 2)\n+        result = (self.boundaries[ix] + self.boundaries[ix + 1]) / 2\n+        if result.ndim == 0 or (result.size == 1 and (not isinstance(value, np.ndarray))):\n+            result = float(result)\n+        return result\n \n class NoNorm(Normalize):\n     \"\"\"\n", "normalized_occurrence": 1}
