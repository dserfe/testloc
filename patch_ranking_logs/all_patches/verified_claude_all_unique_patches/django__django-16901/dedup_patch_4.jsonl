{"model_name_or_path": "agentless_claude", "instance_id": "django__django-16901", "model_patch": "diff --git a/django/db/backends/base/operations.py b/django/db/backends/base/operations.py\nindex 5801e03..6d5a5a9 100644\n--- a/django/db/backends/base/operations.py\n+++ b/django/db/backends/base/operations.py\n@@ -668,6 +668,16 @@ class BaseDatabaseOperations:\n         can vary between backends (e.g., Oracle with %% and &) and between\n         subexpression types (e.g., date expressions).\n         \"\"\"\n+        if connector == 'XOR':\n+            # Implement proper XOR logic for odd/even number of true values\n+            if len(sub_expressions) == 2:\n+                # For two expressions: (a AND NOT b) OR (NOT a AND b)\n+                a, b = sub_expressions\n+                return f\"(({a} AND NOT {b}) OR (NOT {a} AND {b}))\"\n+            else:\n+                # For multiple expressions: count the number of true expressions and check if it's odd\n+                exprs_sum = \" + \".join(f\"CASE WHEN {expr} THEN 1 ELSE 0 END\" for expr in sub_expressions)\n+                return f\"MOD(({exprs_sum}), 2) = 1\"\n         conn = \" %s \" % connector\n         return conn.join(sub_expressions)\n \n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/backends/base/operations.py b/django/db/backends/base/operations.py\nindex ba948a6..9f459b6 100644\n--- a/django/db/backends/base/operations.py\n+++ b/django/db/backends/base/operations.py\n@@ -215,6 +215,13 @@ class BaseDatabaseOperations:\n     def conditional_expression_supported_in_where_clause(self, expression):\n         return True\n     def combine_expression(self, connector, sub_expressions):\n+        if connector == 'XOR':\n+            if len(sub_expressions) == 2:\n+                a, b = sub_expressions\n+                return f'(({a} AND NOT {b}) OR (NOT {a} AND {b}))'\n+            else:\n+                exprs_sum = ' + '.join((f'CASE WHEN {expr} THEN 1 ELSE 0 END' for expr in sub_expressions))\n+                return f'MOD(({exprs_sum}), 2) = 1'\n         conn = ' %s ' % connector\n         return conn.join(sub_expressions)\n     def combine_duration_expression(self, connector, sub_expressions):\n", "normalized_occurrence": 1}
