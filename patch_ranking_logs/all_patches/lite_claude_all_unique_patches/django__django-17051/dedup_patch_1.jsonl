{"model_name_or_path": "agentless_claude", "instance_id": "django__django-17051", "model_patch": "diff --git a/django/db/backends/postgresql/operations.py b/django/db/backends/postgresql/operations.py\nindex 7f396c2..7b73cd3 100644\n--- a/django/db/backends/postgresql/operations.py\n+++ b/django/db/backends/postgresql/operations.py\n@@ -397,9 +397,12 @@ class DatabaseOperations(BaseDatabaseOperations):\n \n     def on_conflict_suffix_sql(self, fields, on_conflict, update_fields, unique_fields):\n         if on_conflict == OnConflict.IGNORE:\n+            # For IGNORE, we can't reliably get the IDs of ignored rows\n             return \"ON CONFLICT DO NOTHING\"\n         if on_conflict == OnConflict.UPDATE:\n-            return \"ON CONFLICT(%s) DO UPDATE SET %s\" % (\n+            # For UPDATE, we can get the IDs of updated rows\n+            returning = \" RETURNING %s\" % self.quote_name(\"id\") if fields else \"\"\n+            return \"ON CONFLICT(%s) DO UPDATE SET %s%s\" % (\n                 \", \".join(map(self.quote_name, unique_fields)),\n                 \", \".join(\n                     [\n@@ -407,6 +410,7 @@ class DatabaseOperations(BaseDatabaseOperations):\n                         for field in map(self.quote_name, update_fields)\n                     ]\n                 ),\n+                returning,\n             )\n         return super().on_conflict_suffix_sql(\n             fields,\n@@ -423,4 +427,4 @@ class DatabaseOperations(BaseDatabaseOperations):\n         if lhs_field.db_type(self.connection) != rhs_field.db_type(self.connection):\n             rhs_expr = Cast(rhs_expr, lhs_field)\n \n-        return lhs_expr, rhs_expr\n+        return lhs_expr, rhs_expr\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/backends/postgresql/operations.py b/django/db/backends/postgresql/operations.py\nindex 7919a18..506c8b8 100644\n--- a/django/db/backends/postgresql/operations.py\n+++ b/django/db/backends/postgresql/operations.py\n@@ -207,7 +207,8 @@ class DatabaseOperations(BaseDatabaseOperations):\n         if on_conflict == OnConflict.IGNORE:\n             return 'ON CONFLICT DO NOTHING'\n         if on_conflict == OnConflict.UPDATE:\n-            return 'ON CONFLICT(%s) DO UPDATE SET %s' % (', '.join(map(self.quote_name, unique_fields)), ', '.join([f'{field} = EXCLUDED.{field}' for field in map(self.quote_name, update_fields)]))\n+            returning = ' RETURNING %s' % self.quote_name('id') if fields else ''\n+            return 'ON CONFLICT(%s) DO UPDATE SET %s%s' % (', '.join(map(self.quote_name, unique_fields)), ', '.join([f'{field} = EXCLUDED.{field}' for field in map(self.quote_name, update_fields)]), returning)\n         return super().on_conflict_suffix_sql(fields, on_conflict, update_fields, unique_fields)\n     def prepare_join_on_clause(self, lhs_table, lhs_field, rhs_table, rhs_field):\n         lhs_expr, rhs_expr = super().prepare_join_on_clause(lhs_table, lhs_field, rhs_table, rhs_field)\n", "normalized_occurrence": 1}
