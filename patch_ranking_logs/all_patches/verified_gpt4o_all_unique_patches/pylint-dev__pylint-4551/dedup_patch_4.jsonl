{"model_name_or_path": "agentless", "instance_id": "pylint-dev__pylint-4551", "model_patch": "diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex 0111bb1..3386e76 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -79,21 +79,20 @@ class ClassDiagram(Figure, FilterMixIn):\n     def get_attrs(self, node):\n         \"\"\"return visible attributes, possibly with class name\"\"\"\n         attrs = []\n-        properties = [\n-            (n, m)\n-            for n, m in node.items()\n-            if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n-        ]\n         for node_name, associated_nodes in (\n             list(node.instance_attrs_type.items())\n             + list(node.locals_type.items())\n-            + properties\n         ):\n             if not self.show_attr(node_name):\n                 continue\n-            names = self.class_names(associated_nodes)\n-            if names:\n-                node_name = \"{} : {}\".format(node_name, \", \".join(names))\n+            # Check for type hints\n+            if node_name in node.annotations:\n+                type_hint = node.annotations[node_name]\n+                node_name = \"{} : {}\".format(node_name, type_hint.as_string())\n+            else:\n+                names = self.class_names(associated_nodes)\n+                if names:\n+                    node_name = \"{} : {}\".format(node_name, \", \".join(names))\n             attrs.append(node_name)\n         return sorted(attrs)\n \n", "occurrence": 1, "normalized_patch": "diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex d9b60dc..f427a34 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -56,13 +56,16 @@ class ClassDiagram(Figure, FilterMixIn):\n     def get_attrs(self, node):\n         \"\"\"return visible attributes, possibly with class name\"\"\"\n         attrs = []\n-        properties = [(n, m) for n, m in node.items() if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)]\n-        for node_name, associated_nodes in list(node.instance_attrs_type.items()) + list(node.locals_type.items()) + properties:\n+        for node_name, associated_nodes in list(node.instance_attrs_type.items()) + list(node.locals_type.items()):\n             if not self.show_attr(node_name):\n                 continue\n-            names = self.class_names(associated_nodes)\n-            if names:\n-                node_name = '{} : {}'.format(node_name, ', '.join(names))\n+            if node_name in node.annotations:\n+                type_hint = node.annotations[node_name]\n+                node_name = '{} : {}'.format(node_name, type_hint.as_string())\n+            else:\n+                names = self.class_names(associated_nodes)\n+                if names:\n+                    node_name = '{} : {}'.format(node_name, ', '.join(names))\n             attrs.append(node_name)\n         return sorted(attrs)\n \n", "normalized_occurrence": 1}
