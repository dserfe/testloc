{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9461", "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 00b90de..eb7475a 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1548,7 +1548,23 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n         # with __init__ in C and no `__text_signature__`.\n         return None, None, None\n \n-    def format_args(self, **kwargs: Any) -> str:\n+    def import_object(self, raiseerror: bool = False) -> bool:\n+        ret = super().import_object(raiseerror)\n+        if not ret:\n+            return ret\n+\n+        # to distinguish classmethod/staticmethod/property\n+        obj = self.parent.__dict__.get(self.object_name)\n+        if obj is None:\n+            obj = self.object\n+\n+        if inspect.isclassmethod(obj):\n+            self.member_order = self.member_order - 1\n+        if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n+            self.member_order = self.member_order - 1\n+        if isinstance(obj, property):\n+            self.member_order = self.member_order - 1\n+        return ret\n         if self.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n@@ -1565,7 +1581,22 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n \n         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n \n-    def format_signature(self, **kwargs: Any) -> str:\n+    def add_directive_header(self, sig: str) -> None:\n+        super().add_directive_header(sig)\n+        sourcename = self.get_sourcename()\n+        obj = self.parent.__dict__.get(self.object_name, self.object)\n+        if inspect.isabstractmethod(obj):\n+            self.add_line('   :abstractmethod:', sourcename)\n+        if inspect.iscoroutinefunction(obj):\n+            self.add_line('   :async:', sourcename)\n+        if inspect.isclassmethod(obj):\n+            self.add_line('   :classmethod:', sourcename)\n+        if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n+            self.add_line('   :staticmethod:', sourcename)\n+        if isinstance(obj, property):\n+            self.add_line('   :property:', sourcename)\n+        if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n+            self.add_line('   :final:', sourcename)\n         if self.doc_as_attr:\n             return ''\n         if self.config.autodoc_class_signature == 'separated':\n@@ -2088,7 +2119,23 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type:\n \n         return ret\n \n-    def format_args(self, **kwargs: Any) -> str:\n+    def import_object(self, raiseerror: bool = False) -> bool:\n+        ret = super().import_object(raiseerror)\n+        if not ret:\n+            return ret\n+\n+        # to distinguish classmethod/staticmethod/property\n+        obj = self.parent.__dict__.get(self.object_name)\n+        if obj is None:\n+            obj = self.object\n+\n+        if inspect.isclassmethod(obj):\n+            self.member_order = self.member_order - 1\n+        if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n+            self.member_order = self.member_order - 1\n+        if isinstance(obj, property):\n+            self.member_order = self.member_order - 1\n+        return ret\n         if self.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n@@ -2140,7 +2187,22 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type:\n     def document_members(self, all_members: bool = False) -> None:\n         pass\n \n-    def format_signature(self, **kwargs: Any) -> str:\n+    def add_directive_header(self, sig: str) -> None:\n+        super().add_directive_header(sig)\n+        sourcename = self.get_sourcename()\n+        obj = self.parent.__dict__.get(self.object_name, self.object)\n+        if inspect.isabstractmethod(obj):\n+            self.add_line('   :abstractmethod:', sourcename)\n+        if inspect.iscoroutinefunction(obj):\n+            self.add_line('   :async:', sourcename)\n+        if inspect.isclassmethod(obj):\n+            self.add_line('   :classmethod:', sourcename)\n+        if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n+            self.add_line('   :staticmethod:', sourcename)\n+        if isinstance(obj, property):\n+            self.add_line('   :property:', sourcename)\n+        if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n+            self.add_line('   :final:', sourcename)\n         sigs = []\n         if (self.analyzer and\n                 '.'.join(self.objpath) in self.analyzer.overloads and\n", "occurrence": 1, "normalized_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex ee3bdad..25bd228 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -864,7 +864,20 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):\n         except ValueError:\n             pass\n         return (None, None, None)\n-    def format_args(self, **kwargs: Any) -> str:\n+    def import_object(self, raiseerror: bool=False) -> bool:\n+        ret = super().import_object(raiseerror)\n+        if not ret:\n+            return ret\n+        obj = self.parent.__dict__.get(self.object_name)\n+        if obj is None:\n+            obj = self.object\n+        if inspect.isclassmethod(obj):\n+            self.member_order = self.member_order - 1\n+        if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n+            self.member_order = self.member_order - 1\n+        if isinstance(obj, property):\n+            self.member_order = self.member_order - 1\n+        return ret\n         if self.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n         try:\n@@ -875,7 +888,22 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):\n         if sig is None:\n             return None\n         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n-    def format_signature(self, **kwargs: Any) -> str:\n+    def add_directive_header(self, sig: str) -> None:\n+        super().add_directive_header(sig)\n+        sourcename = self.get_sourcename()\n+        obj = self.parent.__dict__.get(self.object_name, self.object)\n+        if inspect.isabstractmethod(obj):\n+            self.add_line('   :abstractmethod:', sourcename)\n+        if inspect.iscoroutinefunction(obj):\n+            self.add_line('   :async:', sourcename)\n+        if inspect.isclassmethod(obj):\n+            self.add_line('   :classmethod:', sourcename)\n+        if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n+            self.add_line('   :staticmethod:', sourcename)\n+        if isinstance(obj, property):\n+            self.add_line('   :property:', sourcename)\n+        if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n+            self.add_line('   :final:', sourcename)\n         if self.doc_as_attr:\n             return ''\n         if self.config.autodoc_class_signature == 'separated':\n@@ -1211,7 +1239,20 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):\n         if inspect.isclassmethod(obj) or inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n             self.member_order = self.member_order - 1\n         return ret\n-    def format_args(self, **kwargs: Any) -> str:\n+    def import_object(self, raiseerror: bool=False) -> bool:\n+        ret = super().import_object(raiseerror)\n+        if not ret:\n+            return ret\n+        obj = self.parent.__dict__.get(self.object_name)\n+        if obj is None:\n+            obj = self.object\n+        if inspect.isclassmethod(obj):\n+            self.member_order = self.member_order - 1\n+        if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n+            self.member_order = self.member_order - 1\n+        if isinstance(obj, property):\n+            self.member_order = self.member_order - 1\n+        return ret\n         if self.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n         try:\n@@ -1249,7 +1290,22 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):\n             self.add_line('   :final:', sourcename)\n     def document_members(self, all_members: bool=False) -> None:\n         pass\n-    def format_signature(self, **kwargs: Any) -> str:\n+    def add_directive_header(self, sig: str) -> None:\n+        super().add_directive_header(sig)\n+        sourcename = self.get_sourcename()\n+        obj = self.parent.__dict__.get(self.object_name, self.object)\n+        if inspect.isabstractmethod(obj):\n+            self.add_line('   :abstractmethod:', sourcename)\n+        if inspect.iscoroutinefunction(obj):\n+            self.add_line('   :async:', sourcename)\n+        if inspect.isclassmethod(obj):\n+            self.add_line('   :classmethod:', sourcename)\n+        if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n+            self.add_line('   :staticmethod:', sourcename)\n+        if isinstance(obj, property):\n+            self.add_line('   :property:', sourcename)\n+        if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n+            self.add_line('   :final:', sourcename)\n         sigs = []\n         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads and (self.config.autodoc_typehints != 'none'):\n             overloaded = True\n", "normalized_occurrence": 1}
