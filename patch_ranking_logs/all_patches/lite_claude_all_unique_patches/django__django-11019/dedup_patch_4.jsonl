{"model_name_or_path": "agentless_claude", "instance_id": "django__django-11019", "model_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex b9c8e61..20459a0 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -115,6 +115,65 @@ class Media:\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n     @staticmethod\n+    def check_order_conflicts(list_1, list_2):\n+        \"\"\"\n+        Check for relative order conflicts between two lists.\n+        Returns a list of (path1, path2) pairs where the relative order differs between the lists.\n+        \"\"\"\n+        conflicts = []\n+        # Get indices of common elements in both lists\n+        common = set(list_1) & set(list_2)\n+        if not common:\n+            return conflicts\n+        \n+        # For each pair of common elements, compare their relative ordering\n+        common = list(common)\n+        for i, path1 in enumerate(common):\n+            for path2 in common[i + 1:]:\n+                idx1_1, idx1_2 = list_1.index(path1), list_1.index(path2)\n+                idx2_1, idx2_2 = list_2.index(path1), list_2.index(path2)\n+                if (idx1_1 < idx1_2) != (idx2_1 < idx2_2):\n+                    conflicts.append((path1, path2))\n+        return conflicts\n+\n+    @staticmethod\n+    def merge(list_1, list_2):\n+        \"\"\"\n+        Merge two lists while trying to keep the relative order of the elements.\n+        Warn if the lists have the same two elements in a different relative\n+        order.\n+\n+        For static assets it can be important to have them included in the DOM\n+        in a certain order. In JavaScript you may not be able to reference a\n+        global or in CSS you might want to override a style.\n+        \"\"\"\n+        # Check for ordering conflicts\n+        conflicts = Media.check_order_conflicts(list_1, list_2)\n+        if conflicts:\n+            for path1, path2 in conflicts:\n+                warnings.warn(\n+                    'Detected duplicate Media files in an opposite order:\\n'\n+                    '%s\\n%s' % (path1, path2),\n+                    MediaOrderConflictWarning,\n+                )\n+\n+        # Build a new merged list maintaining the relative ordering\n+        seen = set()\n+        merged = []\n+        \n+        # Add all items from list_1, skipping duplicates\n+        for path in list_1:\n+            if path not in seen:\n+                merged.append(path)\n+                seen.add(path)\n+                \n+        # Add remaining items from list_2\n+        for path in list_2:\n+            if path not in seen:\n+                merged.append(path)\n+                seen.add(path)\n+                \n+        return merged\n     def merge(list_1, list_2):\n         \"\"\"\n         Merge two lists while trying to keep the relative order of the elements.\n", "occurrence": 1, "normalized_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex cd0e6f4..9411452 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -62,6 +62,36 @@ class Media:\n             return Media(**{str(name): getattr(self, '_' + name)})\n         raise KeyError('Unknown media type \"%s\"' % name)\n     @staticmethod\n+    def check_order_conflicts(list_1, list_2):\n+        conflicts = []\n+        common = set(list_1) & set(list_2)\n+        if not common:\n+            return conflicts\n+        common = list(common)\n+        for i, path1 in enumerate(common):\n+            for path2 in common[i + 1:]:\n+                idx1_1, idx1_2 = (list_1.index(path1), list_1.index(path2))\n+                idx2_1, idx2_2 = (list_2.index(path1), list_2.index(path2))\n+                if (idx1_1 < idx1_2) != (idx2_1 < idx2_2):\n+                    conflicts.append((path1, path2))\n+        return conflicts\n+    @staticmethod\n+    def merge(list_1, list_2):\n+        conflicts = Media.check_order_conflicts(list_1, list_2)\n+        if conflicts:\n+            for path1, path2 in conflicts:\n+                warnings.warn('Detected duplicate Media files in an opposite order:\\n%s\\n%s' % (path1, path2), MediaOrderConflictWarning)\n+        seen = set()\n+        merged = []\n+        for path in list_1:\n+            if path not in seen:\n+                merged.append(path)\n+                seen.add(path)\n+        for path in list_2:\n+            if path not in seen:\n+                merged.append(path)\n+                seen.add(path)\n+        return merged\n     def merge(list_1, list_2):\n         combined_list = list(list_1)\n         last_insert_index = len(list_1)\n", "normalized_occurrence": 1}
