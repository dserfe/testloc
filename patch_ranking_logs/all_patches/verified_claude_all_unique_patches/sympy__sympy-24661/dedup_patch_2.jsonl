{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-24661", "model_patch": "diff --git a/sympy/core/relational.py b/sympy/core/relational.py\nindex c35b72b..23adbfa 100644\n--- a/sympy/core/relational.py\n+++ b/sympy/core/relational.py\n@@ -816,24 +816,26 @@ class _Inequality(Relational):\n             return NotImplemented\n \n         evaluate = options.pop('evaluate', global_parameters.evaluate)\n-        if evaluate:\n-            for me in (lhs, rhs):\n-                if me.is_extended_real is False:\n-                    raise TypeError(\"Invalid comparison of non-real %s\" % me)\n-                if me is S.NaN:\n-                    raise TypeError(\"Invalid NaN comparison\")\n-            # First we invoke the appropriate inequality method of `lhs`\n-            # (e.g., `lhs.__lt__`).  That method will try to reduce to\n-            # boolean or raise an exception.  It may keep calling\n-            # superclasses until it reaches `Expr` (e.g., `Expr.__lt__`).\n-            # In some cases, `Expr` will just invoke us again (if neither it\n-            # nor a subclass was able to reduce to boolean or raise an\n-            # exception).  In that case, it must call us with\n-            # `evaluate=False` to prevent infinite recursion.\n-            return cls._eval_relation(lhs, rhs, **options)\n-\n-        # make a \"non-evaluated\" Expr for the inequality\n-        return Relational.__new__(cls, lhs, rhs, **options)\n+        \n+        # Check evaluate flag first - if False, return unevaluated\n+        if not evaluate:\n+            return Relational.__new__(cls, lhs, rhs, **options)\n+\n+        # Only perform evaluation if evaluate=True\n+        for me in (lhs, rhs):\n+            if me.is_extended_real is False:\n+                raise TypeError(\"Invalid comparison of non-real %s\" % me)\n+            if me is S.NaN:\n+                raise TypeError(\"Invalid NaN comparison\")\n+        # First we invoke the appropriate inequality method of `lhs`\n+        # (e.g., `lhs.__lt__`).  That method will try to reduce to\n+        # boolean or raise an exception.  It may keep calling\n+        # superclasses until it reaches `Expr` (e.g., `Expr.__lt__`).\n+        # In some cases, `Expr` will just invoke us again (if neither it\n+        # nor a subclass was able to reduce to boolean or raise an\n+        # exception).  In that case, it must call us with\n+        # `evaluate=False` to prevent infinite recursion.\n+        return cls._eval_relation(lhs, rhs, **options)\n \n     @classmethod\n     def _eval_relation(cls, lhs, rhs, **options):\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/relational.py b/sympy/core/relational.py\nindex 6f6b8fe..613a675 100644\n--- a/sympy/core/relational.py\n+++ b/sympy/core/relational.py\n@@ -348,14 +348,14 @@ class _Inequality(Relational):\n         except SympifyError:\n             return NotImplemented\n         evaluate = options.pop('evaluate', global_parameters.evaluate)\n-        if evaluate:\n-            for me in (lhs, rhs):\n-                if me.is_extended_real is False:\n-                    raise TypeError('Invalid comparison of non-real %s' % me)\n-                if me is S.NaN:\n-                    raise TypeError('Invalid NaN comparison')\n-            return cls._eval_relation(lhs, rhs, **options)\n-        return Relational.__new__(cls, lhs, rhs, **options)\n+        if not evaluate:\n+            return Relational.__new__(cls, lhs, rhs, **options)\n+        for me in (lhs, rhs):\n+            if me.is_extended_real is False:\n+                raise TypeError('Invalid comparison of non-real %s' % me)\n+            if me is S.NaN:\n+                raise TypeError('Invalid NaN comparison')\n+        return cls._eval_relation(lhs, rhs, **options)\n     @classmethod\n     def _eval_relation(cls, lhs, rhs, **options):\n         val = cls._eval_fuzzy_relation(lhs, rhs)\n", "normalized_occurrence": 1}
