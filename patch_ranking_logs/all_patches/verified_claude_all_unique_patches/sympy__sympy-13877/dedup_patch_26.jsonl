{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13877", "model_patch": "diff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py\nindex 3216a40..dea66a8 100644\n--- a/sympy/matrices/matrices.py\n+++ b/sympy/matrices/matrices.py\n@@ -162,58 +162,7 @@ class MatrixDeterminant(MatrixCommon):\n         submat, toeplitz = self._eval_berkowitz_toeplitz_matrix()\n         return toeplitz * submat._eval_berkowitz_vector()\n \n-    def _eval_det_bareiss(self):\n-        \"\"\"Compute matrix determinant using Bareiss' fraction-free\n-        algorithm which is an extension of the well known Gaussian\n-        elimination method. This approach is best suited for dense\n-        symbolic matrices and will result in a determinant with\n-        minimal number of fractions. It means that less term\n-        rewriting is needed on resulting formulae.\n-\n-        TODO: Implement algorithm for sparse matrices (SFF),\n-        http://www.eecis.udel.edu/~saunders/papers/sffge/it5.ps.\n-        \"\"\"\n-\n-        # XXX included as a workaround for issue #12362.  Should use `_find_reasonable_pivot` instead\n-        def _find_pivot(l):\n-            for pos,val in enumerate(l):\n-                if val:\n-                    return (pos, val, None, None)\n-            return (None, None, None, None)\n-\n-\n-        # Recursively implemented Bareiss' algorithm as per Deanna Richelle Leggett's\n-        # thesis http://www.math.usm.edu/perry/Research/Thesis_DRL.pdf\n-        def bareiss(mat, cumm=1):\n-            if mat.rows == 0:\n-                return S.One\n-            elif mat.rows == 1:\n-                return mat[0, 0]\n-\n-            # find a pivot and extract the remaining matrix\n-            # XXX should use `_find_reasonable_pivot`.  Blocked by issue #12362\n-            pivot_pos, pivot_val, _, _ = _find_pivot(mat[:, 0])\n-            if pivot_pos == None:\n-                return S.Zero\n-\n-            # if we have a valid pivot, we'll do a \"row swap\", so keep the\n-            # sign of the det\n-            sign = (-1) ** (pivot_pos % 2)\n-\n-            # we want every row but the pivot row and every column\n-            rows = list(i for i in range(mat.rows) if i != pivot_pos)\n-            cols = list(range(mat.cols))\n-            tmp_mat = mat.extract(rows, cols)\n-\n-            def entry(i, j):\n-                ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n-                if not ret.is_Atom:\n-                    cancel(ret)\n-                return ret\n-\n-            return sign*bareiss(self._new(mat.rows - 1, mat.cols - 1, entry), pivot_val)\n \n-        return cancel(bareiss(self))\n \n     def _eval_det_berkowitz(self):\n         \"\"\" Use the Berkowitz algorithm to compute the determinant.\"\"\"\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py\nindex be48f5f..3d9df2e 100644\n--- a/sympy/matrices/matrices.py\n+++ b/sympy/matrices/matrices.py\n@@ -62,31 +62,6 @@ class MatrixDeterminant(MatrixCommon):\n             return self._new(2, 1, [S.One, -self[0, 0]])\n         submat, toeplitz = self._eval_berkowitz_toeplitz_matrix()\n         return toeplitz * submat._eval_berkowitz_vector()\n-    def _eval_det_bareiss(self):\n-        def _find_pivot(l):\n-            for pos, val in enumerate(l):\n-                if val:\n-                    return (pos, val, None, None)\n-            return (None, None, None, None)\n-        def bareiss(mat, cumm=1):\n-            if mat.rows == 0:\n-                return S.One\n-            elif mat.rows == 1:\n-                return mat[0, 0]\n-            pivot_pos, pivot_val, _, _ = _find_pivot(mat[:, 0])\n-            if pivot_pos == None:\n-                return S.Zero\n-            sign = (-1) ** (pivot_pos % 2)\n-            rows = list((i for i in range(mat.rows) if i != pivot_pos))\n-            cols = list(range(mat.cols))\n-            tmp_mat = mat.extract(rows, cols)\n-            def entry(i, j):\n-                ret = (pivot_val * tmp_mat[i, j + 1] - mat[pivot_pos, j + 1] * tmp_mat[i, 0]) / cumm\n-                if not ret.is_Atom:\n-                    cancel(ret)\n-                return ret\n-            return sign * bareiss(self._new(mat.rows - 1, mat.cols - 1, entry), pivot_val)\n-        return cancel(bareiss(self))\n     def _eval_det_berkowitz(self):\n         berk_vector = self._eval_berkowitz_vector()\n         return (-1) ** (len(berk_vector) - 1) * berk_vector[-1]\n", "normalized_occurrence": 1}
