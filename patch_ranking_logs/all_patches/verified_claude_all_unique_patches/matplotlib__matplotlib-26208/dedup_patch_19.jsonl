{"model_name_or_path": "agentless_claude", "instance_id": "matplotlib__matplotlib-26208", "model_patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex f9613d3..bea02c0 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -2310,37 +2310,7 @@ class _AxesBase(martist.Artist):\n         self.stale = True\n         return txt\n \n-    def _update_line_limits(self, line):\n-        \"\"\"\n-        Figures out the data limit of the given line, updating self.dataLim.\n-        \"\"\"\n-        path = line.get_path()\n-        if path.vertices.size == 0:\n-            return\n \n-        line_trf = line.get_transform()\n-\n-        if line_trf == self.transData:\n-            data_path = path\n-        elif any(line_trf.contains_branch_seperately(self.transData)):\n-            # Compute the transform from line coordinates to data coordinates.\n-            trf_to_data = line_trf - self.transData\n-            # If transData is affine we can use the cached non-affine component\n-            # of line's path (since the non-affine part of line_trf is\n-            # entirely encapsulated in trf_to_data).\n-            if self.transData.is_affine:\n-                line_trans_path = line._get_transformed_path()\n-                na_path, _ = line_trans_path.get_transformed_path_and_affine()\n-                data_path = trf_to_data.transform_path_affine(na_path)\n-            else:\n-                data_path = trf_to_data.transform_path(path)\n-        else:\n-            # For backwards compatibility we update the dataLim with the\n-            # coordinate range of the given path, even though the coordinate\n-            # systems are completely different. This may occur in situations\n-            # such as when ax.transAxes is passed through for absolute\n-            # positioning.\n-            data_path = path\n \n         if not data_path.vertices.size:\n             return\n@@ -2353,6 +2323,14 @@ class _AxesBase(martist.Artist):\n                 updatex = False\n             if updatey and line_trf == self.get_xaxis_transform():\n                 updatey = False\n+\n+        # Don't update limits if this is a twinned axis and the line transform\n+        # matches the other axis's transform\n+        if self._twinned_axes:\n+            for twin in self._twinned_axes.get_siblings(self):\n+                if twin is not self and line_trf == twin.transData:\n+                    return\n+\n         self.dataLim.update_from_path(data_path,\n                                       self.ignore_existing_data_limits,\n                                       updatex=updatex, updatey=updatey)\n", "occurrence": 1, "normalized_patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex eb9da84..f9d460f 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -944,23 +944,6 @@ class _AxesBase(martist.Artist):\n         txt._remove_method = self._children.remove\n         self.stale = True\n         return txt\n-    def _update_line_limits(self, line):\n-        path = line.get_path()\n-        if path.vertices.size == 0:\n-            return\n-        line_trf = line.get_transform()\n-        if line_trf == self.transData:\n-            data_path = path\n-        elif any(line_trf.contains_branch_seperately(self.transData)):\n-            trf_to_data = line_trf - self.transData\n-            if self.transData.is_affine:\n-                line_trans_path = line._get_transformed_path()\n-                na_path, _ = line_trans_path.get_transformed_path_and_affine()\n-                data_path = trf_to_data.transform_path_affine(na_path)\n-            else:\n-                data_path = trf_to_data.transform_path(path)\n-        else:\n-            data_path = path\n         if not data_path.vertices.size:\n             return\n         updatex, updatey = line_trf.contains_branch_seperately(self.transData)\n@@ -969,6 +952,10 @@ class _AxesBase(martist.Artist):\n                 updatex = False\n             if updatey and line_trf == self.get_xaxis_transform():\n                 updatey = False\n+        if self._twinned_axes:\n+            for twin in self._twinned_axes.get_siblings(self):\n+                if twin is not self and line_trf == twin.transData:\n+                    return\n         self.dataLim.update_from_path(data_path, self.ignore_existing_data_limits, updatex=updatex, updatey=updatey)\n         self.ignore_existing_data_limits = False\n     def add_patch(self, p):\n", "normalized_occurrence": 1}
