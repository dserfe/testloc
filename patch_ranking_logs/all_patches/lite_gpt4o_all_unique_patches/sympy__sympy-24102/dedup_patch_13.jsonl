{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-24102", "model_patch": "diff --git a/sympy/parsing/mathematica.py b/sympy/parsing/mathematica.py\nindex 3e3bc62..9450d1f 100644\n--- a/sympy/parsing/mathematica.py\n+++ b/sympy/parsing/mathematica.py\n@@ -213,9 +213,9 @@ class MathematicaParser:\n     # Mathematica function name pattern\n     FM_PATTERN = re.compile(r'''\n                 (?:\n-                \\A|(?<=[^a-zA-Z])   # at the top or a non-letter\n+                \\A|(?<=[^\\w])   # at the top or a non-word\n                 )\n-                [A-Z][a-zA-Z\\d]*    # Function\n+                \\w[\\w\\d]*    # Function\n                 (?=\\[)              # [ as a character\n                 ''', re.VERBOSE)\n \n@@ -586,7 +586,7 @@ class MathematicaParser:\n         \"##\": lambda: [\"SlotSequence\", \"1\"],\n     }\n \n-    _literal = r\"[A-Za-z][A-Za-z0-9]*\"\n+    _literal = r\"[\\w][\\w\\d]*\"\n     _number = r\"(?:[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+)\"\n \n     _enclosure_open = [\"(\", \"[\", \"[[\", \"{\"]\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/parsing/mathematica.py b/sympy/parsing/mathematica.py\nindex 957d6fe..6476618 100644\n--- a/sympy/parsing/mathematica.py\n+++ b/sympy/parsing/mathematica.py\n@@ -47,7 +47,7 @@ class MathematicaParser:\n         CORRESPONDENCES.update({fm: fs})\n     REPLACEMENTS = {' ': '', '^': '**', '{': '[', '}': ']'}\n     RULES = {'whitespace': (re.compile('\\n                (?:(?<=[a-zA-Z\\\\d])|(?<=\\\\d\\\\.))     # a letter or a number\\n                \\\\s+                               # any number of whitespaces\\n                (?:(?=[a-zA-Z\\\\d])|(?=\\\\.\\\\d))       # a letter or a number\\n                ', re.VERBOSE), '*'), 'add*_1': (re.compile(\"\\n                (?:(?<=[])\\\\d])|(?<=\\\\d\\\\.))       # ], ) or a number\\n                                                # ''\\n                (?=[(a-zA-Z])                   # ( or a single letter\\n                \", re.VERBOSE), '*'), 'add*_2': (re.compile('\\n                (?<=[a-zA-Z])       # a letter\\n                \\\\(                  # ( as a character\\n                (?=.)               # any characters\\n                ', re.VERBOSE), '*('), 'Pi': (re.compile(\"\\n                (?:\\n                \\\\A|(?<=[^a-zA-Z])\\n                )\\n                Pi                  # 'Pi' is 3.14159... in Mathematica\\n                (?=[^a-zA-Z])\\n                \", re.VERBOSE), 'pi')}\n-    FM_PATTERN = re.compile('\\n                (?:\\n                \\\\A|(?<=[^a-zA-Z])   # at the top or a non-letter\\n                )\\n                [A-Z][a-zA-Z\\\\d]*    # Function\\n                (?=\\\\[)              # [ as a character\\n                ', re.VERBOSE)\n+    FM_PATTERN = re.compile('\\n                (?:\\n                \\\\A|(?<=[^\\\\w])   # at the top or a non-word\\n                )\\n                \\\\w[\\\\w\\\\d]*    # Function\\n                (?=\\\\[)              # [ as a character\\n                ', re.VERBOSE)\n     ARG_MTRX_PATTERN = re.compile('\\n                \\\\{.*\\\\}\\n                ', re.VERBOSE)\n     ARGS_PATTERN_TEMPLATE = '\\n                (?:\\n                \\\\A|(?<=[^a-zA-Z])\\n                )\\n                {arguments}         # model argument like x, y,...\\n                (?=[^a-zA-Z])\\n                '\n     TRANSLATIONS = {}\n@@ -218,7 +218,7 @@ class MathematicaParser:\n     LEFT = 'Left'\n     _mathematica_op_precedence: List[tTuple[str, Optional[str], tDict[str, tUnion[str, Callable]]]] = [(POSTFIX, None, {';': lambda x: x + ['Null'] if isinstance(x, list) and x and (x[0] == 'CompoundExpression') else ['CompoundExpression', x, 'Null']}), (INFIX, FLAT, {';': 'CompoundExpression'}), (INFIX, RIGHT, {'=': 'Set', ':=': 'SetDelayed', '+=': 'AddTo', '-=': 'SubtractFrom', '*=': 'TimesBy', '/=': 'DivideBy'}), (INFIX, LEFT, {'//': lambda x, y: [x, y]}), (POSTFIX, None, {'&': 'Function'}), (INFIX, LEFT, {'/.': 'ReplaceAll'}), (INFIX, RIGHT, {'->': 'Rule', ':>': 'RuleDelayed'}), (INFIX, LEFT, {'/;': 'Condition'}), (INFIX, FLAT, {'|': 'Alternatives'}), (POSTFIX, None, {'..': 'Repeated', '...': 'RepeatedNull'}), (INFIX, FLAT, {'||': 'Or'}), (INFIX, FLAT, {'&&': 'And'}), (PREFIX, None, {'!': 'Not'}), (INFIX, FLAT, {'===': 'SameQ', '=!=': 'UnsameQ'}), (INFIX, FLAT, {'==': 'Equal', '!=': 'Unequal', '<=': 'LessEqual', '<': 'Less', '>=': 'GreaterEqual', '>': 'Greater'}), (INFIX, None, {';;': 'Span'}), (INFIX, FLAT, {'+': 'Plus', '-': 'Plus'}), (INFIX, FLAT, {'*': 'Times', '/': 'Times'}), (INFIX, FLAT, {'.': 'Dot'}), (PREFIX, None, {'-': lambda x: MathematicaParser._get_neg(x), '+': lambda x: x}), (INFIX, RIGHT, {'^': 'Power'}), (INFIX, RIGHT, {'@@': 'Apply', '/@': 'Map', '//@': 'MapAll', '@@@': lambda x, y: ['Apply', x, y, ['List', '1']]}), (POSTFIX, None, {\"'\": 'Derivative', '!': 'Factorial', '!!': 'Factorial2', '--': 'Decrement'}), (INFIX, None, {'[': lambda x, y: [x, *y], '[[': lambda x, y: ['Part', x, *y]}), (PREFIX, None, {'{': lambda x: ['List', *x], '(': lambda x: x[0]}), (INFIX, None, {'?': 'PatternTest'}), (POSTFIX, None, {'_': lambda x: ['Pattern', x, ['Blank']], '_.': lambda x: ['Optional', ['Pattern', x, ['Blank']]], '__': lambda x: ['Pattern', x, ['BlankSequence']], '___': lambda x: ['Pattern', x, ['BlankNullSequence']]}), (INFIX, None, {'_': lambda x, y: ['Pattern', x, ['Blank', y]]}), (PREFIX, None, {'#': 'Slot', '##': 'SlotSequence'})]\n     _missing_arguments_default = {'#': lambda: ['Slot', '1'], '##': lambda: ['SlotSequence', '1']}\n-    _literal = '[A-Za-z][A-Za-z0-9]*'\n+    _literal = '[\\\\w][\\\\w\\\\d]*'\n     _number = '(?:[0-9]+(?:\\\\.[0-9]*)?|\\\\.[0-9]+)'\n     _enclosure_open = ['(', '[', '[[', '{']\n     _enclosure_close = [')', ']', ']]', '}']\n", "normalized_occurrence": 1}
