{"model_name_or_path": "agentless_claude", "instance_id": "astropy__astropy-12907", "model_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex d6e9246..d32a5c2 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -174,6 +174,65 @@ def _coord_matrix(model, pos, noutp):\n \n     The array has a shape (noutp, model.n_inputs).\n \n+    Parameters\n+    ----------\n+    model : `astropy.modeling.Model`\n+        model\n+    pos : str\n+        Position of this model in the expression tree.\n+        One of ['left', 'right'].\n+    noutp : int\n+        Number of outputs of the compound model of which the input model\n+        is a left or right child.\n+\n+    \"\"\"\n+    from astropy.modeling.core import CompoundModel\n+\n+    # Handle compound models recursively\n+    if isinstance(model, CompoundModel):\n+        if model.op == '&':\n+            left_mat = _coord_matrix(model.left, 'left', model.n_outputs)\n+            right_mat = _coord_matrix(model.right, 'right', model.n_outputs)\n+            mat = np.zeros((noutp, model.n_inputs))\n+            if pos == 'left':\n+                mat[:model.n_outputs, :model.n_inputs] = np.hstack([left_mat, right_mat])\n+            else:\n+                mat[-model.n_outputs:, -model.n_inputs:] = np.hstack([left_mat, right_mat])\n+            return mat\n+\n+    if isinstance(model, Mapping):\n+        axes = []\n+        for i in model.mapping:\n+            axis = np.zeros((model.n_inputs,))\n+            axis[i] = 1\n+            axes.append(axis)\n+        m = np.vstack(axes)\n+        mat = np.zeros((noutp, model.n_inputs))\n+        if pos == 'left':\n+            mat[: model.n_outputs, :model.n_inputs] = m\n+        else:\n+            mat[-model.n_outputs:, -model.n_inputs:] = m\n+        return mat\n+    if not model.separable:\n+        # this does not work for more than 2 coordinates\n+        mat = np.zeros((noutp, model.n_inputs))\n+        if pos == 'left':\n+            mat[:model.n_outputs, : model.n_inputs] = 1\n+        else:\n+            mat[-model.n_outputs:, -model.n_inputs:] = 1\n+    else:\n+        mat = np.zeros((noutp, model.n_inputs))\n+\n+        for i in range(model.n_inputs):\n+            mat[i, i] = 1\n+        if pos == 'right':\n+            mat = np.roll(mat, (noutp - model.n_outputs))\n+    return mat\n+    \"\"\"\n+    Create an array representing inputs and outputs of a simple model.\n+\n+    The array has a shape (noutp, model.n_inputs).\n+\n     Parameters\n     ----------\n     model : `astropy.modeling.Model`\n", "occurrence": 1, "normalized_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex 198a838..8b0afe5 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -41,6 +41,43 @@ def _arith_oper(left, right):\n     result = np.ones((left_outputs, left_inputs))\n     return result\n def _coord_matrix(model, pos, noutp):\n+    from astropy.modeling.core import CompoundModel\n+    if isinstance(model, CompoundModel):\n+        if model.op == '&':\n+            left_mat = _coord_matrix(model.left, 'left', model.n_outputs)\n+            right_mat = _coord_matrix(model.right, 'right', model.n_outputs)\n+            mat = np.zeros((noutp, model.n_inputs))\n+            if pos == 'left':\n+                mat[:model.n_outputs, :model.n_inputs] = np.hstack([left_mat, right_mat])\n+            else:\n+                mat[-model.n_outputs:, -model.n_inputs:] = np.hstack([left_mat, right_mat])\n+            return mat\n+    if isinstance(model, Mapping):\n+        axes = []\n+        for i in model.mapping:\n+            axis = np.zeros((model.n_inputs,))\n+            axis[i] = 1\n+            axes.append(axis)\n+        m = np.vstack(axes)\n+        mat = np.zeros((noutp, model.n_inputs))\n+        if pos == 'left':\n+            mat[:model.n_outputs, :model.n_inputs] = m\n+        else:\n+            mat[-model.n_outputs:, -model.n_inputs:] = m\n+        return mat\n+    if not model.separable:\n+        mat = np.zeros((noutp, model.n_inputs))\n+        if pos == 'left':\n+            mat[:model.n_outputs, :model.n_inputs] = 1\n+        else:\n+            mat[-model.n_outputs:, -model.n_inputs:] = 1\n+    else:\n+        mat = np.zeros((noutp, model.n_inputs))\n+        for i in range(model.n_inputs):\n+            mat[i, i] = 1\n+        if pos == 'right':\n+            mat = np.roll(mat, noutp - model.n_outputs)\n+    return mat\n     if isinstance(model, Mapping):\n         axes = []\n         for i in model.mapping:\n", "normalized_occurrence": 1}
