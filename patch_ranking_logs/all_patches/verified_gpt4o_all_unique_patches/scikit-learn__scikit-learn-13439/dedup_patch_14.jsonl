{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13439", "model_patch": "diff --git a/sklearn/pipeline.py b/sklearn/pipeline.py\nindex 4594f40..d030b50 100644\n--- a/sklearn/pipeline.py\n+++ b/sklearn/pipeline.py\n@@ -348,6 +348,10 @@ class Pipeline(_BaseComposition):\n         else:\n             return last_step.fit(Xt, y, **fit_params).transform(Xt)\n \n+    def __len__(self):\n+        \"\"\"Return the number of steps in the pipeline.\"\"\"\n+        return len(self.steps)\n+\n     @if_delegate_has_method(delegate='_final_estimator')\n     def predict(self, X, **predict_params):\n         \"\"\"Apply transforms to the data, and predict with the final estimator\n@@ -375,6 +379,10 @@ class Pipeline(_BaseComposition):\n             Xt = transform.transform(Xt)\n         return self.steps[-1][-1].predict(Xt, **predict_params)\n \n+    def __len__(self):\n+        \"\"\"Return the number of steps in the pipeline.\"\"\"\n+        return len(self.steps)\n+\n     @if_delegate_has_method(delegate='_final_estimator')\n     def fit_predict(self, X, y=None, **fit_params):\n         \"\"\"Applies fit_predict of last step in pipeline after transforms.\n@@ -405,6 +413,10 @@ class Pipeline(_BaseComposition):\n         Xt, fit_params = self._fit(X, y, **fit_params)\n         return self.steps[-1][-1].fit_predict(Xt, y, **fit_params)\n \n+    def __len__(self):\n+        \"\"\"Return the number of steps in the pipeline.\"\"\"\n+        return len(self.steps)\n+\n     @if_delegate_has_method(delegate='_final_estimator')\n     def predict_proba(self, X):\n         \"\"\"Apply transforms, and predict_proba of the final estimator\n@@ -424,6 +436,10 @@ class Pipeline(_BaseComposition):\n             Xt = transform.transform(Xt)\n         return self.steps[-1][-1].predict_proba(Xt)\n \n+    def __len__(self):\n+        \"\"\"Return the number of steps in the pipeline.\"\"\"\n+        return len(self.steps)\n+\n     @if_delegate_has_method(delegate='_final_estimator')\n     def decision_function(self, X):\n         \"\"\"Apply transforms, and decision_function of the final estimator\n@@ -443,6 +459,10 @@ class Pipeline(_BaseComposition):\n             Xt = transform.transform(Xt)\n         return self.steps[-1][-1].decision_function(Xt)\n \n+    def __len__(self):\n+        \"\"\"Return the number of steps in the pipeline.\"\"\"\n+        return len(self.steps)\n+\n     @if_delegate_has_method(delegate='_final_estimator')\n     def predict_log_proba(self, X):\n         \"\"\"Apply transforms, and predict_log_proba of the final estimator\n@@ -522,6 +542,10 @@ class Pipeline(_BaseComposition):\n             Xt = transform.inverse_transform(Xt)\n         return Xt\n \n+    def __len__(self):\n+        \"\"\"Return the number of steps in the pipeline.\"\"\"\n+        return len(self.steps)\n+\n     @if_delegate_has_method(delegate='_final_estimator')\n     def score(self, X, y=None, sample_weight=None):\n         \"\"\"Apply transforms, and score with the final estimator\n", "occurrence": 1, "normalized_patch": "--- a/sklearn/pipeline.py\n+++ b/sklearn/pipeline.py\n+    def __len__(self):\n+        return len(self.steps)\n+    def __len__(self):\n+        return len(self.steps)\n+    def __len__(self):\n+        return len(self.steps)\n+    def __len__(self):\n+        return len(self.steps)\n+    def __len__(self):\n+        return len(self.steps)\n+    def __len__(self):\n+        return len(self.steps)", "normalized_occurrence": 2}
