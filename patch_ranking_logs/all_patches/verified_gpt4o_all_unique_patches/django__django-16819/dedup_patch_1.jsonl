{"model_name_or_path": "agentless", "instance_id": "django__django-16819", "model_patch": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 7088737..add836f 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -808,58 +808,10 @@ class IndexOperation(Operation):\n         return self.model_name.lower()\n \n \n-class AddIndex(IndexOperation):\n-    \"\"\"Add an index on a model.\"\"\"\n-\n-    def __init__(self, model_name, index):\n-        self.model_name = model_name\n-        if not index.name:\n-            raise ValueError(\n-                \"Indexes passed to AddIndex operations require a name \"\n-                \"argument. %r doesn't have one.\" % index\n-            )\n-        self.index = index\n-\n-    def state_forwards(self, app_label, state):\n-        state.add_index(app_label, self.model_name_lower, self.index)\n-\n-    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n-        model = to_state.apps.get_model(app_label, self.model_name)\n-        if self.allow_migrate_model(schema_editor.connection.alias, model):\n-            schema_editor.add_index(model, self.index)\n-\n-    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n-        model = from_state.apps.get_model(app_label, self.model_name)\n-        if self.allow_migrate_model(schema_editor.connection.alias, model):\n-            schema_editor.remove_index(model, self.index)\n-\n-    def deconstruct(self):\n-        kwargs = {\n-            \"model_name\": self.model_name,\n-            \"index\": self.index,\n-        }\n-        return (\n-            self.__class__.__qualname__,\n-            [],\n-            kwargs,\n-        )\n-\n-    def describe(self):\n-        if self.index.expressions:\n-            return \"Create index %s on %s on model %s\" % (\n-                self.index.name,\n-                \", \".join([str(expression) for expression in self.index.expressions]),\n-                self.model_name,\n-            )\n-        return \"Create index %s on field(s) %s of model %s\" % (\n-            self.index.name,\n-            \", \".join(self.index.fields),\n-            self.model_name,\n-        )\n-\n-    @property\n-    def migration_name_fragment(self):\n-        return \"%s_%s\" % (self.model_name_lower, self.index.name.lower())\n+    def reduce(self, operation, app_label):\n+        if isinstance(operation, RemoveIndex) and self.model_name_lower == operation.model_name_lower and self.index.name == operation.name:\n+            return []\n+        return super().reduce(operation, app_label)\n \n \n class RemoveIndex(IndexOperation):\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex d617523..a513cbb 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -350,32 +350,10 @@ class IndexOperation(Operation):\n     @cached_property\n     def model_name_lower(self):\n         return self.model_name.lower()\n-class AddIndex(IndexOperation):\n-    def __init__(self, model_name, index):\n-        self.model_name = model_name\n-        if not index.name:\n-            raise ValueError(\"Indexes passed to AddIndex operations require a name argument. %r doesn't have one.\" % index)\n-        self.index = index\n-    def state_forwards(self, app_label, state):\n-        state.add_index(app_label, self.model_name_lower, self.index)\n-    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n-        model = to_state.apps.get_model(app_label, self.model_name)\n-        if self.allow_migrate_model(schema_editor.connection.alias, model):\n-            schema_editor.add_index(model, self.index)\n-    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n-        model = from_state.apps.get_model(app_label, self.model_name)\n-        if self.allow_migrate_model(schema_editor.connection.alias, model):\n-            schema_editor.remove_index(model, self.index)\n-    def deconstruct(self):\n-        kwargs = {'model_name': self.model_name, 'index': self.index}\n-        return (self.__class__.__qualname__, [], kwargs)\n-    def describe(self):\n-        if self.index.expressions:\n-            return 'Create index %s on %s on model %s' % (self.index.name, ', '.join([str(expression) for expression in self.index.expressions]), self.model_name)\n-        return 'Create index %s on field(s) %s of model %s' % (self.index.name, ', '.join(self.index.fields), self.model_name)\n-    @property\n-    def migration_name_fragment(self):\n-        return '%s_%s' % (self.model_name_lower, self.index.name.lower())\n+    def reduce(self, operation, app_label):\n+        if isinstance(operation, RemoveIndex) and self.model_name_lower == operation.model_name_lower and (self.index.name == operation.name):\n+            return []\n+        return super().reduce(operation, app_label)\n class RemoveIndex(IndexOperation):\n     def __init__(self, model_name, name):\n         self.model_name = model_name\n", "normalized_occurrence": 1}
