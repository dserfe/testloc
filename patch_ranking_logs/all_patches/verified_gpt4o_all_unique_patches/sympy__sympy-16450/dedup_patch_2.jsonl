{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-16450", "model_patch": "diff --git a/sympy/core/assumptions.py b/sympy/core/assumptions.py\nindex 6a94adc..cfe3bfb 100644\n--- a/sympy/core/assumptions.py\n+++ b/sympy/core/assumptions.py\n@@ -252,6 +252,8 @@ def make_property(fact):\n \n \n def _ask(fact, obj):\n+    if fact == 'finite' and 'finite' in obj._assumptions:\n+        return obj._assumptions['finite']\n     \"\"\"\n     Find the truth value for a property of an object.\n \n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/assumptions.py b/sympy/core/assumptions.py\nindex cf551fe..63ce759 100644\n--- a/sympy/core/assumptions.py\n+++ b/sympy/core/assumptions.py\n@@ -36,6 +36,9 @@ def make_property(fact):\n     getit.func_name = as_property(fact)\n     return property(getit)\n def _ask(fact, obj):\n+    if fact == 'finite' and 'finite' in obj._assumptions:\n+        return obj._assumptions['finite']\n+    \"\\n    Find the truth value for a property of an object.\\n\\n    This function is called when a request is made to see what a fact\\n    value is.\\n\\n    For this we use several techniques:\\n\\n    First, the fact-evaluation function is tried, if it exists (for\\n    example _eval_is_integer). Then we try related facts. For example\\n\\n        rational   -->   integer\\n\\n    another example is joined rule:\\n\\n        integer & !odd  --> even\\n\\n    so in the latter case if we are looking at what 'even' value is,\\n    'integer' and 'odd' facts will be asked.\\n\\n    In all cases, when we settle on some fact value, its implications are\\n    deduced, and the result is cached in ._assumptions.\\n    \"\n     assumptions = obj._assumptions\n     handler_map = obj._prop_handler\n     assumptions._tell(fact, None)\n", "normalized_occurrence": 1}
