{"model_name_or_path": "agentless", "instance_id": "django__django-13212", "model_patch": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 1b74a94..c3a28ce 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -48,7 +48,7 @@ class RegexValidator:\n         regex_matches = self.regex.search(str(value))\n         invalid_input = regex_matches if self.inverse_match else not regex_matches\n         if invalid_input:\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message % {'value': value}, code=self.code)\n \n     def __eq__(self, other):\n         return (\n@@ -100,11 +100,11 @@ class URLValidator(RegexValidator):\n \n     def __call__(self, value):\n         if not isinstance(value, str):\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message % {'value': value}, code=self.code)\n         # Check if the scheme is valid.\n         scheme = value.split('://')[0].lower()\n         if scheme not in self.schemes:\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message % {'value': value}, code=self.code)\n \n         # Then check full URL\n         try:\n@@ -139,7 +139,7 @@ class URLValidator(RegexValidator):\n         # one byte for the length of the name and one byte for the trailing dot\n         # that's used to indicate absolute names in DNS.\n         if len(urlsplit(value).netloc) > 253:\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message % {'value': value}, code=self.code)\n \n \n integer_validator = RegexValidator(\n@@ -208,12 +208,12 @@ class EmailValidator:\n \n     def __call__(self, value):\n         if not value or '@' not in value:\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message % {'value': value}, code=self.code)\n \n         user_part, domain_part = value.rsplit('@', 1)\n \n         if not self.user_regex.match(user_part):\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message % {'value': value}, code=self.code)\n \n         if (domain_part not in self.domain_allowlist and\n                 not self.validate_domain_part(domain_part)):\n@@ -225,7 +225,7 @@ class EmailValidator:\n             else:\n                 if self.validate_domain_part(domain_part):\n                     return\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message % {'value': value}, code=self.code)\n \n     def validate_domain_part(self, domain_part):\n         if self.domain_regex.match(domain_part):\n@@ -550,7 +550,7 @@ class ProhibitNullCharactersValidator:\n \n     def __call__(self, value):\n         if '\\x00' in str(value):\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message % {'value': value}, code=self.code)\n \n     def __eq__(self, other):\n         return (\n", "occurrence": 4, "normalized_patch": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 7587523..af02c97 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -36,7 +36,7 @@ class RegexValidator:\n         regex_matches = self.regex.search(str(value))\n         invalid_input = regex_matches if self.inverse_match else not regex_matches\n         if invalid_input:\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message % {'value': value}, code=self.code)\n     def __eq__(self, other):\n         return isinstance(other, RegexValidator) and self.regex.pattern == other.regex.pattern and (self.regex.flags == other.regex.flags) and (self.message == other.message) and (self.code == other.code) and (self.inverse_match == other.inverse_match)\n @deconstructible\n@@ -57,10 +57,10 @@ class URLValidator(RegexValidator):\n             self.schemes = schemes\n     def __call__(self, value):\n         if not isinstance(value, str):\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message % {'value': value}, code=self.code)\n         scheme = value.split('://')[0].lower()\n         if scheme not in self.schemes:\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message % {'value': value}, code=self.code)\n         try:\n             super().__call__(value)\n         except ValidationError as e:\n@@ -86,7 +86,7 @@ class URLValidator(RegexValidator):\n                 except ValidationError:\n                     raise ValidationError(self.message, code=self.code)\n         if len(urlsplit(value).netloc) > 253:\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message % {'value': value}, code=self.code)\n integer_validator = RegexValidator(_lazy_re_compile('^-?\\\\d+\\\\Z'), message=_('Enter a valid integer.'), code='invalid')\n def validate_integer(value):\n     return integer_validator(value)\n@@ -118,10 +118,10 @@ class EmailValidator:\n             self.domain_allowlist = allowlist\n     def __call__(self, value):\n         if not value or '@' not in value:\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message % {'value': value}, code=self.code)\n         user_part, domain_part = value.rsplit('@', 1)\n         if not self.user_regex.match(user_part):\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message % {'value': value}, code=self.code)\n         if domain_part not in self.domain_allowlist and (not self.validate_domain_part(domain_part)):\n             try:\n                 domain_part = punycode(domain_part)\n@@ -130,7 +130,7 @@ class EmailValidator:\n             else:\n                 if self.validate_domain_part(domain_part):\n                     return\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message % {'value': value}, code=self.code)\n     def validate_domain_part(self, domain_part):\n         if self.domain_regex.match(domain_part):\n             return True\n@@ -294,6 +294,6 @@ class ProhibitNullCharactersValidator:\n             self.code = code\n     def __call__(self, value):\n         if '\\x00' in str(value):\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message % {'value': value}, code=self.code)\n     def __eq__(self, other):\n         return isinstance(other, self.__class__) and self.message == other.message and (self.code == other.code)\n\\ No newline at end of file\n", "normalized_occurrence": 4}
