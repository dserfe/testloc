{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-9288", "model_patch": "diff --git a/sklearn/cluster/k_means_.py b/sklearn/cluster/k_means_.py\nindex 915d041..d3eb8db 100644\n--- a/sklearn/cluster/k_means_.py\n+++ b/sklearn/cluster/k_means_.py\n@@ -388,13 +388,14 @@ def k_means(X, n_clusters, sample_weight=None, init='k-means++',\n                                    # Change seed to ensure variety\n                                    random_state=seed)\n             for seed in seeds)\n-        # Get results with the lowest inertia\n-        labels, inertia, centers, n_iters = zip(*results)\n-        best = np.argmin(inertia)\n-        best_labels = labels[best]\n-        best_inertia = inertia[best]\n-        best_centers = centers[best]\n-        best_n_iter = n_iters[best]\n+        # Ensure numerical consistency by reducing the results in a deterministic order\n+        best_labels, best_inertia, best_centers, best_n_iter = None, None, None, None\n+        for labels, inertia, centers, n_iter in results:\n+            if best_inertia is None or inertia < best_inertia:\n+                best_labels = labels\n+                best_inertia = inertia\n+                best_centers = centers\n+                best_n_iter = n_iter\n \n     if not sp.issparse(X):\n         if not copy_x:\n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/cluster/k_means_.py b/sklearn/cluster/k_means_.py\nindex abcc315..24a67a5 100644\n--- a/sklearn/cluster/k_means_.py\n+++ b/sklearn/cluster/k_means_.py\n@@ -117,12 +117,13 @@ def k_means(X, n_clusters, sample_weight=None, init='k-means++', precompute_dist\n     else:\n         seeds = random_state.randint(np.iinfo(np.int32).max, size=n_init)\n         results = Parallel(n_jobs=n_jobs, verbose=0)((delayed(kmeans_single)(X, sample_weight, n_clusters, max_iter=max_iter, init=init, verbose=verbose, tol=tol, precompute_distances=precompute_distances, x_squared_norms=x_squared_norms, random_state=seed) for seed in seeds))\n-        labels, inertia, centers, n_iters = zip(*results)\n-        best = np.argmin(inertia)\n-        best_labels = labels[best]\n-        best_inertia = inertia[best]\n-        best_centers = centers[best]\n-        best_n_iter = n_iters[best]\n+        best_labels, best_inertia, best_centers, best_n_iter = (None, None, None, None)\n+        for labels, inertia, centers, n_iter in results:\n+            if best_inertia is None or inertia < best_inertia:\n+                best_labels = labels\n+                best_inertia = inertia\n+                best_centers = centers\n+                best_n_iter = n_iter\n     if not sp.issparse(X):\n         if not copy_x:\n             X += X_mean\n", "normalized_occurrence": 1}
