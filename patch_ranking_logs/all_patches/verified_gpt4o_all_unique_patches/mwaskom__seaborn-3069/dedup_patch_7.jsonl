{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3069", "model_patch": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 1e10d58..6d2f23c 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -133,6 +133,66 @@ class Scale:\n \n         return Identity()\n \n+@dataclass\n+class Nominal(Scale):\n+    \"\"\"\n+    A categorical scale without relative importance / magnitude.\n+    \"\"\"\n+    values: tuple | str | list | dict | None = None\n+    order: list | None = None\n+\n+    _priority: ClassVar[int] = 3\n+\n+    def _setup(\n+        self, data: Series, prop: Property, axis: Axis | None = None,\n+    ) -> Scale:\n+\n+        new = copy(self)\n+        if new._tick_params is None:\n+            new = new.tick()\n+        if new._label_params is None:\n+            new = new.label()\n+\n+        stringify = np.vectorize(format)\n+        units_seed = categorical_order(data, new.order)\n+\n+        class CatScale(mpl.scale.LinearScale):\n+            name = None  # To work around mpl<3.4 compat issues\n+\n+            def set_default_locators_and_formatters(self, axis):\n+                ...\n+\n+        mpl_scale = CatScale(data.name)\n+        if axis is None:\n+            axis = PseudoAxis(mpl_scale)\n+            # Set view interval with same margin logic as categorical axis\n+            axis.set_view_interval(-0.5, len(units_seed) - 0.5)\n+\n+        new._matplotlib_scale = mpl_scale\n+\n+        axis.update_units(stringify(np.array(units_seed)))\n+\n+        def convert_units(x):\n+            keep = np.array([x_ in units_seed for x_ in x], bool)\n+            out = np.full(len(x), np.nan)\n+            out[keep] = axis.convert_units(stringify(x[keep]))\n+            return out\n+\n+        new._pipeline = [\n+            convert_units,\n+            prop.get_mapping(new, data),\n+        ]\n+\n+        def spacer(x):\n+            return 1\n+\n+        new._spacer = spacer\n+\n+        if prop.legend:\n+            new._legend = units_seed, list(stringify(units_seed))\n+\n+        return new\n+\n \n @dataclass\n class Nominal(Scale):\n", "occurrence": 1, "normalized_patch": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 58a2cdb..7c14a0d 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -75,6 +75,41 @@ class Scale:\n             _matplotlib_scale = None\n         return Identity()\n @dataclass\n+class Nominal(Scale):\n+    values: tuple | str | list | dict | None = None\n+    order: list | None = None\n+    _priority: ClassVar[int] = 3\n+    def _setup(self, data: Series, prop: Property, axis: Axis | None=None) -> Scale:\n+        new = copy(self)\n+        if new._tick_params is None:\n+            new = new.tick()\n+        if new._label_params is None:\n+            new = new.label()\n+        stringify = np.vectorize(format)\n+        units_seed = categorical_order(data, new.order)\n+        class CatScale(mpl.scale.LinearScale):\n+            name = None\n+            def set_default_locators_and_formatters(self, axis):\n+                ...\n+        mpl_scale = CatScale(data.name)\n+        if axis is None:\n+            axis = PseudoAxis(mpl_scale)\n+            axis.set_view_interval(-0.5, len(units_seed) - 0.5)\n+        new._matplotlib_scale = mpl_scale\n+        axis.update_units(stringify(np.array(units_seed)))\n+        def convert_units(x):\n+            keep = np.array([x_ in units_seed for x_ in x], bool)\n+            out = np.full(len(x), np.nan)\n+            out[keep] = axis.convert_units(stringify(x[keep]))\n+            return out\n+        new._pipeline = [convert_units, prop.get_mapping(new, data)]\n+        def spacer(x):\n+            return 1\n+        new._spacer = spacer\n+        if prop.legend:\n+            new._legend = (units_seed, list(stringify(units_seed)))\n+        return new\n+@dataclass\n class Nominal(Scale):\n     values: tuple | str | list | dict | None = None\n     order: list | None = None\n", "normalized_occurrence": 1}
