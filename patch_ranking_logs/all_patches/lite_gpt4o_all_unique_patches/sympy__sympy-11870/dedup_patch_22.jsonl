{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-11870", "model_patch": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex bd243c1..8d1e2ff 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -586,7 +586,23 @@ def exptrigsimp(expr):\n                     newd[1 + sign*S.Exp1**x] += m\n                     newd[c] += m\n \n-        return Mul(*[k**newd[k] for k in newd])\n+        result = Mul(*[k**newd[k] for k in newd])\n+        \n+        # Special handling for sinc\n+        if result.has(I):\n+            result_terms = Add.make_args(result)\n+            for term in result_terms:\n+                if term.is_Mul:\n+                    coeff, exp_term = term.as_coeff_Mul()\n+                    if I in term.free_symbols and exp_term.has(exp):\n+                        base, exponent = exp_term.as_base_exp()\n+                        if base == exp(1) and exponent.has(I):\n+                            arg = exponent.as_coeff_Mul()[0]\n+                            if len(result_terms) == 1:\n+                                return sin(arg)\n+                            else:\n+                                return sin(arg) / arg\n+        return result\n     newexpr = bottom_up(newexpr, f)\n \n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 8c4936d..6d9f5ef 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -221,7 +221,21 @@ def exptrigsimp(expr):\n                 else:\n                     newd[1 + sign * S.Exp1 ** x] += m\n                     newd[c] += m\n-        return Mul(*[k ** newd[k] for k in newd])\n+        result = Mul(*[k ** newd[k] for k in newd])\n+        if result.has(I):\n+            result_terms = Add.make_args(result)\n+            for term in result_terms:\n+                if term.is_Mul:\n+                    coeff, exp_term = term.as_coeff_Mul()\n+                    if I in term.free_symbols and exp_term.has(exp):\n+                        base, exponent = exp_term.as_base_exp()\n+                        if base == exp(1) and exponent.has(I):\n+                            arg = exponent.as_coeff_Mul()[0]\n+                            if len(result_terms) == 1:\n+                                return sin(arg)\n+                            else:\n+                                return sin(arg) / arg\n+        return result\n     newexpr = bottom_up(newexpr, f)\n     if newexpr.has(HyperbolicFunction):\n         e, f = hyper_as_trig(newexpr)\n", "normalized_occurrence": 1}
