{"model_name_or_path": "agentless_claude", "instance_id": "sphinx-doc__sphinx-8638", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex ec7a051..d8be68f 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -782,6 +782,10 @@ class PyAttribute(PyObject):\n     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n         fullname, prefix = super().handle_signature(sig, signode)\n \n+        # Ensure the attribute is properly scoped to its containing class\n+        if '.' in fullname:\n+            signode['is_class_attr'] = True\n+\n         typ = self.options.get('type')\n         if typ:\n             annotations = _parse_annotation(typ, self.env)\n@@ -791,6 +795,7 @@ class PyAttribute(PyObject):\n         if value:\n             signode += addnodes.desc_annotation(value, ' = ' + value)\n \n+        # Return the fully qualified name to prevent cross-scope linking\n         return fullname, prefix\n \n     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n@@ -799,14 +804,14 @@ class PyAttribute(PyObject):\n             clsname, attrname = name.rsplit('.', 1)\n             if modname and self.env.config.add_module_names:\n                 clsname = '.'.join([modname, clsname])\n+            # Include full qualified path in the index text to maintain proper scoping\n+            return _('%s (%s.%s attribute)') % (attrname, modname, clsname)\n         except ValueError:\n             if modname:\n                 return _('%s (in module %s)') % (name, modname)\n             else:\n                 return name\n \n-        return _('%s (%s attribute)') % (attrname, clsname)\n-\n \n class PyDecoratorMixin:\n     \"\"\"\n", "occurrence": 1, "normalized_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 06b9e34..d7b4c7a 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -480,6 +480,8 @@ class PyAttribute(PyObject):\n     option_spec.update({'type': directives.unchanged, 'value': directives.unchanged})\n     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n         fullname, prefix = super().handle_signature(sig, signode)\n+        if '.' in fullname:\n+            signode['is_class_attr'] = True\n         typ = self.options.get('type')\n         if typ:\n             annotations = _parse_annotation(typ, self.env)\n@@ -494,12 +496,12 @@ class PyAttribute(PyObject):\n             clsname, attrname = name.rsplit('.', 1)\n             if modname and self.env.config.add_module_names:\n                 clsname = '.'.join([modname, clsname])\n+            return _('%s (%s.%s attribute)') % (attrname, modname, clsname)\n         except ValueError:\n             if modname:\n                 return _('%s (in module %s)') % (name, modname)\n             else:\n                 return name\n-        return _('%s (%s attribute)') % (attrname, clsname)\n class PyDecoratorMixin:\n     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n         for cls in self.__class__.__mro__:\n", "normalized_occurrence": 1}
