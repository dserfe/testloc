{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-7571", "model_patch": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex 16efd55..401550b 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -346,13 +346,15 @@ class LogCaptureFixture:\n         self._item = item\n         # dict of log name -> log level\n         self._initial_logger_levels = {}  # type: Dict[Optional[str], int]\n+        self._initial_handler_level = self.handler.level\n \n     def _finalize(self) -> None:\n         \"\"\"Finalizes the fixture.\n \n         This restores the log levels changed by :meth:`set_level`.\n         \"\"\"\n-        # restore log levels\n+        # restore handler level\n+        self.handler.setLevel(self._initial_handler_level)\n         for logger_name, level in self._initial_logger_levels.items():\n             logger = logging.getLogger(logger_name)\n             logger.setLevel(level)\n@@ -419,7 +421,11 @@ class LogCaptureFixture:\n         \"\"\"Reset the list of log records and the captured log text.\"\"\"\n         self.handler.reset()\n \n-    def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n+        # restore handler level\n+        self.handler.setLevel(self._initial_handler_level)\n+        for logger_name, level in self._initial_logger_levels.items():\n+            logger = logging.getLogger(logger_name)\n+            logger.setLevel(level)\n         \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value at the end of\n         the test.\n \n", "occurrence": 1, "normalized_patch": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex 862b163..d7959b1 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -164,7 +164,9 @@ class LogCaptureFixture:\n     def __init__(self, item: nodes.Node) -> None:\n         self._item = item\n         self._initial_logger_levels = {}\n+        self._initial_handler_level = self.handler.level\n     def _finalize(self) -> None:\n+        self.handler.setLevel(self._initial_handler_level)\n         for logger_name, level in self._initial_logger_levels.items():\n             logger = logging.getLogger(logger_name)\n             logger.setLevel(level)\n@@ -187,7 +189,11 @@ class LogCaptureFixture:\n         return [r.getMessage() for r in self.records]\n     def clear(self) -> None:\n         self.handler.reset()\n-    def set_level(self, level: Union[int, str], logger: Optional[str]=None) -> None:\n+        self.handler.setLevel(self._initial_handler_level)\n+        for logger_name, level in self._initial_logger_levels.items():\n+            logger = logging.getLogger(logger_name)\n+            logger.setLevel(level)\n+        'Sets the level for capturing of logs. The level will be restored to its previous value at the end of\\n        the test.\\n\\n        :param int level: the logger to level.\\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\\n\\n        .. versionchanged:: 3.4\\n            The levels of the loggers changed by this function will be restored to their initial values at the\\n            end of the test.\\n        '\n         logger_obj = logging.getLogger(logger)\n         self._initial_logger_levels.setdefault(logger, logger_obj.level)\n         logger_obj.setLevel(level)\n", "normalized_occurrence": 1}
