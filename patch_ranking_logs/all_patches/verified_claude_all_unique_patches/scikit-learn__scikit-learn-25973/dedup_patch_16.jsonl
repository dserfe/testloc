{"model_name_or_path": "agentless_claude", "instance_id": "scikit-learn__scikit-learn-25973", "model_patch": "diff --git a/sklearn/feature_selection/_sequential.py b/sklearn/feature_selection/_sequential.py\nindex 2854ca5..a983cbb 100644\n--- a/sklearn/feature_selection/_sequential.py\n+++ b/sklearn/feature_selection/_sequential.py\n@@ -291,30 +291,7 @@ class SequentialFeatureSelector(SelectorMixin, MetaEstimatorMixin, BaseEstimator\n \n         return self\n \n-    def _get_best_new_feature_score(self, estimator, X, y, current_mask):\n-        # Return the best new feature and its score to add to the current_mask,\n-        # i.e. return the best new feature and its score to add (resp. remove)\n-        # when doing forward selection (resp. backward selection).\n-        # Feature will be added if the current score and past score are greater\n-        # than tol when n_feature is auto,\n-        candidate_feature_indices = np.flatnonzero(~current_mask)\n-        scores = {}\n-        for feature_idx in candidate_feature_indices:\n-            candidate_mask = current_mask.copy()\n-            candidate_mask[feature_idx] = True\n-            if self.direction == \"backward\":\n-                candidate_mask = ~candidate_mask\n-            X_new = X[:, candidate_mask]\n-            scores[feature_idx] = cross_val_score(\n-                estimator,\n-                X_new,\n-                y,\n-                cv=self.cv,\n-                scoring=self.scoring,\n-                n_jobs=self.n_jobs,\n-            ).mean()\n-        new_feature_idx = max(scores, key=lambda feature_idx: scores[feature_idx])\n-        return new_feature_idx, scores[new_feature_idx]\n+\n \n     def _get_support_mask(self):\n         check_is_fitted(self)\n@@ -323,4 +300,4 @@ class SequentialFeatureSelector(SelectorMixin, MetaEstimatorMixin, BaseEstimator\n     def _more_tags(self):\n         return {\n             \"allow_nan\": _safe_tags(self.estimator, key=\"allow_nan\"),\n-        }\n+        }\n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/feature_selection/_sequential.py b/sklearn/feature_selection/_sequential.py\nindex f5583ad..98db1b0 100644\n--- a/sklearn/feature_selection/_sequential.py\n+++ b/sklearn/feature_selection/_sequential.py\n@@ -60,18 +60,6 @@ class SequentialFeatureSelector(SelectorMixin, MetaEstimatorMixin, BaseEstimator\n         self.support_ = current_mask\n         self.n_features_to_select_ = self.support_.sum()\n         return self\n-    def _get_best_new_feature_score(self, estimator, X, y, current_mask):\n-        candidate_feature_indices = np.flatnonzero(~current_mask)\n-        scores = {}\n-        for feature_idx in candidate_feature_indices:\n-            candidate_mask = current_mask.copy()\n-            candidate_mask[feature_idx] = True\n-            if self.direction == 'backward':\n-                candidate_mask = ~candidate_mask\n-            X_new = X[:, candidate_mask]\n-            scores[feature_idx] = cross_val_score(estimator, X_new, y, cv=self.cv, scoring=self.scoring, n_jobs=self.n_jobs).mean()\n-        new_feature_idx = max(scores, key=lambda feature_idx: scores[feature_idx])\n-        return (new_feature_idx, scores[new_feature_idx])\n     def _get_support_mask(self):\n         check_is_fitted(self)\n         return self.support_\n", "normalized_occurrence": 1}
