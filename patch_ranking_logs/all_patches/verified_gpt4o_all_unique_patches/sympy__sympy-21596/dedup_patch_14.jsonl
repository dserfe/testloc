{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-21596", "model_patch": "diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex 78d756e..7378f83 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -132,7 +132,12 @@ class Set(Basic, EvalfMixin):\n         EmptySet\n \n         \"\"\"\n-        return Intersection(self, other)\n+        intersection = Intersection(self, other)\n+        if isinstance(self, imageset):\n+            if isinstance(other, Reals):\n+                new_elements = [elem for elem in self if elem.is_real]\n+                return FiniteSet(*new_elements)\n+        return intersection\n \n     def intersection(self, other):\n         \"\"\"\n@@ -331,11 +336,15 @@ class Set(Basic, EvalfMixin):\n         if isinstance(c, Contains):\n             return c\n         if c is None:\n-            return Contains(other, self, evaluate=False)\n-        b = tfn[c]\n-        if b is None:\n-            return c\n-        return b\n+            if isinstance(other, ComplexNumber) and other.is_real:\n+                c = False\n+            else:\n+                return Contains(other, self, evaluate=False)\n+        else:\n+            b = tfn[c]\n+            if b is None:\n+                return c\n+            return b\n \n     def _contains(self, other):\n         raise NotImplementedError(filldedent('''\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex 09f6d6f..553a214 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -54,7 +54,12 @@ class Set(Basic, EvalfMixin):\n     def union(self, other):\n         return Union(self, other)\n     def intersect(self, other):\n-        return Intersection(self, other)\n+        intersection = Intersection(self, other)\n+        if isinstance(self, imageset):\n+            if isinstance(other, Reals):\n+                new_elements = [elem for elem in self if elem.is_real]\n+                return FiniteSet(*new_elements)\n+        return intersection\n     def intersection(self, other):\n         return self.intersect(other)\n     def is_disjoint(self, other):\n@@ -108,11 +113,15 @@ class Set(Basic, EvalfMixin):\n         if isinstance(c, Contains):\n             return c\n         if c is None:\n-            return Contains(other, self, evaluate=False)\n-        b = tfn[c]\n-        if b is None:\n-            return c\n-        return b\n+            if isinstance(other, ComplexNumber) and other.is_real:\n+                c = False\n+            else:\n+                return Contains(other, self, evaluate=False)\n+        else:\n+            b = tfn[c]\n+            if b is None:\n+                return c\n+            return b\n     def _contains(self, other):\n         raise NotImplementedError(filldedent('\\n            (%s)._contains(%s) is not defined. This method, when\\n            defined, will receive a sympified object. The method\\n            should return True, False, None or something that\\n            expresses what must be true for the containment of that\\n            object in self to be evaluated. If None is returned\\n            then a generic Contains object will be returned\\n            by the ``contains`` method.' % (self, other)))\n     def is_subset(self, other):\n", "normalized_occurrence": 1}
