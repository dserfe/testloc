{"model_name_or_path": "agentless", "instance_id": "django__django-15732", "model_patch": "diff --git a/django/db/backends/postgresql/introspection.py b/django/db/backends/postgresql/introspection.py\nindex 15d7bc4..295f305 100644\n--- a/django/db/backends/postgresql/introspection.py\n+++ b/django/db/backends/postgresql/introspection.py\n@@ -207,16 +207,20 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n             [table_name],\n         )\n         for constraint, columns, kind, used_cols, options in cursor.fetchall():\n-            constraints[constraint] = {\n-                \"columns\": columns,\n-                \"primary_key\": kind == \"p\",\n-                \"unique\": kind in [\"p\", \"u\"],\n-                \"foreign_key\": tuple(used_cols.split(\".\", 1)) if kind == \"f\" else None,\n-                \"check\": kind == \"c\",\n-                \"index\": False,\n-                \"definition\": None,\n-                \"options\": options,\n-            }\n+            if constraint not in constraints:\n+                constraints[constraint] = {\n+                    \"columns\": columns,\n+                    \"primary_key\": kind == \"p\",\n+                    \"unique\": kind in [\"p\", \"u\"],\n+                    \"foreign_key\": tuple(used_cols.split(\".\", 1)) if kind == \"f\" else None,\n+                    \"check\": kind == \"c\",\n+                    \"index\": False,\n+                    \"definition\": None,\n+                    \"options\": options,\n+                }\n+            else:\n+                if kind == \"u\" and not constraints[constraint][\"primary_key\"]:\n+                    constraints[constraint][\"unique\"] = True\n         # Now get indexes\n         cursor.execute(\n             \"\"\"\n@@ -292,4 +296,4 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n                     \"definition\": definition,\n                     \"options\": options,\n                 }\n-        return constraints\n+        return constraints\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/backends/postgresql/introspection.py b/django/db/backends/postgresql/introspection.py\nindex cdc8683..6885936 100644\n--- a/django/db/backends/postgresql/introspection.py\n+++ b/django/db/backends/postgresql/introspection.py\n@@ -36,7 +36,10 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n         constraints = {}\n         cursor.execute(\"\\n            SELECT\\n                c.conname,\\n                array(\\n                    SELECT attname\\n                    FROM unnest(c.conkey) WITH ORDINALITY cols(colid, arridx)\\n                    JOIN pg_attribute AS ca ON cols.colid = ca.attnum\\n                    WHERE ca.attrelid = c.conrelid\\n                    ORDER BY cols.arridx\\n                ),\\n                c.contype,\\n                (SELECT fkc.relname || '.' || fka.attname\\n                FROM pg_attribute AS fka\\n                JOIN pg_class AS fkc ON fka.attrelid = fkc.oid\\n                WHERE fka.attrelid = c.confrelid AND fka.attnum = c.confkey[1]),\\n                cl.reloptions\\n            FROM pg_constraint AS c\\n            JOIN pg_class AS cl ON c.conrelid = cl.oid\\n            WHERE cl.relname = %s AND pg_catalog.pg_table_is_visible(cl.oid)\\n        \", [table_name])\n         for constraint, columns, kind, used_cols, options in cursor.fetchall():\n-            constraints[constraint] = {'columns': columns, 'primary_key': kind == 'p', 'unique': kind in ['p', 'u'], 'foreign_key': tuple(used_cols.split('.', 1)) if kind == 'f' else None, 'check': kind == 'c', 'index': False, 'definition': None, 'options': options}\n+            if constraint not in constraints:\n+                constraints[constraint] = {'columns': columns, 'primary_key': kind == 'p', 'unique': kind in ['p', 'u'], 'foreign_key': tuple(used_cols.split('.', 1)) if kind == 'f' else None, 'check': kind == 'c', 'index': False, 'definition': None, 'options': options}\n+            elif kind == 'u' and (not constraints[constraint]['primary_key']):\n+                constraints[constraint]['unique'] = True\n         cursor.execute(\"\\n            SELECT\\n                indexname,\\n                array_agg(attname ORDER BY arridx),\\n                indisunique,\\n                indisprimary,\\n                array_agg(ordering ORDER BY arridx),\\n                amname,\\n                exprdef,\\n                s2.attoptions\\n            FROM (\\n                SELECT\\n                    c2.relname as indexname, idx.*, attr.attname, am.amname,\\n                    CASE\\n                        WHEN idx.indexprs IS NOT NULL THEN\\n                            pg_get_indexdef(idx.indexrelid)\\n                    END AS exprdef,\\n                    CASE am.amname\\n                        WHEN %s THEN\\n                            CASE (option & 1)\\n                                WHEN 1 THEN 'DESC' ELSE 'ASC'\\n                            END\\n                    END as ordering,\\n                    c2.reloptions as attoptions\\n                FROM (\\n                    SELECT *\\n                    FROM\\n                        pg_index i,\\n                        unnest(i.indkey, i.indoption)\\n                            WITH ORDINALITY koi(key, option, arridx)\\n                ) idx\\n                LEFT JOIN pg_class c ON idx.indrelid = c.oid\\n                LEFT JOIN pg_class c2 ON idx.indexrelid = c2.oid\\n                LEFT JOIN pg_am am ON c2.relam = am.oid\\n                LEFT JOIN\\n                    pg_attribute attr ON attr.attrelid = c.oid AND attr.attnum = idx.key\\n                WHERE c.relname = %s AND pg_catalog.pg_table_is_visible(c.oid)\\n            ) s2\\n            GROUP BY indexname, indisunique, indisprimary, amname, exprdef, attoptions;\\n        \", [self.index_default_access_method, table_name])\n         for index, columns, unique, primary, orders, type_, definition, options in cursor.fetchall():\n             if index not in constraints:\n", "normalized_occurrence": 1}
