{"model_name_or_path": "agentless_claude", "instance_id": "matplotlib__matplotlib-24149", "model_patch": "diff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 63a9e60..2e9e0fb 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -1706,47 +1706,7 @@ def safe_first_element(obj):\n     return _safe_first_finite(obj, skip_nonfinite=False)\n \n \n-def _safe_first_finite(obj, *, skip_nonfinite=True):\n-    \"\"\"\n-    Return the first non-None (and optionally finite) element in *obj*.\n-\n-    This is a method for internal use.\n \n-    This is an type-independent way of obtaining the first non-None element,\n-    supporting both index access and the iterator protocol.\n-    The first non-None element will be obtained when skip_none is True.\n-    \"\"\"\n-    def safe_isfinite(val):\n-        if val is None:\n-            return False\n-        try:\n-            return np.isfinite(val) if np.isscalar(val) else True\n-        except TypeError:\n-            # This is something that numpy can not make heads or tails\n-            # of, assume \"finite\"\n-            return True\n-    if skip_nonfinite is False:\n-        if isinstance(obj, collections.abc.Iterator):\n-            # needed to accept `array.flat` as input.\n-            # np.flatiter reports as an instance of collections.Iterator\n-            # but can still be indexed via [].\n-            # This has the side effect of re-setting the iterator, but\n-            # that is acceptable.\n-            try:\n-                return obj[0]\n-            except TypeError:\n-                pass\n-            raise RuntimeError(\"matplotlib does not support generators \"\n-                               \"as input\")\n-        return next(iter(obj))\n-    elif isinstance(obj, np.flatiter):\n-        # TODO do the finite filtering on this\n-        return obj[0]\n-    elif isinstance(obj, collections.abc.Iterator):\n-        raise RuntimeError(\"matplotlib does not \"\n-                           \"support generators as input\")\n-    else:\n-        return next(val for val in obj if safe_isfinite(val))\n \n \n def sanitize_sequence(data):\n", "occurrence": 5, "normalized_patch": "diff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex d655165..c421109 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -729,28 +729,6 @@ def index_of(y):\n     raise ValueError('Input could not be cast to an at-least-1D NumPy array')\n def safe_first_element(obj):\n     return _safe_first_finite(obj, skip_nonfinite=False)\n-def _safe_first_finite(obj, *, skip_nonfinite=True):\n-    def safe_isfinite(val):\n-        if val is None:\n-            return False\n-        try:\n-            return np.isfinite(val) if np.isscalar(val) else True\n-        except TypeError:\n-            return True\n-    if skip_nonfinite is False:\n-        if isinstance(obj, collections.abc.Iterator):\n-            try:\n-                return obj[0]\n-            except TypeError:\n-                pass\n-            raise RuntimeError('matplotlib does not support generators as input')\n-        return next(iter(obj))\n-    elif isinstance(obj, np.flatiter):\n-        return obj[0]\n-    elif isinstance(obj, collections.abc.Iterator):\n-        raise RuntimeError('matplotlib does not support generators as input')\n-    else:\n-        return next((val for val in obj if safe_isfinite(val)))\n def sanitize_sequence(data):\n     return list(data) if isinstance(data, collections.abc.MappingView) else data\n def normalize_kwargs(kw, alias_mapping=None):\n", "normalized_occurrence": 5}
