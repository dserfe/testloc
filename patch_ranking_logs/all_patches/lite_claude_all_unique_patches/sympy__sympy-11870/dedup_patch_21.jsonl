{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-11870", "model_patch": "diff --git a/sympy/functions/elementary/exponential.py b/sympy/functions/elementary/exponential.py\nindex 67a8b07..f927d4c 100644\n--- a/sympy/functions/elementary/exponential.py\n+++ b/sympy/functions/elementary/exponential.py\n@@ -452,6 +452,31 @@ class exp(ExpBase):\n         from sympy import tanh\n         return (1 + tanh(arg/2))/(1 - tanh(arg/2))\n \n+    @staticmethod\n+    def _eval_rewrite_as_trig(expr):\n+        \"\"\"Helper to recognize and convert exp(I*x) patterns to trig functions.\"\"\"\n+        from sympy import sin, cos, I\n+        if isinstance(expr, Mul):\n+            coeff = []\n+            exp_terms = []\n+            for term in expr.args:\n+                if isinstance(term, exp):\n+                    exp_terms.append(term)\n+                else:\n+                    coeff.append(term)\n+            if len(exp_terms) == 2:\n+                exp1, exp2 = exp_terms\n+                if (exp1.args[0] == -exp2.args[0] and\n+                    exp1.args[0].could_extract_minus_sign()):\n+                    # Pattern: a*exp(I*x) + b*exp(-I*x)\n+                    x = exp1.args[0].as_coefficient(I)\n+                    if x is not None:\n+                        if Mul(*coeff) == S.ImaginaryUnit/2:\n+                            return sin(x)\n+                        elif Mul(*coeff) == S.One/2:\n+                            return cos(x)\n+        return expr\n+\n \n class log(Function):\n     r\"\"\"\n", "occurrence": 1, "normalized_patch": "--- a/sympy/functions/elementary/exponential.py\n+++ b/sympy/functions/elementary/exponential.py\n+    @staticmethod\n+    def _eval_rewrite_as_trig(expr):\n+        from sympy import sin, cos, I\n+        if isinstance(expr, Mul):\n+            coeff = []\n+            exp_terms = []\n+            for term in expr.args:\n+                if isinstance(term, exp):\n+                    exp_terms.append(term)\n+                else:\n+                    coeff.append(term)\n+            if len(exp_terms) == 2:\n+                exp1, exp2 = exp_terms\n+                if exp1.args[0] == -exp2.args[0] and exp1.args[0].could_extract_minus_sign():\n+                    x = exp1.args[0].as_coefficient(I)\n+                    if x is not None:\n+                        if Mul(*coeff) == S.ImaginaryUnit / 2:\n+                            return sin(x)\n+                        elif Mul(*coeff) == S.One / 2:\n+                            return cos(x)\n+        return expr", "normalized_occurrence": 1}
