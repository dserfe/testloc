{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13878", "model_patch": "diff --git a/sympy/stats/crv_types.py b/sympy/stats/crv_types.py\nindex e880705..76e2e8a 100644\n--- a/sympy/stats/crv_types.py\n+++ b/sympy/stats/crv_types.py\n@@ -153,6 +153,16 @@ class ArcsinDistribution(SingleContinuousDistribution):\n     def pdf(self, x):\n         return 1/(pi*sqrt((x - self.a)*(self.b - x)))\n \n+class ArcsinDistribution(SingleContinuousDistribution):\n+    _argnames = ('a', 'b')\n+\n+    def pdf(self, x):\n+        return 1/(pi*sqrt((x - self.a)*(self.b - x)))\n+        \n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 2*asin(sqrt((x - a)/(b - a)))/pi\n+\n def Arcsin(name, a=0, b=1):\n     r\"\"\"\n     Create a Continuous Random Variable with an arcsin distribution.\n@@ -671,6 +681,17 @@ class DagumDistribution(SingleContinuousDistribution):\n         return a*p/x*((x/b)**(a*p)/(((x/b)**a + 1)**(p + 1)))\n \n \n+class DagumDistribution(SingleContinuousDistribution):\n+    _argnames = ('p', 'a', 'b')\n+\n+    def pdf(self, x):\n+        p, a, b = self.p, self.a, self.b\n+        return a*p/x*((x/b)**(a*p)/(((x/b)**a + 1)**(p + 1)))\n+\n+    def _cdf(self, x):\n+        p, a, b = self.p, self.a, self.b\n+        return (1 + (x/b)**-a)**-p\n+\n def Dagum(name, p, a, b):\n     r\"\"\"\n     Create a continuous random variable with a Dagum distribution.\n@@ -1042,6 +1063,23 @@ class FrechetDistribution(SingleContinuousDistribution):\n         a, s, m = self.a, self.s, self.m\n         return a/s * ((x-m)/s)**(-1-a) * exp(-((x-m)/s)**(-a))\n \n+class FrechetDistribution(SingleContinuousDistribution):\n+    _argnames = ('a', 's', 'm')\n+\n+    set = Interval(0, oo)\n+\n+    def __new__(cls, a, s=1, m=0):\n+        a, s, m = list(map(sympify, (a, s, m)))\n+        return Basic.__new__(cls, a, s, m)\n+\n+    def pdf(self, x):\n+        a, s, m = self.a, self.s, self.m\n+        return a/s * ((x-m)/s)**(-1-a) * exp(-((x-m)/s)**(-a))\n+\n+    def _cdf(self, x):\n+        a, s, m = self.a, self.s, self.m\n+        return exp(-((x-m)/s)**-a)\n+\n def Frechet(name, a, s=1, m=0):\n     r\"\"\"\n     Create a continuous random variable with a Frechet distribution.\n@@ -1112,6 +1150,27 @@ class GammaDistribution(SingleContinuousDistribution):\n         return random.gammavariate(self.k, self.theta)\n \n \n+class GammaDistribution(SingleContinuousDistribution):\n+    _argnames = ('k', 'theta')\n+\n+    set = Interval(0, oo)\n+\n+    @staticmethod\n+    def check(k, theta):\n+        _value_check(k > 0, \"k must be positive\")\n+        _value_check(theta > 0, \"Theta must be positive\")\n+\n+    def pdf(self, x):\n+        k, theta = self.k, self.theta\n+        return x**(k - 1) * exp(-x/theta) / (gamma(k)*theta**k)\n+\n+    def sample(self):\n+        return random.gammavariate(self.k, self.theta)\n+        \n+    def _cdf(self, x):\n+        k, theta = self.k, self.theta\n+        return lowergamma(k, x / theta) / gamma(k)\n+\n def Gamma(name, k, theta):\n     r\"\"\"\n     Create a continuous random variable with a Gamma distribution.\n@@ -1200,6 +1259,24 @@ class GammaInverseDistribution(SingleContinuousDistribution):\n         a, b = self.a, self.b\n         return b**a/gamma(a) * x**(-a-1) * exp(-b/x)\n \n+class GammaInverseDistribution(SingleContinuousDistribution):\n+    _argnames = ('a', 'b')\n+\n+    set = Interval(0, oo)\n+\n+    @staticmethod\n+    def check(a, b):\n+        _value_check(a > 0, \"alpha must be positive\")\n+        _value_check(b > 0, \"beta must be positive\")\n+\n+    def pdf(self, x):\n+        a, b = self.a, self.b\n+        return b**a/gamma(a) * x**(-a-1) * exp(-b/x)\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return uppergamma(a, b/x) / gamma(a)\n+\n def GammaInverse(name, a, b):\n     r\"\"\"\n     Create a continuous random variable with an inverse Gamma distribution.\n", "occurrence": 1, "normalized_patch": "--- a/sympy/stats/crv_types.py\n+++ b/sympy/stats/crv_types.py\n+class ArcsinDistribution(SingleContinuousDistribution):\n+    _argnames = ('a', 'b')\n+    def pdf(self, x):\n+        return 1 / (pi * sqrt((x - self.a) * (self.b - x)))\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 2 * asin(sqrt((x - a) / (b - a))) / pi\n+class DagumDistribution(SingleContinuousDistribution):\n+    _argnames = ('p', 'a', 'b')\n+    def pdf(self, x):\n+        p, a, b = (self.p, self.a, self.b)\n+        return a * p / x * ((x / b) ** (a * p) / ((x / b) ** a + 1) ** (p + 1))\n+    def _cdf(self, x):\n+        p, a, b = (self.p, self.a, self.b)\n+        return (1 + (x / b) ** (-a)) ** (-p)\n+class FrechetDistribution(SingleContinuousDistribution):\n+    _argnames = ('a', 's', 'm')\n+    set = Interval(0, oo)\n+    def __new__(cls, a, s=1, m=0):\n+        a, s, m = list(map(sympify, (a, s, m)))\n+        return Basic.__new__(cls, a, s, m)\n+    def pdf(self, x):\n+        a, s, m = (self.a, self.s, self.m)\n+        return a / s * ((x - m) / s) ** (-1 - a) * exp(-((x - m) / s) ** (-a))\n+    def _cdf(self, x):\n+        a, s, m = (self.a, self.s, self.m)\n+        return exp(-((x - m) / s) ** (-a))\n+class GammaDistribution(SingleContinuousDistribution):\n+    _argnames = ('k', 'theta')\n+    set = Interval(0, oo)\n+    @staticmethod\n+    def check(k, theta):\n+        _value_check(k > 0, 'k must be positive')\n+        _value_check(theta > 0, 'Theta must be positive')\n+    def pdf(self, x):\n+        k, theta = (self.k, self.theta)\n+        return x ** (k - 1) * exp(-x / theta) / (gamma(k) * theta ** k)\n+    def sample(self):\n+        return random.gammavariate(self.k, self.theta)\n+    def _cdf(self, x):\n+        k, theta = (self.k, self.theta)\n+        return lowergamma(k, x / theta) / gamma(k)\n+class GammaInverseDistribution(SingleContinuousDistribution):\n+    _argnames = ('a', 'b')\n+    set = Interval(0, oo)\n+    @staticmethod\n+    def check(a, b):\n+        _value_check(a > 0, 'alpha must be positive')\n+        _value_check(b > 0, 'beta must be positive')\n+    def pdf(self, x):\n+        a, b = (self.a, self.b)\n+        return b ** a / gamma(a) * x ** (-a - 1) * exp(-b / x)\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return uppergamma(a, b / x) / gamma(a)", "normalized_occurrence": 1}
