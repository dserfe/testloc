{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-23413", "model_patch": "diff --git a/sympy/matrices/normalforms.py b/sympy/matrices/normalforms.py\nindex d5302ed..db3d655 100644\n--- a/sympy/matrices/normalforms.py\n+++ b/sympy/matrices/normalforms.py\n@@ -67,61 +67,11 @@ def invariant_factors(m, domain=None):\n     return factors\n \n \n-def hermite_normal_form(A, *, D=None, check_rank=False):\n-    r\"\"\"\n-    Compute the Hermite Normal Form of a Matrix *A* of integers.\n \n-    Examples\n-    ========\n-\n-    >>> from sympy import Matrix\n-    >>> from sympy.matrices.normalforms import hermite_normal_form\n-    >>> m = Matrix([[12, 6, 4], [3, 9, 6], [2, 16, 14]])\n-    >>> print(hermite_normal_form(m))\n-    Matrix([[10, 0, 2], [0, 15, 3], [0, 0, 2]])\n-\n-    Parameters\n-    ==========\n-\n-    A : $m \\times n$ ``Matrix`` of integers.\n-\n-    D : int, optional\n-        Let $W$ be the HNF of *A*. If known in advance, a positive integer *D*\n-        being any multiple of $\\det(W)$ may be provided. In this case, if *A*\n-        also has rank $m$, then we may use an alternative algorithm that works\n-        mod *D* in order to prevent coefficient explosion.\n-\n-    check_rank : boolean, optional (default=False)\n-        The basic assumption is that, if you pass a value for *D*, then\n-        you already believe that *A* has rank $m$, so we do not waste time\n-        checking it for you. If you do want this to be checked (and the\n-        ordinary, non-modulo *D* algorithm to be used if the check fails), then\n-        set *check_rank* to ``True``.\n-\n-    Returns\n-    =======\n-\n-    ``Matrix``\n-        The HNF of matrix *A*.\n-\n-    Raises\n-    ======\n-\n-    DMDomainError\n-        If the domain of the matrix is not :ref:`ZZ`.\n-\n-    DMShapeError\n-        If the mod *D* algorithm is used but the matrix has more rows than\n-        columns.\n-\n-    References\n-    ==========\n-\n-    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\n-       (See Algorithms 2.4.5 and 2.4.8.)\n-\n-    \"\"\"\n     # Accept any of Python int, SymPy Integer, and ZZ itself:\n     if D is not None and not ZZ.of_type(D):\n         D = ZZ(int(D))\n-    return _hnf(A._rep, D=D, check_rank=check_rank).to_Matrix()\n+    # Force check_rank=False when using transpose method to avoid row removal\n+    if isinstance(A._rep, DomainMatrix) and A._rep.shape[0] < A._rep.shape[1]:\n+        check_rank = False\n+    return _hnf(A._rep, D=D, check_rank=check_rank).to_Matrix()\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/matrices/normalforms.py b/sympy/matrices/normalforms.py\nindex a9e46e4..c594cb4 100644\n--- a/sympy/matrices/normalforms.py\n+++ b/sympy/matrices/normalforms.py\n@@ -23,7 +23,8 @@ def invariant_factors(m, domain=None):\n             to_poly = lambda f: Poly(f, K.symbols, domain=K.domain)\n             factors = tuple((to_poly(f) for f in factors))\n     return factors\n-def hermite_normal_form(A, *, D=None, check_rank=False):\n     if D is not None and (not ZZ.of_type(D)):\n         D = ZZ(int(D))\n+    if isinstance(A._rep, DomainMatrix) and A._rep.shape[0] < A._rep.shape[1]:\n+        check_rank = False\n     return _hnf(A._rep, D=D, check_rank=check_rank).to_Matrix()\n\\ No newline at end of file\n", "normalized_occurrence": 1}
