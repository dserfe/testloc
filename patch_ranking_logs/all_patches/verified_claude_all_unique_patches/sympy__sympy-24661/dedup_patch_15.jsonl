{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-24661", "model_patch": "diff --git a/sympy/core/relational.py b/sympy/core/relational.py\nindex c35b72b..f5ba04b 100644\n--- a/sympy/core/relational.py\n+++ b/sympy/core/relational.py\n@@ -807,33 +807,7 @@ class _Inequality(Relational):\n     \"\"\"\n     __slots__ = ()\n \n-    def __new__(cls, lhs, rhs, **options):\n-\n-        try:\n-            lhs = _sympify(lhs)\n-            rhs = _sympify(rhs)\n-        except SympifyError:\n-            return NotImplemented\n \n-        evaluate = options.pop('evaluate', global_parameters.evaluate)\n-        if evaluate:\n-            for me in (lhs, rhs):\n-                if me.is_extended_real is False:\n-                    raise TypeError(\"Invalid comparison of non-real %s\" % me)\n-                if me is S.NaN:\n-                    raise TypeError(\"Invalid NaN comparison\")\n-            # First we invoke the appropriate inequality method of `lhs`\n-            # (e.g., `lhs.__lt__`).  That method will try to reduce to\n-            # boolean or raise an exception.  It may keep calling\n-            # superclasses until it reaches `Expr` (e.g., `Expr.__lt__`).\n-            # In some cases, `Expr` will just invoke us again (if neither it\n-            # nor a subclass was able to reduce to boolean or raise an\n-            # exception).  In that case, it must call us with\n-            # `evaluate=False` to prevent infinite recursion.\n-            return cls._eval_relation(lhs, rhs, **options)\n-\n-        # make a \"non-evaluated\" Expr for the inequality\n-        return Relational.__new__(cls, lhs, rhs, **options)\n \n     @classmethod\n     def _eval_relation(cls, lhs, rhs, **options):\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/relational.py b/sympy/core/relational.py\nindex 6f6b8fe..7f042c7 100644\n--- a/sympy/core/relational.py\n+++ b/sympy/core/relational.py\n@@ -341,21 +341,6 @@ class Unequality(Relational):\n Ne = Unequality\n class _Inequality(Relational):\n     __slots__ = ()\n-    def __new__(cls, lhs, rhs, **options):\n-        try:\n-            lhs = _sympify(lhs)\n-            rhs = _sympify(rhs)\n-        except SympifyError:\n-            return NotImplemented\n-        evaluate = options.pop('evaluate', global_parameters.evaluate)\n-        if evaluate:\n-            for me in (lhs, rhs):\n-                if me.is_extended_real is False:\n-                    raise TypeError('Invalid comparison of non-real %s' % me)\n-                if me is S.NaN:\n-                    raise TypeError('Invalid NaN comparison')\n-            return cls._eval_relation(lhs, rhs, **options)\n-        return Relational.__new__(cls, lhs, rhs, **options)\n     @classmethod\n     def _eval_relation(cls, lhs, rhs, **options):\n         val = cls._eval_fuzzy_relation(lhs, rhs)\n", "normalized_occurrence": 1}
