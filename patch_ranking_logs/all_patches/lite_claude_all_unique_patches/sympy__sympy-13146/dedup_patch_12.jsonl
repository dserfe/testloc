{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13146", "model_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex e24efd1..7f32682 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -693,6 +693,13 @@ def evalf_pow(v, prec, options):\n         # Positive square root\n         return mpf_sqrt(xre, prec), None, prec, None\n \n+    # Convert float exponents to rationals when possible\n+    if exp.is_Float:\n+        from sympy.core.numbers import Float\n+        rat_exp = Float(exp).as_rational()\n+        if rat_exp is not None:\n+            return evalf_pow(v.func(base, rat_exp), prec, options)\n+\n     # We first evaluate the exponent to find its magnitude\n     # This determines the working precision that must be used\n     prec += 10\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex 54c5b3f..c6b569e 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -390,6 +390,11 @@ def evalf_pow(v, prec, options):\n         if mpf_lt(xre, fzero):\n             return (None, mpf_sqrt(mpf_neg(xre), prec), None, prec)\n         return (mpf_sqrt(xre, prec), None, prec, None)\n+    if exp.is_Float:\n+        from sympy.core.numbers import Float\n+        rat_exp = Float(exp).as_rational()\n+        if rat_exp is not None:\n+            return evalf_pow(v.func(base, rat_exp), prec, options)\n     prec += 10\n     yre, yim, _, _ = evalf(exp, prec, options)\n     if not (yre or yim):\n", "normalized_occurrence": 1}
