{"model_name_or_path": "agentless_claude", "instance_id": "django__django-14730", "model_patch": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex d685b12..47468b2 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1229,6 +1229,19 @@ class ManyToManyField(RelatedField):\n \n     def _check_ignored_options(self, **kwargs):\n         warnings = []\n+        errors = []\n+\n+        if self.remote_field.symmetrical and self.remote_field.related_name:\n+            # Check if it's not the auto-generated related_name for self-referential symmetrical relationships\n+            if not self.remote_field.related_name.endswith('_rel_+') and not self.remote_field.related_name.endswith('_+'): \n+                errors.append(\n+                    checks.Error(\n+                        'related_name has no effect on symmetrical ManyToManyField.',\n+                        obj=self,\n+                        hint='Do not set related_name on symmetrical ManyToManyField relationships.',\n+                        id='fields.E345',\n+                    )\n+                )\n \n         if self.has_null_arg:\n             warnings.append(\n@@ -1258,7 +1271,7 @@ class ManyToManyField(RelatedField):\n                 )\n             )\n \n-        return warnings\n+        return errors + warnings\n \n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n@@ -1719,4 +1732,4 @@ class ManyToManyField(RelatedField):\n         return None\n \n     def db_parameters(self, connection):\n-        return {\"type\": None, \"check\": None}\n+        return {\"type\": None, \"check\": None}\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 6fd437b..fdc292b 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -542,13 +542,17 @@ class ManyToManyField(RelatedField):\n         return []\n     def _check_ignored_options(self, **kwargs):\n         warnings = []\n+        errors = []\n+        if self.remote_field.symmetrical and self.remote_field.related_name:\n+            if not self.remote_field.related_name.endswith('_rel_+') and (not self.remote_field.related_name.endswith('_+')):\n+                errors.append(checks.Error('related_name has no effect on symmetrical ManyToManyField.', obj=self, hint='Do not set related_name on symmetrical ManyToManyField relationships.', id='fields.E345'))\n         if self.has_null_arg:\n             warnings.append(checks.Warning('null has no effect on ManyToManyField.', obj=self, id='fields.W340'))\n         if self._validators:\n             warnings.append(checks.Warning('ManyToManyField does not support validators.', obj=self, id='fields.W341'))\n         if self.remote_field.limit_choices_to and self.remote_field.through and (not self.remote_field.through._meta.auto_created):\n             warnings.append(checks.Warning('limit_choices_to has no effect on ManyToManyField with a through model.', obj=self, id='fields.W343'))\n-        return warnings\n+        return errors + warnings\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = '%s.%s' % (self.remote_field.through._meta.app_label, self.remote_field.through.__name__)\n", "normalized_occurrence": 1}
