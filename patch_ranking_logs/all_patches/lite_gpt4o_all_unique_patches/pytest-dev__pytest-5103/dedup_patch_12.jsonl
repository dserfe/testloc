{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-5103", "model_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 4810cdd..6e75691 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -968,28 +968,47 @@ warn_explicit(\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n-        new_func, func_expl = self.visit(call.func)\n-        arg_expls = []\n-        new_args = []\n-        new_kwargs = []\n-        for arg in call.args:\n-            res, expl = self.visit(arg)\n-            arg_expls.append(expl)\n-            new_args.append(res)\n-        for keyword in call.keywords:\n-            res, expl = self.visit(keyword.value)\n-            new_kwargs.append(ast.keyword(keyword.arg, res))\n-            if keyword.arg:\n-                arg_expls.append(keyword.arg + \"=\" + expl)\n-            else:  # **args have `arg` keywords with an .arg of None\n-                arg_expls.append(\"**\" + expl)\n-\n-        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs)\n-        res = self.assign(new_call)\n-        res_expl = self.explanation_param(self.display(res))\n-        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n-        return res, outer_expl\n+        func_name = call.func.id if isinstance(call.func, ast.Name) else None\n+        if func_name in {\"all\", \"any\"} and len(call.args) == 1 and not call.keywords:\n+            # Special handling for all() and any()\n+            loop_var = self.variable()\n+            loop_var_assign = ast.Assign([ast.Name(loop_var, ast.Store())], call.args[0])\n+            self.statements.append(loop_var_assign)\n+\n+            loop_body = []\n+            fail_save = self.on_failure\n+            self.on_failure = loop_body\n+\n+            gen_exp = call.args[0]\n+            if isinstance(gen_exp, (ast.GeneratorExp, ast.ListComp, ast.SetComp)):\n+                for comp in gen_exp.generators:\n+                    ifs = comp.ifs\n+                    if not ifs:\n+                        ifs = [None]\n+                    for if_expr in ifs:\n+                        self.push_format_context()\n+                        test, test_expl = self.visit(comp.target)\n+                        iterable, iter_expl = self.visit(comp.iter)\n+                        if if_expr:\n+                            if_result, if_expl = self.visit(if_expr)\n+                            if_test = ast.BoolOp(ast.And(), [test, if_result])\n+                        else:\n+                            if_test = test\n+\n+                        loop_assign = ast.Assign([test], iterable)\n+                        loop_test_expr = ast.If(if_test, [], [])\n+                        self.statements.append(loop_assign)\n+                        self.statements.append(loop_test_expr)\n+                        self.statements = loop_test_expr.body\n+\n+                        if gen_exp.elt:\n+                            res, expl = self.generic_visit(gen_exp.elt)\n+                            loop_body.append(ast.Expr(ast.Call(call.func, [res], [])))\n+                            loop_body.append(ast.Expr(ast.Yield(res)))\n+                        \n+                        self.statements = fail_save\n+                res = ast.Name(loop_var, ast.Load())\n+                return res, expl\n \n     def visit_Starred(self, starred):\n         # From Python 3.5, a Starred node can appear in a function call\n@@ -1081,4 +1100,4 @@ warn_explicit(\n             res = ast.BoolOp(ast.And(), load_names)\n         else:\n             res = load_names[0]\n-        return res, self.explanation_param(self.pop_format_context(expl_call))\n+        return res, self.explanation_param(self.pop_format_context(expl_call))\n", "occurrence": 1, "normalized_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2ada5b2..961291c 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -544,27 +544,41 @@ class AssertionRewriter(ast.NodeVisitor):\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return (res, explanation)\n     def visit_Call_35(self, call):\n-        new_func, func_expl = self.visit(call.func)\n-        arg_expls = []\n-        new_args = []\n-        new_kwargs = []\n-        for arg in call.args:\n-            res, expl = self.visit(arg)\n-            arg_expls.append(expl)\n-            new_args.append(res)\n-        for keyword in call.keywords:\n-            res, expl = self.visit(keyword.value)\n-            new_kwargs.append(ast.keyword(keyword.arg, res))\n-            if keyword.arg:\n-                arg_expls.append(keyword.arg + '=' + expl)\n-            else:\n-                arg_expls.append('**' + expl)\n-        expl = '%s(%s)' % (func_expl, ', '.join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs)\n-        res = self.assign(new_call)\n-        res_expl = self.explanation_param(self.display(res))\n-        outer_expl = '%s\\n{%s = %s\\n}' % (res_expl, res_expl, expl)\n-        return (res, outer_expl)\n+        func_name = call.func.id if isinstance(call.func, ast.Name) else None\n+        if func_name in {'all', 'any'} and len(call.args) == 1 and (not call.keywords):\n+            loop_var = self.variable()\n+            loop_var_assign = ast.Assign([ast.Name(loop_var, ast.Store())], call.args[0])\n+            self.statements.append(loop_var_assign)\n+            loop_body = []\n+            fail_save = self.on_failure\n+            self.on_failure = loop_body\n+            gen_exp = call.args[0]\n+            if isinstance(gen_exp, (ast.GeneratorExp, ast.ListComp, ast.SetComp)):\n+                for comp in gen_exp.generators:\n+                    ifs = comp.ifs\n+                    if not ifs:\n+                        ifs = [None]\n+                    for if_expr in ifs:\n+                        self.push_format_context()\n+                        test, test_expl = self.visit(comp.target)\n+                        iterable, iter_expl = self.visit(comp.iter)\n+                        if if_expr:\n+                            if_result, if_expl = self.visit(if_expr)\n+                            if_test = ast.BoolOp(ast.And(), [test, if_result])\n+                        else:\n+                            if_test = test\n+                        loop_assign = ast.Assign([test], iterable)\n+                        loop_test_expr = ast.If(if_test, [], [])\n+                        self.statements.append(loop_assign)\n+                        self.statements.append(loop_test_expr)\n+                        self.statements = loop_test_expr.body\n+                        if gen_exp.elt:\n+                            res, expl = self.generic_visit(gen_exp.elt)\n+                            loop_body.append(ast.Expr(ast.Call(call.func, [res], [])))\n+                            loop_body.append(ast.Expr(ast.Yield(res)))\n+                        self.statements = fail_save\n+                res = ast.Name(loop_var, ast.Load())\n+                return (res, expl)\n     def visit_Starred(self, starred):\n         res, expl = self.visit(starred.value)\n         new_starred = ast.Starred(res, starred.ctx)\n", "normalized_occurrence": 1}
