{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13551", "model_patch": "diff --git a/sympy/concrete/products.py b/sympy/concrete/products.py\nindex 65aca3f..0046e68 100644\n--- a/sympy/concrete/products.py\n+++ b/sympy/concrete/products.py\n@@ -275,14 +275,33 @@ class Product(ExprWithIntLimits):\n             return poly.LC()**(n - a + 1) * A * B\n \n         elif term.is_Add:\n+            # Handle sums by evaluating each term separately\n+            # This is especially important for mixed terms with k and n\n+            args = term.args\n+            constant_term = S.Zero\n+            k_terms = []\n+            \n+            # Separate terms with and without k\n+            for arg in args:\n+                if k in arg.free_symbols:\n+                    k_terms.append(arg)\n+                else:\n+                    constant_term += arg\n+            \n+            if constant_term != S.Zero and k_terms:\n+                # For terms like n + 1/2**k, handle separately\n+                k_part = Add(*k_terms)\n+                k_prod = self._eval_product(k_part, (k, a, n))\n+                if k_prod is not None:\n+                    return constant_term * (n - a + 1) + k_prod\n+            \n+            # Fall back to original behavior if special cases don't apply\n             p, q = term.as_numer_denom()\n             q = self._eval_product(q, (k, a, n))\n             if q.is_Number:\n-\n                 # There is expression, which couldn't change by\n                 # as_numer_denom(). E.g. n**(2/3) + 1 --> (n**(2/3) + 1, 1).\n                 # We have to catch this case.\n-\n                 p = sum([self._eval_product(i, (k, a, n)) for i in p.as_coeff_Add()])\n             else:\n                 p = self._eval_product(p, (k, a, n))\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/concrete/products.py b/sympy/concrete/products.py\nindex f5dda77..76e31f3 100644\n--- a/sympy/concrete/products.py\n+++ b/sympy/concrete/products.py\n@@ -75,6 +75,19 @@ class Product(ExprWithIntLimits):\n                 B = self.func(arg, (k, a, n)).doit()\n             return poly.LC() ** (n - a + 1) * A * B\n         elif term.is_Add:\n+            args = term.args\n+            constant_term = S.Zero\n+            k_terms = []\n+            for arg in args:\n+                if k in arg.free_symbols:\n+                    k_terms.append(arg)\n+                else:\n+                    constant_term += arg\n+            if constant_term != S.Zero and k_terms:\n+                k_part = Add(*k_terms)\n+                k_prod = self._eval_product(k_part, (k, a, n))\n+                if k_prod is not None:\n+                    return constant_term * (n - a + 1) + k_prod\n             p, q = term.as_numer_denom()\n             q = self._eval_product(q, (k, a, n))\n             if q.is_Number:\n", "normalized_occurrence": 1}
