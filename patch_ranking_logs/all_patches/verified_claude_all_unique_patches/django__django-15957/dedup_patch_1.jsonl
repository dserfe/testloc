{"model_name_or_path": "agentless_claude", "instance_id": "django__django-15957", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 5314293..162798c 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -2160,6 +2160,16 @@ class Prefetch:\n                 lookup.split(LOOKUP_SEP)[:-1] + [to_attr]\n             )\n \n+        if queryset is not None and (\n+            queryset._low_mark or queryset._high_mark\n+        ):\n+            # If the queryset is sliced, we need to clone it before applying\n+            # additional filters to avoid the \"Cannot filter a query once a slice\n+            # has been taken\" error. We'll apply the slice after filtering.\n+            low_mark, high_mark = queryset._low_mark, queryset._high_mark\n+            queryset = queryset.all()  # Clone the queryset\n+            queryset._low_mark, queryset._high_mark = low_mark, high_mark\n+\n         self.queryset = queryset\n         self.to_attr = to_attr\n \n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex cb06696..05fda8c 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1121,6 +1121,10 @@ class Prefetch:\n             raise ValueError('Prefetch querysets cannot use raw(), values(), and values_list().')\n         if to_attr:\n             self.prefetch_to = LOOKUP_SEP.join(lookup.split(LOOKUP_SEP)[:-1] + [to_attr])\n+        if queryset is not None and (queryset._low_mark or queryset._high_mark):\n+            low_mark, high_mark = (queryset._low_mark, queryset._high_mark)\n+            queryset = queryset.all()\n+            queryset._low_mark, queryset._high_mark = (low_mark, high_mark)\n         self.queryset = queryset\n         self.to_attr = to_attr\n     def __getstate__(self):\n", "normalized_occurrence": 1}
