[
    {
        "instance_id": "django__django-14534",
        "model_patch": "diff --git a/tests/forms_tests/widget_tests/test_checkboxselectmultiple.py b/tests/forms_tests/widget_tests/test_checkboxselectmultiple.py\nindex 42555d98a6..f1aed86567 100644\n--- a/tests/forms_tests/widget_tests/test_checkboxselectmultiple.py\n+++ b/tests/forms_tests/widget_tests/test_checkboxselectmultiple.py\n@@ -206,3 +206,23 @@ class CheckboxSelectMultipleTest(WidgetTest):\n         bound_field = TestForm()['f']\n         self.assertEqual(bound_field.field.widget.id_for_label('id'), '')\n         self.assertEqual(bound_field.label_tag(), '<label>F:</label>')\n+\n+    def test_id_for_label_uses_widget_attrs_id(self):\n+        \"\"\"\n+        BoundWidget.id_for_label should use the ID from widget attrs\n+        when it's provided in ChoiceWidget.options.\n+        \"\"\"\n+        class TestForm(forms.Form):\n+            choices = forms.MultipleChoiceField(\n+                widget=CheckboxSelectMultiple(attrs={'id': 'custom_id'}),\n+                choices=[('1', 'One'), ('2', 'Two')],\n+            )\n+        form = TestForm()\n+        subwidgets = list(form['choices'].subwidgets)\n+        # The first subwidget should have an ID that includes the custom ID\n+        self.assertEqual(subwidgets[0].id_for_label, 'custom_id_0')\n+        # The second subwidget should also have an ID that includes the custom ID\n+        self.assertEqual(subwidgets[1].id_for_label, 'custom_id_1')\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13768",
        "model_patch": "diff --git a/tests/dispatch/tests.py b/tests/dispatch/tests.py\nindex 9b5482ed58..545dc2031f 100644\n--- a/tests/dispatch/tests.py\n+++ b/tests/dispatch/tests.py\n@@ -174,6 +174,27 @@ class DispatcherTests(SimpleTestCase):\n         a_signal.disconnect(fails)\n         self.assertTestIsClean(a_signal)\n \n+    def test_send_robust_logs_exceptions(self):\n+        \"\"\"Test that exceptions raised by signal receivers are logged.\"\"\"\n+        def failing_receiver(val, **kwargs):\n+            raise ValueError('Signal receiver exception')\n+        a_signal = Signal()\n+        a_signal.connect(failing_receiver)\n+        with self.assertLogs('django.dispatch.dispatcher', level='ERROR') as cm:\n+            result = a_signal.send_robust(sender=self, val=\"test\")\n+        # Check that the exception was returned as expected\n+        err = result[0][1]\n+        self.assertIsInstance(err, ValueError)\n+        self.assertEqual(str(err), 'Signal receiver exception')\n+        # Check that the exception was logged\n+        self.assertEqual(len(cm.records), 1)\n+        self.assertIn('Error connecting signal', cm.records[0].getMessage())\n+        self.assertIn('ValueError: Signal receiver exception', cm.output[0])\n+        a_signal.disconnect(failing_receiver)\n+        self.assertTestIsClean(a_signal)\n+    \n+\n+\n     def test_disconnection(self):\n         receiver_1 = Callable()\n         receiver_2 = Callable()\n@@ -230,3 +251,4 @@ class ReceiverTestCase(SimpleTestCase):\n         self.assertIn('a', self.state)\n         self.assertIn('b', self.state)\n         self.assertIn('c', self.state)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sphinx-doc__sphinx-11445",
        "model_patch": "diff --git a/tests/test_ext_todo.py b/tests/test_ext_todo.py\nindex 7d39495e7..a77e85af5 100644\n--- a/tests/test_ext_todo.py\n+++ b/tests/test_ext_todo.py\n@@ -107,3 +107,32 @@ def test_todo_valid_link(app, status, warning):\n \n     # If everything is correct we should have exactly one target.\n     assert len(matched) == 1\n+\n+def test_rst_prolog_with_domain_directive(app, status, warning):\n+    \"\"\"Test that rst_prolog doesn't remove top level headings with domain directives.\"\"\"\n+    app.config.rst_prolog = \"\"\"\n+.. |psf| replace:: Python Software Foundation\n+\"\"\"\n+    # Create a test document with a domain directive in the heading\n+    content = (\n+        \":mod:`mypackage`\\n\"\n+        \"===============\\n\"\n+        \"\\n\"\n+        \"Content\\n\"\n+        \"\\n\"\n+        \"Subheading\\n\"\n+        \"----------\\n\"\n+    )\n+    app.env.temp_data['docname'] = 'test'\n+    (app.srcdir / 'test.rst').write_text(content)\n+    app.build()\n+    # Check if the heading is correctly rendered in the HTML output\n+    html = (app.outdir / 'test.html').read_text()\n+    # The heading should be present in the HTML\n+    assert '<h1>mypackage' in html\n+    # The title should be properly stored in the environment\n+    assert 'mypackage' in app.env.titles['test'].astext()\n+    # Check that the domain directive is properly rendered\n+    assert '<span class=\"pre\">mypackage</span>' in html\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "psf__requests-3362",
        "model_patch": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex d2a2714a..3f50499b 100755\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -980,6 +980,33 @@ class TestRequests:\n         chunks = r.iter_content(decode_unicode=True)\n         assert all(isinstance(chunk, str) for chunk in chunks)\n \n+    def test_iter_content_decode_unicode_with_json(self):\n+        \"\"\"\n+        When called with decode_unicode=True, Response.iter_content should always\n+        return unicode for JSON content, just like Response.text does.\n+        \"\"\"\n+        # Create a response with JSON content\n+        r = requests.Response()\n+        r._content_consumed = True\n+        r._content = b'{\"key\": \"value\"}'\n+        r.encoding = 'utf-8'\n+        r.headers = {'content-type': 'application/json'}\n+        # Get the first chunk from iter_content with decode_unicode=True\n+        chunk = next(r.iter_content(chunk_size=16*1024, decode_unicode=True))\n+        # Check that the chunk is a string (unicode in Python 3)\n+        assert isinstance(chunk, str)\n+        # Also check for streaming response\n+        r = requests.Response()\n+        r.raw = io.BytesIO(b'{\"key\": \"value\"}')\n+        r.encoding = 'utf-8'\n+        r.headers = {'content-type': 'application/json'}\n+        # Get the first chunk from iter_content with decode_unicode=True\n+        chunk = next(r.iter_content(chunk_size=16*1024, decode_unicode=True))\n+        # Check that the chunk is a string (unicode in Python 3)\n+        assert isinstance(chunk, str)\n+    \n+\n+\n     def test_response_chunk_size_int(self):\n         \"\"\"Ensure that chunk_size is passed as an integer, otherwise\n         raise a TypeError.\n@@ -1709,3 +1736,4 @@ def test_vendor_aliases():\n \n     with pytest.raises(ImportError):\n         from requests.packages import webbrowser\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-21847",
        "model_patch": "diff --git a/sympy/polys/tests/test_monomials.py b/sympy/polys/tests/test_monomials.py\nindex 482cbee30d..e3a8b1784a 100644\n--- a/sympy/polys/tests/test_monomials.py\n+++ b/sympy/polys/tests/test_monomials.py\n@@ -162,6 +162,27 @@ def test_monomials():\n                     x*j**2, x*k**2, x*j*k, x**2*j**2*k**2, x*j*k**2, x**2, x**2*j*k**2\n             }\n \n+def test_itermonomials_min_degrees():\n+    # Test for the issue where min_degrees with total_degree doesn't return all monomials of that degree\n+    x1, x2, x3 = symbols('x1, x2, x3')\n+    # Test with min_degrees = max_degrees = 3\n+    # Should return all monomials with total degree exactly 3\n+    expected = {x1**3, x2**3, x3**3, \n+                x1**2*x2, x1**2*x3, x2**2*x1, \n+                x2**2*x3, x3**2*x1, x3**2*x2,\n+                x1*x2*x3}\n+    result = set(itermonomials([x1, x2, x3], 3, min_degrees=3))\n+    assert result == expected, f\"Expected {expected}, got {result}\"\n+    # Test with min_degrees = 3, max_degrees = 4\n+    # Should include all monomials with total degree 3 and 4\n+    result_higher = set(itermonomials([x1, x2, x3], 4, min_degrees=3))\n+    assert result.issubset(result_higher), \"Monomials of degree 3 missing when max_degree > min_degree\"\n+    # Test with two variables\n+    expected_two_vars = {x1**3, x2**3, x1**2*x2, x1*x2**2}\n+    result_two_vars = set(itermonomials([x1, x2], 3, min_degrees=3))\n+    assert result_two_vars == expected_two_vars\n+\n+\n def test_monomial_count():\n     assert monomial_count(2, 2) == 6\n     assert monomial_count(2, 3) == 10\n@@ -252,3 +273,4 @@ def test_Monomial():\n     raises(ValueError, lambda: m**-1)\n     raises(TypeError, lambda: m.gcd(3))\n     raises(TypeError, lambda: m.lcm(3))\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-24970",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_colors.py b/lib/matplotlib/tests/test_colors.py\nindex ff893e71ac..8647c6b1d0 100644\n--- a/lib/matplotlib/tests/test_colors.py\n+++ b/lib/matplotlib/tests/test_colors.py\n@@ -1441,6 +1441,17 @@ def test_2d_to_rgba():\n     rgba_2d = mcolors.to_rgba(color.reshape((1, -1)))\n     assert rgba_1d == rgba_2d\n \n+def test_empty_uint8_array_no_warnings():\n+    \"\"\"Test that no deprecation warnings are emitted when passing an empty uint8 array.\"\"\"\n+    with pytest.warns(None) as record:\n+        # This should not emit any warnings\n+        plt.get_cmap()(np.empty((0, ), dtype=np.uint8))\n+    # Verify no NumPy deprecation warnings were emitted\n+    for warning in record:\n+        assert not (isinstance(warning.message, np.VisibleDeprecationWarning) and \n+                   \"NumPy will stop allowing conversion of out-of-bound Python integers\" in str(warning.message))\n+\n+\n \n def test_set_dict_to_rgba():\n     # downstream libraries do this...\n@@ -1585,3 +1596,4 @@ def test_cm_set_cmap_error():\n     bad_cmap = 'AardvarksAreAwkward'\n     with pytest.raises(ValueError, match=bad_cmap):\n         sm.set_cmap(bad_cmap)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-10508",
        "model_patch": "diff --git a/sklearn/preprocessing/tests/test_label.py b/sklearn/preprocessing/tests/test_label.py\nindex 4f64fc6b46..6a3458c603 100644\n--- a/sklearn/preprocessing/tests/test_label.py\n+++ b/sklearn/preprocessing/tests/test_label.py\n@@ -208,6 +208,17 @@ def test_label_encoder_errors():\n     assert_raise_message(ValueError, msg, le.inverse_transform, [-2])\n     assert_raise_message(ValueError, msg, le.inverse_transform, [-2, -3, -4])\n \n+def test_label_encoder_empty_array():\n+    # Test that LabelEncoder.transform works with empty arrays\n+    le = LabelEncoder()\n+    # Test with numeric labels\n+    le.fit([1, 2])\n+    assert_array_equal(le.transform([]), np.array([], dtype=int))\n+    # Test with string labels - this should work the same way\n+    le.fit([\"a\", \"b\"])\n+    assert_array_equal(le.transform([]), np.array([], dtype=int))\n+\n+\n \n def test_sparse_output_multilabel_binarizer():\n     # test input as iterable of iterables\n@@ -513,3 +524,4 @@ def test_inverse_binarize_multiclass():\n                                                    [0, 0, 0]]),\n                                        np.arange(3))\n     assert_array_equal(got, np.array([1, 1, 0]))\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-23299",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_matplotlib.py b/lib/matplotlib/tests/test_matplotlib.py\nindex 6f92b4ca0a..695685d1b7 100644\n--- a/lib/matplotlib/tests/test_matplotlib.py\n+++ b/lib/matplotlib/tests/test_matplotlib.py\n@@ -75,3 +75,23 @@ def test_importable_with__OO():\n     )\n     cmd = [sys.executable, \"-OO\", \"-c\", program]\n     assert subprocess.call(cmd, env={**os.environ, \"MPLBACKEND\": \"\"}) == 0\n+\n+def test_get_backend_preserves_figures():\n+    \"\"\"Test that get_backend() doesn't clear figures created in rc_context.\"\"\"\n+    import matplotlib.pyplot as plt\n+    from matplotlib import get_backend, rc_context\n+    # Create a figure within rc_context\n+    with rc_context():\n+        fig = plt.figure()\n+    # Store the state before calling get_backend()\n+    before = list(plt._pylab_helpers.Gcf.figs.keys())\n+    # Call get_backend() which should not affect the figures\n+    get_backend()\n+    # Check that the figures are still there\n+    after = list(plt._pylab_helpers.Gcf.figs.keys())\n+    # Clean up\n+    plt.close(fig)\n+    # The test should fail if figures are cleared\n+    assert before == after, f\"Figures before: {before}, after: {after}\"\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-16988",
        "model_patch": "diff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 67761ce004..085832be45 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -1142,3 +1142,17 @@ def test_issue_16878b():\n     # that handles the base_set of S.Reals like there is\n     # for Integers\n     assert imageset(x, (x, x), S.Reals).is_subset(S.Reals**2) is True\n+\n+def test_intersection_duplicates():\n+    # Test that Intersection removes duplicates\n+    assert Intersection({1}, {1}, {x}) != EmptySet()\n+    # The correct result should be a conditional set\n+    result = Intersection({1}, {1}, {x})\n+    expected = Piecewise(({1}, Eq(x, 1)), (S.EmptySet, True))\n+    assert result == expected\n+    # Test that duplicates are removed at the outset\n+    assert Intersection({1}, {1}, {x}) == Intersection({1}, {x})\n+    # Test with different order of arguments\n+    assert Intersection({x}, {1}, {1}) == Intersection({x}, {1})\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-22005",
        "model_patch": "diff --git a/sympy/solvers/tests/test_polysys.py b/sympy/solvers/tests/test_polysys.py\nindex 58419f8762..a49ddcc02b 100644\n--- a/sympy/solvers/tests/test_polysys.py\n+++ b/sympy/solvers/tests/test_polysys.py\n@@ -133,3 +133,13 @@ def test_solve_issue_3686():\n     assert roots[0][1].epsilon_eq(-499.474999374969, 1e12)\n     assert roots[1][0] == 0\n     assert roots[1][1].epsilon_eq(500.474999374969, 1e12)\n+\n+def test_infinite_solutions():\n+    # Test that systems with infinite solutions are properly detected\n+    raises(NotImplementedError, lambda: solve_poly_system([x - 1], x, y))\n+    raises(NotImplementedError, lambda: solve_poly_system([y - 1], x, y))\n+    # Test with Poly objects\n+    raises(NotImplementedError, lambda: solve_poly_system([Poly(x - 1, x, y)], x, y))\n+    raises(NotImplementedError, lambda: solve_poly_system([Poly(y - 1, x, y)], x, y))\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11910",
        "model_patch": "diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex 1d5b8ef463..62e65b3473 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -836,32 +836,50 @@ class AutodetectorTests(TestCase):\n         self.assertOperationTypes(changes, 'testapp', 0, [\"RenameField\"])\n         self.assertOperationAttributes(changes, 'testapp', 0, 0, old_name=\"name\", new_name=\"names\")\n \n+\n     def test_rename_field_foreign_key_to_field(self):\n+        \"\"\"\n+        Tests that when renaming a field that's pointed to by a ForeignKey's\n+        to_field, the ForeignKey's to_field is also updated to reflect the rename.\n+        This test specifically focuses on the case where the renamed field is a\n+        primary key.\n+        \"\"\"\n+        # Initial model states\n         before = [\n             ModelState('app', 'Foo', [\n-                ('id', models.AutoField(primary_key=True)),\n-                ('field', models.IntegerField(unique=True)),\n+                ('field_wrong', models.CharField(max_length=50, primary_key=True)),\n             ]),\n             ModelState('app', 'Bar', [\n                 ('id', models.AutoField(primary_key=True)),\n-                ('foo', models.ForeignKey('app.Foo', models.CASCADE, to_field='field')),\n+                ('foo', models.ForeignKey('app.Foo', models.CASCADE, to_field='field_wrong')),\n             ]),\n         ]\n+        # States after renaming the primary key field\n         after = [\n             ModelState('app', 'Foo', [\n-                ('id', models.AutoField(primary_key=True)),\n-                ('renamed_field', models.IntegerField(unique=True)),\n+                ('field_fixed', models.CharField(max_length=50, primary_key=True)),\n             ]),\n             ModelState('app', 'Bar', [\n                 ('id', models.AutoField(primary_key=True)),\n-                ('foo', models.ForeignKey('app.Foo', models.CASCADE, to_field='renamed_field')),\n+                ('foo', models.ForeignKey('app.Foo', models.CASCADE, to_field='field_fixed')),\n             ]),\n         ]\n+        # Get the changes between the states\n         changes = self.get_changes(before, after, MigrationQuestioner({'ask_rename': True}))\n-        # Right number/type of migrations?\n+        # Verify the correct number and type of migrations\n         self.assertNumberMigrations(changes, 'app', 1)\n         self.assertOperationTypes(changes, 'app', 0, ['RenameField'])\n-        self.assertOperationAttributes(changes, 'app', 0, 0, old_name='field', new_name='renamed_field')\n+        # Verify the rename operation has the correct attributes\n+        self.assertOperationAttributes(changes, 'app', 0, 0, \n+                                      old_name='field_wrong', \n+                                      new_name='field_fixed')\n+        # Verify that the ForeignKey's to_field is updated correctly\n+        # This is the key part that tests the issue\n+        bar_model = self.after_state.apps.get_model('app', 'Bar')\n+        foo_field = bar_model._meta.get_field('foo')\n+        self.assertEqual(foo_field.to_fields[0], 'field_fixed')\n+    \n+\n \n     def test_rename_foreign_object_fields(self):\n         fields = ('first', 'second')\n@@ -2414,3 +2432,4 @@ class AutodetectorTests(TestCase):\n         self.assertNumberMigrations(changes, 'app', 1)\n         self.assertOperationTypes(changes, 'app', 0, ['DeleteModel'])\n         self.assertOperationAttributes(changes, 'app', 0, 0, name='Dog')\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-7490",
        "model_patch": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 8fceb37aa..67755a643 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1187,6 +1187,23 @@ def test_mark_xfail_item(testdir):\n     xfailed = [r for r in skipped if hasattr(r, \"wasxfail\")]\n     assert xfailed\n \n+def test_dynamic_xfail_during_test(testdir):\n+    \"\"\"Test that dynamically adding xfail marker during test execution works.\"\"\"\n+    testdir.makepyfile(\"\"\"\n+        import pytest\n+        def test_xfail_added_during_test(request):\n+            mark = pytest.mark.xfail(reason=\"xfail dynamically added during test\")\n+            request.node.add_marker(mark)\n+            assert 0\n+    \"\"\")\n+    result = testdir.runpytest(\"-v\")\n+    result.stdout.fnmatch_lines([\n+        \"*::test_xfail_added_during_test XFAIL*\",\n+        \"*xfail dynamically added during test*\"\n+    ])\n+    assert result.ret == 0\n+\n+\n \n def test_summary_list_after_errors(testdir):\n     \"\"\"Ensure the list of errors/fails/xfails/skips appears after tracebacks in terminal reporting.\"\"\"\n@@ -1230,3 +1247,4 @@ def test_relpath_rootdir(testdir):\n     result.stdout.fnmatch_lines(\n         [\"SKIPPED [[]1[]] tests/test_1.py:2: unconditional skip\"]\n     )\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-13584",
        "model_patch": "diff --git a/sklearn/tests/test_config.py b/sklearn/tests/test_config.py\nindex 4538799982..722b4af918 100644\n--- a/sklearn/tests/test_config.py\n+++ b/sklearn/tests/test_config.py\n@@ -69,3 +69,21 @@ def test_set_config():\n \n     # No unknown arguments\n     assert_raises(TypeError, set_config, do_something_else=True)\n+\n+def test_print_changed_only_with_array():\n+    \"\"\"Test that print_changed_only works with array parameters.\"\"\"\n+    import numpy as np\n+    from logistic import LogisticRegressionCV\n+    # Test with print_changed_only=True\n+    with config_context(print_changed_only=True):\n+        # This should not raise a ValueError\n+        repr_str = repr(LogisticRegressionCV(Cs=np.array([0.1, 1])))\n+        assert \"Cs=\" in repr_str\n+        # Test with other array types\n+        repr_str = repr(LogisticRegressionCV(Cs=[0.1, 1]))\n+        assert \"Cs=\" in repr_str\n+        # Test with a single element array\n+        repr_str = repr(LogisticRegressionCV(Cs=np.array([0.5])))\n+        assert \"Cs=\" in repr_str\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pylint-dev__pylint-7228",
        "model_patch": "diff --git a/tests/config/unittest_config.py b/tests/config/unittest_config.py\nindex 8c668aa52..9146808b0 100644\n--- a/tests/config/unittest_config.py\n+++ b/tests/config/unittest_config.py\n@@ -27,6 +27,15 @@ def test__regexp_validator_invalid() -> None:\n     with pytest.raises(sre_constants.error):\n         config.option._regexp_validator(None, None, \"test_)\")\n \n+def test__regexp_validator_unicode_pattern() -> None:\n+    \"\"\"Test that unicode patterns like \\p{Han} are properly handled.\"\"\"\n+    try:\n+        # This should not raise an error when the issue is fixed\n+        config.option._regexp_validator(None, \"name\", r\"[\\p{Han}a-z_][\\p{Han}a-z0-9_]{2,30}$\")\n+    except re.error as exc:\n+        pytest.fail(f\"Unicode pattern with \\\\p{{Han}} raised an error: {exc}\")\n+\n+\n \n def test__csv_validator_no_spaces() -> None:\n     values = [\"One\", \"Two\", \"Three\"]\n@@ -87,3 +96,4 @@ class TestPyLinterOptionSetters(CheckerTestCase):\n         options = self.linter.config.ignore_paths\n \n         assert options == []\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "psf__requests-2148",
        "model_patch": "diff --git a/test_requests.py b/test_requests.py\nindex 283353b9..05137513 100755\n--- a/test_requests.py\n+++ b/test_requests.py\n@@ -969,6 +969,22 @@ class RequestsTestCase(unittest.TestCase):\n         self._patch_adapter_gzipped_redirect(s, url)\n         s.get(url)\n \n+    def test_socket_error_is_caught(self):\n+        \"\"\"Test that socket.error is caught and wrapped in a ConnectionError.\"\"\"\n+        session = requests.Session()\n+        # Create a custom adapter that raises a socket.error\n+        class SocketErrorAdapter(HTTPAdapter):\n+            def send(self, request, **kwargs):\n+                import socket\n+                raise socket.error(\"Connection reset by peer\")\n+        # Mount the adapter to handle all requests\n+        session.mount('http://', SocketErrorAdapter())\n+        # The request should raise a ConnectionError, not a socket.error\n+        with pytest.raises(requests.exceptions.ConnectionError):\n+            session.get('http://example.com')\n+    \n+\n+\n     def test_basic_auth_str_is_always_native(self):\n         s = _basic_auth_str(\"test\", \"test\")\n         assert isinstance(s, builtin_str)\n@@ -1423,3 +1439,4 @@ def test_prepared_request_complete_copy():\n \n if __name__ == '__main__':\n     unittest.main()\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-12236",
        "model_patch": "diff --git a/sympy/polys/tests/test_partfrac.py b/sympy/polys/tests/test_partfrac.py\nindex 707fb45871..deca197442 100644\n--- a/sympy/polys/tests/test_partfrac.py\n+++ b/sympy/polys/tests/test_partfrac.py\n@@ -61,6 +61,18 @@ def test_apart_symbolic():\n         1/((a - c)*(b - c)*(c + x)) - 1/((a - b)*(b - c)*(b + x)) + \\\n         1/((a - b)*(a - c)*(a + x))\n \n+def test_apart_symbolic_with_coefficients():\n+    # Test case from the issue\n+    t = Symbol('t', real=True, negative=False)\n+    a = Symbol('a', real=True)\n+    bug = a * (-t + (-t + 1) * (2 * t - 1)) / (2 * t - 1)\n+    # The expected result should match what we get when substituting a=1\n+    expected = -a*t + a/2 - a/(2*(2*t - 1))\n+    # This should give the correct partial fraction decomposition\n+    result = apart(bug, t)\n+    assert result == expected\n+\n+\n \n def test_apart_extension():\n     f = 2/(x**2 + 1)\n@@ -168,3 +180,4 @@ def test_issue_5798():\n     assert apart(\n         2*x/(x**2 + 1) - (x - 1)/(2*(x**2 + 1)) + 1/(2*(x + 1)) - 2/x) == \\\n         (3*x + 1)/(x**2 + 1)/2 + 1/(x + 1)/2 - 2/x\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-17655",
        "model_patch": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 475d1d403f..fc93fa31e6 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -400,3 +400,23 @@ def test_direction_cosine():\n     assert p2.direction_cosine(Point3D(0, 0, 0)) == [-sqrt(3) / 3, -sqrt(3) / 3, -sqrt(3) / 3]\n     assert p2.direction_cosine(Point3D(1, 1, 12)) == [0, 0, 1]\n     assert p2.direction_cosine(Point3D(12, 1, 12)) == [sqrt(2) / 2, 0, sqrt(2) / 2]\n+\n+def test_point_multiplication_order():\n+    # Test that multiplication of Point with a number is commutative\n+    p = Point(1, 1)\n+    # These should give the same result\n+    p1 = p * 2\n+    p2 = 2 * p\n+    assert p1 == p2\n+    # Test with sympify\n+    from sympy import sympify\n+    p3 = p * sympify(2.0)\n+    p4 = sympify(2.0) * p\n+    assert p3 == p4\n+    # Test in expressions\n+    p5 = Point(0, 0)\n+    expr1 = p5 + p * sympify(2.0)\n+    expr2 = p5 + sympify(2.0) * p\n+    assert expr1 == expr2\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sphinx-doc__sphinx-10451",
        "model_patch": "diff --git a/tests/test_ext_autodoc_configs.py b/tests/test_ext_autodoc_configs.py\nindex c075a8e2d..2d09ce67b 100644\n--- a/tests/test_ext_autodoc_configs.py\n+++ b/tests/test_ext_autodoc_configs.py\n@@ -1051,6 +1051,47 @@ def test_autodoc_typehints_description_with_documented_init(app):\n             '      Return type:\\n'\n             '         None\\n' == context)\n \n+def test_autodoc_typehints_description_with_documented_init_and_star_args(app):\n+    (app.srcdir / 'index.rst').write_text(\n+        '.. autoclass:: target.typehints._ClassWithDocumentedInitAndStarArgs\\n'\n+        '   :special-members: __init__\\n',\n+        encoding='utf8'\n+    )\n+    app.build()\n+    context = (app.outdir / 'index.txt').read_text(encoding='utf8')\n+    assert ('class target.typehints._ClassWithDocumentedInitAndStarArgs(x, *args, **kwargs)\\n'\n+            '\\n'\n+            '   Class docstring.\\n'\n+            '\\n'\n+            '   Parameters:\\n'\n+            '      * **x** (*int*) --\\n'\n+            '\\n'\n+            '      * ***args** (*int*) --\\n'\n+            '\\n'\n+            '      * ****kwargs** (*int*) --\\n'\n+            '\\n'\n+            '   Return type:\\n'\n+            '      None\\n'\n+            '\\n'\n+            '   __init__(x, *args, **kwargs)\\n'\n+            '\\n'\n+            '      Init docstring.\\n'\n+            '\\n'\n+            '      Parameters:\\n'\n+            '         * **x** (*int*) -- Some integer\\n'\n+            '\\n'\n+            '         * ***args** (*int*) --\\n'\n+            '\\n'\n+            '           Some integer\\n'\n+            '\\n'\n+            '         * ****kwargs** (*int*) --\\n'\n+            '\\n'\n+            '           Some integer\\n'\n+            '\\n'\n+            '      Return type:\\n'\n+            '         None\\n' == context)\n+\n+\n \n @pytest.mark.sphinx('text', testroot='ext-autodoc',\n                     confoverrides={'autodoc_typehints': \"description\",\n@@ -1643,3 +1684,4 @@ def test_autodoc_default_options_with_values(app):\n         assert '      list of weak references to the object (if defined)' not in actual\n     assert '   .. py:method:: CustomIter.snafucate()' not in actual\n     assert '      Makes this snafucated.' not in actual\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-24149",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex 9fb95cbd68..1c612d4118 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -8195,3 +8195,16 @@ def test_bar_leading_nan():\n         for b in rest:\n             assert np.isfinite(b.xy).all()\n             assert np.isfinite(b.get_width())\n+\n+def test_bar_all_nan():\n+    \"\"\"Test that bar plots with all-nan data don't raise an exception.\"\"\"\n+    fig, ax = plt.subplots()\n+    # This should not raise StopIteration\n+    bars = ax.bar([np.nan], [np.nan])\n+    # Check that we get a BarContainer with one Rectangle\n+    assert len(bars) == 1\n+    # Check that the Rectangle has nan for x and height\n+    assert np.isnan(bars[0].get_x())\n+    assert np.isnan(bars[0].get_height())\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "astropy__astropy-14995",
        "model_patch": "diff --git a/astropy/nddata/tests/test_nddata.py b/astropy/nddata/tests/test_nddata.py\nindex 033b555fa0..cd1baa73e8 100644\n--- a/astropy/nddata/tests/test_nddata.py\n+++ b/astropy/nddata/tests/test_nddata.py\n@@ -707,3 +707,27 @@ def test_collapse(mask, unit, propagate_uncertainties, operation_ignores_mask):\n             # as the data array, so we can just check for equality:\n             if method in ext_methods and propagate_uncertainties:\n                 assert np.ma.all(np.ma.equal(astropy_method, nddata_method))\n+\n+def test_arithmetic_mask_propagation():\n+    \"\"\"Test that mask propagation works correctly when one operand has no mask.\"\"\"\n+    from astropy.nddata import NDDataRef\n+    # Create test data\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+    # Create NDDataRef objects with and without mask\n+    nref_nomask = NDDataRef(array)\n+    nref_mask = NDDataRef(array, mask=mask)\n+    # Test case 1: multiply mask by constant (mask * no mask)\n+    result1 = nref_mask.multiply(1., handle_mask=np.bitwise_or)\n+    assert_array_equal(result1.mask, mask)\n+    # Test case 2: multiply mask by no mask (mask * no mask)\n+    result2 = nref_mask.multiply(nref_nomask, handle_mask=np.bitwise_or)\n+    assert_array_equal(result2.mask, mask)\n+    # Test case 3: multiply no mask by mask (no mask * mask)\n+    result3 = nref_nomask.multiply(nref_mask, handle_mask=np.bitwise_or)\n+    assert_array_equal(result3.mask, mask)\n+    # Test case 4: no mask operations should still return None\n+    result4 = nref_nomask.multiply(nref_nomask, handle_mask=np.bitwise_or)\n+    assert result4.mask is None\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15695",
        "model_patch": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex cfd28b1b39..34daa5025a 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -2961,6 +2961,7 @@ class OperationTests(OperationTestBase):\n         with self.assertRaisesMessage(ValueError, msg):\n             migrations.RenameIndex(\"Pony\", new_name=\"new_idx_name\")\n \n+\n     def test_rename_index_unnamed_index(self):\n         app_label = \"test_rninui\"\n         project_state = self.set_up_test_model(app_label, index_together=True)\n@@ -2977,7 +2978,6 @@ class OperationTests(OperationTestBase):\n             operation.migration_name_fragment,\n             \"rename_pony_weight_pink_new_pony_test_idx\",\n         )\n-\n         new_state = project_state.clone()\n         operation.state_forwards(app_label, new_state)\n         # Rename index.\n@@ -2988,6 +2988,10 @@ class OperationTests(OperationTestBase):\n         with connection.schema_editor() as editor, self.assertNumQueries(0):\n             operation.database_backwards(app_label, editor, new_state, project_state)\n         self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n+        # Re-apply renaming - this should not crash\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n         # Deconstruction.\n         definition = operation.deconstruct()\n         self.assertEqual(definition[0], \"RenameIndex\")\n@@ -3000,6 +3004,8 @@ class OperationTests(OperationTestBase):\n                 \"old_fields\": (\"weight\", \"pink\"),\n             },\n         )\n+    \n+\n \n     def test_rename_index_unknown_unnamed_index(self):\n         app_label = \"test_rninuui\"\n@@ -5330,3 +5336,4 @@ class FieldOperationTests(SimpleTestCase):\n         self.assertIs(\n             operation.references_field(\"Through\", \"second\", \"migrations\"), True\n         )\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-25498",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\nindex e39d007378..0fc9ba45d7 100644\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -1204,6 +1204,26 @@ def test_colorbar_errors(kwargs, error, message):\n     with pytest.raises(error, match=message):\n         fig.colorbar(im, **kwargs)\n \n+def test_colorbar_update_with_norm_change():\n+    \"\"\"Test that colorbar updates correctly after changing the norm of the mappable.\"\"\"\n+    # Create a simple plot with a colorbar\n+    fig, ax = plt.subplots()\n+    data = np.random.normal(1, 1, size=(10, 10))\n+    img = ax.imshow(data, cmap='viridis')\n+    cb = fig.colorbar(img)\n+    # Get initial colorbar range\n+    initial_y = cb._y\n+    # Change the norm of the mappable to LogNorm\n+    img.set_norm(LogNorm(vmin=0.1, vmax=10))\n+    # Update the colorbar\n+    cb.update_normal(img)\n+    # The y values should be different after updating with a LogNorm\n+    assert not np.allclose(initial_y, cb._y)\n+    # Make sure no exception is raised when drawing\n+    fig.canvas.draw()\n+    plt.close(fig)\n+\n+\n \n def test_colorbar_axes_parmeters():\n     fig, ax = plt.subplots(2)\n@@ -1215,3 +1235,4 @@ def test_colorbar_axes_parmeters():\n     fig.colorbar(im, ax=(ax[0], ax[1]))\n     fig.colorbar(im, ax={i: _ax for i, _ax in enumerate(ax)}.values())\n     fig.draw_without_rendering()\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15819",
        "model_patch": "diff --git a/tests/inspectdb/tests.py b/tests/inspectdb/tests.py\nindex 9bf3c432e5..fbbcd2fd81 100644\n--- a/tests/inspectdb/tests.py\n+++ b/tests/inspectdb/tests.py\n@@ -263,6 +263,51 @@ class InspectDBTestCase(TestCase):\n             out.getvalue(),\n         )\n \n+    def test_related_name_for_same_relation(self):\n+        \"\"\"\n+        Test that inspectdb generates related_name for foreign keys\n+        to the same table to avoid reverse accessor clashes.\n+        \"\"\"\n+        out = StringIO()\n+        with connection.cursor() as cursor:\n+            # Mock the introspection to simulate a table with multiple FKs to the same table\n+            with mock.patch.object(\n+                connection.introspection, 'get_table_list',\n+                return_value=[TableInfo(name='inspectdb_multiple_fks', type='t')]\n+            ), mock.patch.object(\n+                connection.introspection, 'get_table_description',\n+                return_value=[\n+                    TableInfo(name='id', type_code=None, display_size=None, internal_size=None, precision=None, scale=None, null_ok=False),\n+                    TableInfo(name='fk1', type_code=None, display_size=None, internal_size=None, precision=None, scale=None, null_ok=True),\n+                    TableInfo(name='fk2', type_code=None, display_size=None, internal_size=None, precision=None, scale=None, null_ok=True),\n+                ]\n+            ), mock.patch.object(\n+                connection.introspection, 'get_relations',\n+                return_value={\n+                    'fk1': ('id', 'inspectdb_same_table'),\n+                    'fk2': ('id', 'inspectdb_same_table'),\n+                }\n+            ), mock.patch.object(\n+                connection.introspection, 'get_constraints',\n+                return_value={}\n+            ), mock.patch.object(\n+                connection.introspection, 'get_primary_key_columns',\n+                return_value=['id']\n+            ):\n+                call_command('inspectdb', 'inspectdb_multiple_fks', stdout=out)\n+        output = out.getvalue()\n+        # The test should check that related_name is added to foreign keys\n+        self.assertIn(\"related_name='+'\", output)\n+        # Check that both foreign keys have related_name\n+        fk1_line = re.search(r'fk1 = .*ForeignKey.*', output)\n+        fk2_line = re.search(r'fk2 = .*ForeignKey.*', output)\n+        self.assertIsNotNone(fk1_line, \"fk1 field not found in output\")\n+        self.assertIsNotNone(fk2_line, \"fk2 field not found in output\")\n+        self.assertIn(\"related_name=\", fk1_line.group(0))\n+        self.assertIn(\"related_name=\", fk2_line.group(0))\n+    \n+\n+\n     def test_digits_column_name_introspection(self):\n         \"\"\"Introspection of column names consist/start with digits (#16536/#17676)\"\"\"\n         char_field_type = connection.features.introspected_field_types[\"CharField\"]\n@@ -615,3 +660,4 @@ class InspectDBTransactionalTests(TransactionTestCase):\n         finally:\n             with connection.cursor() as cursor:\n                 cursor.execute(\"DROP TABLE %s\" % table_name)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-25079",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\nindex e39d007378..af56fca78b 100644\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -1159,6 +1159,32 @@ def test_offset_text_loc():\n     # height as the parent, so use the parents bbox.\n     assert cb.ax.yaxis.offsetText.get_position()[1] > ax.bbox.y1\n \n+def test_colorbar_update_norm():\n+    \"\"\"Test that updating the norm of a mappable with an existing colorbar works.\"\"\"\n+    # Create some random data\n+    rng = np.random.default_rng(0)\n+    img = rng.uniform(1, 5, (25, 25))\n+    # Create the plot with a colorbar\n+    fig, ax = plt.subplots()\n+    plot = ax.pcolormesh(img)\n+    cbar = fig.colorbar(plot, ax=ax)\n+    # Set vmin and vmax for LogNorm\n+    vmin, vmax = 1, 5\n+    # Update the norm to LogNorm\n+    plot.norm = LogNorm(vmin, vmax)\n+    # Force an update\n+    plot.changed()\n+    # Check that the norm was properly updated\n+    assert isinstance(plot.norm, LogNorm)\n+    assert plot.norm.vmin == vmin\n+    assert plot.norm.vmax == vmax\n+    # Check that the colorbar was updated properly\n+    assert isinstance(cbar.norm, LogNorm)\n+    assert cbar.norm.vmin == vmin\n+    assert cbar.norm.vmax == vmax\n+    plt.close(fig)\n+\n+\n \n def test_title_text_loc():\n     plt.style.use('mpl20')\n@@ -1215,3 +1241,4 @@ def test_colorbar_axes_parmeters():\n     fig.colorbar(im, ax=(ax[0], ax[1]))\n     fig.colorbar(im, ax={i: _ax for i, _ax in enumerate(ax)}.values())\n     fig.draw_without_rendering()\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-16379",
        "model_patch": "diff --git a/tests/cache/tests.py b/tests/cache/tests.py\nindex 937a55acc5..8b705d8b8c 100644\n--- a/tests/cache/tests.py\n+++ b/tests/cache/tests.py\n@@ -1762,6 +1762,37 @@ class FileBasedCacheTests(BaseCacheTests, TestCase):\n         with open(cache_file, \"rb\") as fh:\n             self.assertIs(cache._is_expired(fh), True)\n \n+    def test_has_key_race_condition(self):\n+        \"\"\"\n+        Test that FileBasedCache.has_key() handles race conditions where the cache\n+        file is deleted between os.path.exists() and open().\n+        \"\"\"\n+        # Create a cache key\n+        cache_key = \"race_key\"\n+        cache_value = \"race_value\"\n+        # Set a value in the cache\n+        self.cache.set(cache_key, cache_value)\n+        # Get the filename for the cache key\n+        fname = self.cache._key_to_file(cache_key)\n+        # Verify the file exists\n+        self.assertTrue(os.path.exists(fname))\n+        # Mock os.path.exists to return True but delete the file before open() is called\n+        original_exists = os.path.exists\n+        def mock_exists(path):\n+            if path == fname:\n+                result = original_exists(path)\n+                if result:\n+                    # Delete the file to simulate race condition\n+                    os.remove(path)\n+                return result\n+            return original_exists(path)\n+        with mock.patch('os.path.exists', mock_exists):\n+            # This should not raise FileNotFoundError\n+            result = self.cache.has_key(cache_key)\n+            self.assertFalse(result)\n+    \n+\n+\n \n @unittest.skipUnless(RedisCache_params, \"Redis backend not configured\")\n @override_settings(\n@@ -2926,3 +2957,4 @@ class CacheHandlerTest(SimpleTestCase):\n         # .all() initializes all caches.\n         self.assertEqual(len(test_caches.all(initialized_only=True)), 2)\n         self.assertEqual(test_caches.all(), test_caches.all(initialized_only=True))\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-5221",
        "model_patch": "diff --git a/testing/python/fixtures.py b/testing/python/fixtures.py\nindex 48f8028e6..5f41cb3fa 100644\n--- a/testing/python/fixtures.py\n+++ b/testing/python/fixtures.py\n@@ -3294,6 +3294,42 @@ class TestShowFixtures(object):\n         \"\"\"\n         )\n \n+    def test_show_fixtures_with_scope(testdir):\n+        \"\"\"Test that fixture scope is displayed with --fixtures flag.\"\"\"\n+        testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            @pytest.fixture\n+            def function_fixture():\n+                '''function scope fixture'''\n+                return 1\n+            @pytest.fixture(scope=\"module\")\n+            def module_fixture():\n+                '''module scope fixture'''\n+                return 2\n+            @pytest.fixture(scope=\"session\")\n+            def session_fixture():\n+                '''session scope fixture'''\n+                return 3\n+            @pytest.fixture(scope=\"class\")\n+            def class_fixture():\n+                '''class scope fixture'''\n+                return 4\n+            def test_dummy(function_fixture, module_fixture, session_fixture, class_fixture):\n+                assert True\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(\"--fixtures\")\n+        # These lines should fail until the feature is implemented\n+        result.stdout.fnmatch_lines([\n+            \"*function_fixture*function scope fixture\",\n+            \"*module_fixture*[module scope]*module scope fixture\",\n+            \"*session_fixture*[session scope]*session scope fixture\",\n+            \"*class_fixture*[class scope]*class scope fixture\",\n+        ])\n+    \n+\n+\n     def test_fixture_disallow_twice(self):\n         \"\"\"Test that applying @pytest.fixture twice generates an error (#2334).\"\"\"\n         with pytest.raises(ValueError):\n@@ -3937,3 +3973,4 @@ def test_call_fixture_function_error():\n \n     with pytest.raises(pytest.fail.Exception):\n         assert fix() == 1\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-13895",
        "model_patch": "diff --git a/sympy/simplify/tests/test_simplify.py b/sympy/simplify/tests/test_simplify.py\nindex 4bea38bc8f..cd6e45895e 100644\n--- a/sympy/simplify/tests/test_simplify.py\n+++ b/sympy/simplify/tests/test_simplify.py\n@@ -688,6 +688,22 @@ def inverse(self, argindex=1):\n     assert simplify(f(g(sin(x)**2 + cos(x)**2))) == 1\n     assert simplify(f(g(x, y))) == f(g(x, y))\n \n+def test_issue_simplify_negative_power():\n+    x = Symbol('x')\n+    e = (-x/4 - S(1)/12)**x - 1\n+    f = simplify(e)\n+    # Test with a specific value to verify equivalence\n+    a = S(9)/5\n+    # Numerical evaluation should be the same\n+    assert abs(float(e.subs(x, a)) - float(f.subs(x, a))) < 1e-10\n+    # The simplified expression should be equivalent to the original\n+    # for various numerical values\n+    for val in [1, 2, S(1)/3, S(5)/2]:\n+        orig = e.subs(x, val).n()\n+        simp = f.subs(x, val).n()\n+        assert abs(float(orig - simp)) < 1e-10\n+\n+\n \n def test_clear_coefficients():\n     from sympy.simplify.simplify import clear_coefficients\n@@ -700,3 +716,4 @@ def test_clear_coefficients():\n     assert clear_coefficients(S.Infinity, x) == (S.Infinity, x)\n     assert clear_coefficients(-S.Pi, x) == (S.Pi, -x)\n     assert clear_coefficients(2 - S.Pi/3, x) == (pi, -3*x + 6)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-17022",
        "model_patch": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex e56fd6461e..8040a5b68c 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1116,6 +1116,28 @@ def test_MatrixSymbol_issue_15578():\n     g = lambdify(A, A**3)\n     assert numpy.allclose(g(A0), numpy.array([[37, 54], [81, 118]]))\n \n+def test_Identity_issue_lambdify():\n+    from sympy.functions.elementary.trigonometric import atan as arctan\n+    from sympy.matrices.expressions import Identity\n+    if not numpy:\n+        skip(\"numpy not installed\")\n+    n = symbols('n', integer=True)\n+    A = MatrixSymbol(\"A\", n, n)\n+    # Create a lambdified function that adds an identity matrix to A\n+    f = lambdify(A, A + Identity(n))\n+    # Test with a simple 2x2 matrix\n+    A_val = numpy.array([[1, 2], [3, 4]])\n+    # The result should be the original matrix plus the identity matrix\n+    expected = numpy.array([[2, 2], [3, 5]])\n+    result = f(A_val)\n+    assert numpy.allclose(result, expected)\n+    # Also test with a different matrix to ensure it works generally\n+    B_val = numpy.array([[5, 6], [7, 8]])\n+    expected_B = numpy.array([[6, 6], [7, 9]])\n+    result_B = f(B_val)\n+    assert numpy.allclose(result_B, expected_B)\n+\n+\n \n def test_issue_15654():\n     if not scipy:\n@@ -1164,3 +1186,4 @@ def test_issue_16930():\n     f = lambda x:  S.GoldenRatio * x**2\n     f_ = lambdify(x, f(x), modules='scipy')\n     assert f_(1) == scipy.constants.golden_ratio\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13658",
        "model_patch": "diff --git a/tests/admin_scripts/test_django_admin_py.py b/tests/admin_scripts/test_django_admin_py.py\nindex b8b42fb75a..f87f28159a 100644\n--- a/tests/admin_scripts/test_django_admin_py.py\n+++ b/tests/admin_scripts/test_django_admin_py.py\n@@ -37,3 +37,26 @@ class DeprecationTests(SimpleTestCase):\n         django_admin_py_out, _ = self._run_test([self.django_admin_py, '--version'])\n         django_out, _ = self._run_test(['-m', 'django', '--version'])\n         self.assertEqual(django_admin_py_out, django_out)\n+\n+    def test_custom_argv_prog_name(self):\n+        \"\"\"\n+        Test that ManagementUtility uses the computed prog_name when creating\n+        CommandParser, not sys.argv[0].\n+        \"\"\"\n+        custom_prog_name = 'custom-django-admin'\n+        args = [custom_prog_name, 'help']\n+        # Capture the output of the help command with custom argv\n+        process = subprocess.run(\n+            [sys.executable, '-c', \n+              'from django.core.management import execute_from_command_line; '\n+             'execute_from_command_line(%r)' % args],\n+            stdout=subprocess.PIPE,\n+            stderr=subprocess.PIPE,\n+            text=True,\n+        )\n+        # The output should contain the custom program name, not sys.argv[0]\n+        self.assertIn(f'Usage: {custom_prog_name} subcommand', process.stdout)\n+        self.assertNotIn('Usage: -c subcommand', process.stdout)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-13497",
        "model_patch": "diff --git a/sklearn/feature_selection/tests/test_mutual_info.py b/sklearn/feature_selection/tests/test_mutual_info.py\nindex 7ba7d37e8f..75dccbf72c 100644\n--- a/sklearn/feature_selection/tests/test_mutual_info.py\n+++ b/sklearn/feature_selection/tests/test_mutual_info.py\n@@ -198,3 +198,28 @@ def test_mutual_info_options():\n         assert_array_equal(mi_3, mi_4)\n \n     assert not np.allclose(mi_1, mi_3)\n+\n+def test_estimate_mi_discrete_features():\n+    # Test that _estimate_mi correctly handles different types of discrete_features\n+    from sklearn.feature_selection.mutual_info_ import _estimate_mi\n+    X = np.array([[0, 0, 0],\n+                  [1, 1, 0],\n+                  [2, 0, 1],\n+                  [2, 0, 1],\n+                  [2, 0, 1]], dtype=float)\n+    y = np.array([0, 1, 2, 2, 1], dtype=float)\n+    # Test with boolean mask\n+    bool_mask = np.array([True, False, True])\n+    mi_bool_mask = _estimate_mi(X, y, discrete_features=bool_mask, random_state=0)\n+    # Test with array of indices\n+    indices = np.array([0, 2])\n+    mi_indices = _estimate_mi(X, y, discrete_features=indices, random_state=0)\n+    # Results should be the same\n+    assert_array_equal(mi_bool_mask, mi_indices)\n+    # Test with boolean value\n+    mi_all_discrete = _estimate_mi(X, y, discrete_features=True, random_state=0)\n+    mi_all_continuous = _estimate_mi(X, y, discrete_features=False, random_state=0)\n+    # Results should be different\n+    assert not np.allclose(mi_all_discrete, mi_all_continuous)\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-12471",
        "model_patch": "diff --git a/sklearn/preprocessing/tests/test_encoders.py b/sklearn/preprocessing/tests/test_encoders.py\nindex d5ac50a257..2a54ffb8fb 100644\n--- a/sklearn/preprocessing/tests/test_encoders.py\n+++ b/sklearn/preprocessing/tests/test_encoders.py\n@@ -250,6 +250,28 @@ def test_one_hot_encoder_handle_unknown():\n     oh = OneHotEncoder(handle_unknown='42')\n     assert_raises(ValueError, oh.fit, X)\n \n+def test_one_hot_encoder_handle_unknown_with_strings():\n+    # Test that OneHotEncoder with handle_unknown='ignore' works correctly\n+    # with string categories, even when the strings have different lengths\n+    # Create training data with string categories of different lengths\n+    X_train = np.array(['22', '333', '4444', '11111111']).reshape(-1, 1)\n+    # Create test data with an unknown category and a known category\n+    X_test = np.array(['55555', '22']).reshape(-1, 1)\n+    # Fit encoder with handle_unknown='ignore'\n+    enc = OneHotEncoder(handle_unknown='ignore')\n+    enc.fit(X_train)\n+    # Transform should work without error\n+    X_test_transformed = enc.transform(X_test).toarray()\n+    # Check that the known category '22' is encoded correctly (second row)\n+    # and the unknown category '55555' is all zeros (first row)\n+    expected_result = np.zeros((2, 4))\n+    expected_result[1, 0] = 1  # '22' is the first category\n+    assert_array_equal(X_test_transformed, expected_result)\n+    # Ensure the original test data wasn't modified\n+    assert_equal(X_test[0, 0], '55555')\n+    assert_equal(X_test[1, 0], '22')\n+\n+\n \n def test_one_hot_encoder_not_fitted():\n     X = np.array([['a'], ['b']])\n@@ -659,3 +681,4 @@ def test_one_hot_encoder_warning():\n     enc = OneHotEncoder()\n     X = [['Male', 1], ['Female', 3]]\n     np.testing.assert_no_warnings(enc.fit_transform, X)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-25332",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex ec6bdcc2fe..9b75b283e6 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -282,3 +282,28 @@ def test_dynamic_norm():\n def test_vertexselector():\n     line, = plt.plot([0, 1], picker=True)\n     pickle.loads(pickle.dumps(VertexSelector(line)))\n+\n+def test_pickle_figure_with_aligned_labels():\n+    \"\"\"Test that a figure with aligned labels can be pickled.\"\"\"\n+    # Create a figure with multiple subplots\n+    fig = plt.figure()\n+    ax1 = fig.add_subplot(211)\n+    ax2 = fig.add_subplot(212)\n+    # Add some data and labels\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+    # Align the labels - this is what causes the pickling issue\n+    fig.align_labels()\n+    # Try to pickle the figure - this should not raise an exception\n+    pickle_data = pickle.dumps(fig)\n+    # Verify we can unpickle it\n+    fig_unpickled = pickle.loads(pickle_data)\n+    # Basic verification that the unpickled figure has the expected structure\n+    assert len(fig_unpickled.axes) == 2\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-15678",
        "model_patch": "diff --git a/sympy/geometry/tests/test_util.py b/sympy/geometry/tests/test_util.py\nindex a6ded44062..73770b6e6d 100644\n--- a/sympy/geometry/tests/test_util.py\n+++ b/sympy/geometry/tests/test_util.py\n@@ -20,6 +20,22 @@ def test_idiff():\n     assert True in [sol.diff(x, 3).equals(explicit) for sol in solve(circ, y)]\n     assert idiff(x + t + y, [y, t], x) == -Derivative(t, x) - 1\n \n+def test_idiff_eq_and_function():\n+    from sympy import Eq, exp, Function\n+    x = Symbol('x', real=True)\n+    y = Symbol('y', real=True)\n+    f = Function('f')\n+    # Test with Eq\n+    eq1 = Eq(y*exp(y), x*exp(x))\n+    assert idiff(eq1, y, x) == (x + 1)*exp(x - y)/(y + 1)\n+    # Test with function expression\n+    eq2 = f(x)*exp(f(x)) - x*exp(x)\n+    assert idiff(eq2, f(x), x) == (x + 1)*exp(x - f(x))/(f(x) + 1)\n+    # Verify the existing functionality still works\n+    eq3 = y*exp(y) - x*exp(x)\n+    assert idiff(eq3, y, x) == (x + 1)*exp(x - y)/(y + 1)\n+\n+\n \n def test_intersection():\n     assert intersection(Point(0, 0)) == []\n@@ -124,3 +140,4 @@ def test_farthest_points_closest_points():\n     assert farthest_points((1, 1), (0, 0)) == set(\n         [(Point2D(0, 0), Point2D(1, 1))])\n     raises(ValueError, lambda: farthest_points((1, 1)))\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-19007",
        "model_patch": "diff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex da17b9dbb5..bc4a094007 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -222,6 +222,19 @@ def test_deblock():\n \n     assert deblock(reblock_2x2(B)) == B\n \n+def test_blockmatrix_element_access():\n+    n, i = symbols('n, i', integer=True)\n+    A = MatrixSymbol('A', 1, 1)\n+    B = MatrixSymbol('B', n, 1)\n+    C = BlockMatrix([[A], [B]])\n+    # Test that symbolic indexing doesn't incorrectly simplify to just A's element\n+    # This should fail with the current implementation\n+    assert C[i, 0] != A[i, 0]\n+    # Test with specific indices\n+    assert C[0, 0] == A[0, 0]  # First element should come from A\n+    assert C[1, 0] == B[0, 0]  # Second element should come from B\n+\n+\n def test_block_collapse_type():\n     bm1 = BlockDiagMatrix(ImmutableMatrix([1]), ImmutableMatrix([2]))\n     bm2 = BlockDiagMatrix(ImmutableMatrix([3]), ImmutableMatrix([4]))\n@@ -232,3 +245,4 @@ def test_block_collapse_type():\n     assert block_collapse(Transpose(bm1)).__class__ == BlockDiagMatrix\n     assert bc_transpose(Transpose(bm1)).__class__ == BlockDiagMatrix\n     assert bc_inverse(Inverse(bm1)).__class__ == BlockDiagMatrix\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11422",
        "model_patch": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex 42bcd0a50b..e135d82e32 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -642,3 +642,23 @@ class StatReloaderTests(ReloaderTests, IntegrationTests):\n             snapshot = list(self.reloader.snapshot_files())\n             self.assertEqual(len(snapshot), 1)\n             self.assertEqual(snapshot[0][0], self.existing_file)\n+\n+    def test_manage_py_file_included_in_watched_files(self):\n+        \"\"\"Check that manage.py is included in the files watched by the reloader.\"\"\"\n+        reloader = autoreload.StatReloader()\n+        # Create a temporary manage.py file\n+        with self.temporary_file('manage.py') as manage_py:\n+            # Write some content to the file\n+            with open(manage_py, 'w') as f:\n+                                                f.write('#!/usr/bin/env python\\nimport os\\nimport sys\\n\\ndef main():\\n    pass')\n+            # Get the absolute path of manage.py\n+            manage_py_path = Path(manage_py).resolve().absolute()\n+            # Mock sys.argv to simulate running manage.py\n+            with mock.patch('sys.argv', [str(manage_py_path)]):\n+                # Get the files being watched by the reloader\n+                watched_files = reloader.watched_files()\n+                # Assert that manage.py is in the watched files\n+                self.assertIn(manage_py_path, watched_files)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-13146",
        "model_patch": "diff --git a/sympy/simplify/tests/test_simplify.py b/sympy/simplify/tests/test_simplify.py\nindex 6acf690006..d9b9817505 100644\n--- a/sympy/simplify/tests/test_simplify.py\n+++ b/sympy/simplify/tests/test_simplify.py\n@@ -30,59 +30,50 @@ def test_factorial_simplify():\n     assert simplify(factorial(factorial(x))) == factorial(factorial(x))\n \n \n+\n def test_simplify_expr():\n     x, y, z, k, n, m, w, f, s, A = symbols('x,y,z,k,n,m,w,f,s,A')\n-\n     assert all(simplify(tmp) == tmp for tmp in [I, E, oo, x, -x, -oo, -E, -I])\n-\n     e = 1/x + 1/y\n     assert e != (x + y)/(x*y)\n     assert simplify(e) == (x + y)/(x*y)\n-\n     e = A**2*s**4/(4*pi*k*m**3)\n     assert simplify(e) == e\n-\n     e = (4 + 4*x - 2*(2 + 2*x))/(2 + 2*x)\n     assert simplify(e) == 0\n-\n     e = (-4*x*y**2 - 2*y**3 - 2*x**2*y)/(x + y)**2\n     assert simplify(e) == -2*y\n-\n     e = -x - y - (x + y)**(-1)*y**2 + (x + y)**(-1)*x**2\n     assert simplify(e) == -2*y\n-\n     e = (x + x*y)/x\n     assert simplify(e) == 1 + y\n-\n     e = (f(x) + y*f(x))/f(x)\n     assert simplify(e) == 1 + y\n-\n     e = (2 * (1/n - cos(n * pi)/n))/pi\n     assert simplify(e) == (-cos(pi*n) + 1)/(pi*n)*2\n-\n     e = integrate(1/(x**3 + 1), x).diff(x)\n     assert simplify(e) == 1/(x**3 + 1)\n-\n     e = integrate(x/(x**2 + 3*x + 1), x).diff(x)\n     assert simplify(e) == x/(x**2 + 3*x + 1)\n-\n     A = Matrix([[2*k - m*w**2, -k], [-k, k - m*w**2]]).inv()\n     assert simplify((A*Matrix([0, f]))[1]) == \\\n         -f*(2*k - m*w**2)/(k**2 - (k - m*w**2)*(2*k - m*w**2))\n-\n     f = -x + y/(z + t) + z*x/(z + t) + z*a/(z + t) + t*x/(z + t)\n     assert simplify(f) == (y + a*z)/(z + t)\n-\n     A, B = symbols('A,B', commutative=False)\n-\n     assert simplify(A*B - B*A) == A*B - B*A\n     assert simplify(A/(1 + y/x)) == x*A/(x + y)\n     assert simplify(A*(1/x + 1/y)) == A/x + A/y  #(x + y)*A/(x*y)\n-\n     assert simplify(log(2) + log(3)) == log(6)\n     assert simplify(log(2*x) - log(2)) == log(x)\n-\n     assert simplify(hyper([], [], x)) == exp(x)\n+    # Test for issue with floating-point vs rational exponents\n+    expr1 = S(1)/2*x**2.5\n+    expr2 = S(1)*x**(S(5)/2)/2\n+    res = expr1 - expr2\n+    assert simplify(res) == 0\n+    assert simplify(res.evalf(5)) == 0\n+\n \n \n def test_issue_3557():\n@@ -652,3 +643,4 @@ def test_clear_coefficients():\n     assert clear_coefficients(S.Infinity, x) == (S.Infinity, x)\n     assert clear_coefficients(-S.Pi, x) == (S.Pi, -x)\n     assert clear_coefficients(2 - S.Pi/3, x) == (pi, -3*x + 6)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12983",
        "model_patch": "diff --git a/tests/utils_tests/test_text.py b/tests/utils_tests/test_text.py\nindex 9dbf9367c3..8e51f4c78a 100644\n--- a/tests/utils_tests/test_text.py\n+++ b/tests/utils_tests/test_text.py\n@@ -187,6 +187,7 @@ class TestUtilsText(SimpleTestCase):\n         lazy_numeric = lazystr(text.phone2numeric('0800 flowers'))\n         self.assertEqual(lazy_numeric, '0800 3569377')\n \n+\n     def test_slugify(self):\n         items = (\n             # given - expected - Unicode?\n@@ -197,11 +198,19 @@ class TestUtilsText(SimpleTestCase):\n             ('    foo \u0131\u00e7 bar', 'foo-\u0131\u00e7-bar', True),\n             ('\u4f60\u597d', '\u4f60\u597d', True),\n             ('\u0130stanbul', 'istanbul', True),\n+            # Test cases for stripping dashes and underscores\n+            ('___This is a test', 'this-is-a-test', False),\n+            ('This is a test---', 'this-is-a-test', False),\n+            ('___This is a test---', 'this-is-a-test', False),\n+            ('___This_is_a_test---', 'this-is-a-test', False),\n+            ('_-_This_is_a_test_-_', 'this-is-a-test', False),\n         )\n         for value, output, is_unicode in items:\n             self.assertEqual(text.slugify(value, allow_unicode=is_unicode), output)\n         # interning the result may be useful, e.g. when fed to Path.\n         self.assertEqual(sys.intern(text.slugify('a')), 'a')\n+    \n+\n \n     @ignore_warnings(category=RemovedInDjango40Warning)\n     def test_unescape_entities(self):\n@@ -273,3 +282,4 @@ class TestUtilsText(SimpleTestCase):\n         )\n         with override('fr'):\n             self.assertEqual('Ajout de article \u00ab\\xa0My first try\\xa0\u00bb.', s)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pylint-dev__pylint-5859",
        "model_patch": "diff --git a/tests/checkers/unittest_misc.py b/tests/checkers/unittest_misc.py\nindex 23e19a9d0..312a9db7e 100644\n--- a/tests/checkers/unittest_misc.py\n+++ b/tests/checkers/unittest_misc.py\n@@ -120,3 +120,22 @@ class TestFixme(CheckerTestCase):\n         \"\"\"\n         with self.assertNoMessages():\n             self.checker.process_tokens(_tokenize_str(code))\n+\n+    def test_fixme_with_punctuation_tag(self) -> None:\n+        \"\"\"Test that note tags consisting entirely of punctuation are detected.\"\"\"\n+        code = \"\"\"a = 1\n+                # ???: this is a note with punctuation tag\n+                \"\"\"\n+        self.checker.config.notes = [\"???\"]\n+        with self.assertAddsMessages(\n+            MessageTest(\n+                msg_id=\"fixme\",\n+                line=2,\n+                args=\"???: this is a note with punctuation tag\",\n+                col_offset=13,\n+            )\n+        ):\n+            self.checker.process_tokens(_tokenize_str(code))\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-16873",
        "model_patch": "diff --git a/tests/template_tests/filter_tests/test_join.py b/tests/template_tests/filter_tests/test_join.py\nindex 08f68537ee..844bce8238 100644\n--- a/tests/template_tests/filter_tests/test_join.py\n+++ b/tests/template_tests/filter_tests/test_join.py\n@@ -66,11 +66,18 @@ class FunctionTests(SimpleTestCase):\n             \"&lt;a&gt;&lt;br&gt;&lt;img&gt;&lt;br&gt;&lt;/a&gt;\",\n         )\n \n+\n     def test_autoescape_off(self):\n-        self.assertEqual(\n-            join([\"<a>\", \"<img>\", \"</a>\"], \"<br>\", autoescape=False),\n-            \"<a>&lt;br&gt;<img>&lt;br&gt;</a>\",\n-        )\n+        \"\"\"\n+        When autoescape is off, the joining string should not be escaped.\n+        \"\"\"\n+        value = [\"<a>\", \"<img>\", \"</a>\"]\n+        arg = \"<br>\"\n+        result = join(value, arg, autoescape=False)\n+        expected = \"<a><br><img><br></a>\"\n+        self.assertEqual(result, expected)\n+    \n+\n \n     def test_noniterable_arg(self):\n         obj = object()\n@@ -79,3 +86,4 @@ class FunctionTests(SimpleTestCase):\n     def test_noniterable_arg_autoescape_off(self):\n         obj = object()\n         self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-23913",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_legend.py b/lib/matplotlib/tests/test_legend.py\nindex 16847e0be6..7169208949 100644\n--- a/lib/matplotlib/tests/test_legend.py\n+++ b/lib/matplotlib/tests/test_legend.py\n@@ -782,6 +782,25 @@ def test_get_set_draggable():\n     legend.set_draggable(False)\n     assert not legend.get_draggable()\n \n+def test_legend_draggable_keyword():\n+    \"\"\"Test that legend can be created with draggable keyword argument.\"\"\"\n+    # Create a simple plot\n+    fig, ax = plt.subplots()\n+    ax.plot([1, 2, 3], label='test')\n+    # Create legend with draggable=True\n+    legend = ax.legend(draggable=True)\n+    # Check that the legend is draggable\n+    assert legend.get_draggable()\n+    # Create another legend with draggable=False\n+    legend2 = ax.legend(draggable=False)\n+    # Check that the legend is not draggable\n+    assert not legend2.get_draggable()\n+    # Create a legend with default (should not be draggable)\n+    legend3 = ax.legend()\n+    # Check that the legend is not draggable by default\n+    assert not legend3.get_draggable()\n+\n+\n \n def test_alpha_handles():\n     x, n, hh = plt.hist([1, 2, 3], alpha=0.25, label='data', color='red')\n@@ -962,3 +981,4 @@ def test_ncol_ncols(fig_test, fig_ref):\n     ncols = 3\n     fig_test.legend(strings, ncol=ncols)\n     fig_ref.legend(strings, ncols=ncols)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-14774",
        "model_patch": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex e44757ccf8..9fea6cd74c 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -893,6 +893,22 @@ def test_latex_inverse():\n     assert latex(1/x) == \"\\\\frac{1}{x}\"\n     assert latex(1/(x + y)) == \"\\\\frac{1}{x + y}\"\n \n+def test_latex_inverse_trig_full_style():\n+    from sympy import acos\n+    from sympy import atan\n+    from sympy import acot\n+    from sympy.functions.elementary.trigonometric import acsc\n+    from sympy.functions.elementary.trigonometric import asec\n+    # Test that all inverse trig functions work with full style\n+    assert latex(asin(x), inv_trig_style=\"full\") == r\"\\arcsin{x}\"\n+    assert latex(acos(x), inv_trig_style=\"full\") == r\"\\arccos{x}\"\n+    assert latex(atan(x), inv_trig_style=\"full\") == r\"\\arctan{x}\"\n+    assert latex(acot(x), inv_trig_style=\"full\") == r\"\\arccot{x}\"\n+    # These should fail before the fix and pass after\n+    assert latex(acsc(x), inv_trig_style=\"full\") == r\"\\arccsc{x}\"\n+    assert latex(asec(x), inv_trig_style=\"full\") == r\"\\arcsec{x}\"\n+\n+\n \n def test_latex_DiracDelta():\n     assert latex(DiracDelta(x)) == r\"\\delta\\left(x\\right)\"\n@@ -1759,3 +1775,4 @@ def test_WedgeProduct_printing():\n     from sympy.diffgeom import WedgeProduct\n     wp = WedgeProduct(R2.dx, R2.dy)\n     assert latex(wp) == r\"\\mathrm{d}x \\wedge \\mathrm{d}y\"\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-13142",
        "model_patch": "diff --git a/sklearn/mixture/tests/test_gaussian_mixture.py b/sklearn/mixture/tests/test_gaussian_mixture.py\nindex 4d549ccd7b..56529e4842 100644\n--- a/sklearn/mixture/tests/test_gaussian_mixture.py\n+++ b/sklearn/mixture/tests/test_gaussian_mixture.py\n@@ -597,6 +597,22 @@ def test_gaussian_mixture_fit_predict(seed, max_iter, tol):\n         assert_array_equal(Y_pred1, Y_pred2)\n         assert_greater(adjusted_rand_score(Y, Y_pred2), .95)\n \n+def test_gaussian_mixture_fit_predict_n_init():\n+    \"\"\"Test that fit_predict and predict return the same labels when n_init > 1.\"\"\"\n+    rng = np.random.RandomState(0)\n+    X = rng.randn(1000, 5)\n+    # Test with n_init=1 (should pass)\n+    gm1 = GaussianMixture(n_components=5, n_init=1, random_state=0)\n+    labels1_fit_predict = gm1.fit_predict(X)\n+    labels1_predict = gm1.predict(X)\n+    assert_array_equal(labels1_fit_predict, labels1_predict)\n+    # Test with n_init=5 (should pass after fix)\n+    gm5 = GaussianMixture(n_components=5, n_init=5, random_state=0)\n+    labels5_fit_predict = gm5.fit_predict(X)\n+    labels5_predict = gm5.predict(X)\n+    assert_array_equal(labels5_fit_predict, labels5_predict)\n+\n+\n \n def test_gaussian_mixture_fit():\n     # recover the ground truth\n@@ -1033,3 +1049,4 @@ def test_init():\n                                max_iter=1, random_state=random_state).fit(X)\n \n         assert gmm2.lower_bound_ >= gmm1.lower_bound_\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-7432",
        "model_patch": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 0b1c0b49b..c4dffcb47 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1205,3 +1205,21 @@ def test_relpath_rootdir(testdir):\n     result.stdout.fnmatch_lines(\n         [\"SKIPPED [[]1[]] tests/test_1.py:2: unconditional skip\"]\n     )\n+\n+def test_skip_location_with_runxfail(testdir):\n+    \"\"\"Test that skip location is correctly reported when using --runxfail.\"\"\"\n+    testdir.makepyfile(\n+        \"\"\"\n+        import pytest\n+        @pytest.mark.skip(reason=\"skip reason\")\n+        def test_skip_location():\n+            assert 0\n+        \"\"\"\n+    )\n+    result = testdir.runpytest(\"-rs\", \"--runxfail\")\n+    # The skip location should point to the test file, not to skipping.py\n+    result.stdout.fnmatch_lines([\"*SKIPPED*test_skip_location_with_runxfail.py:3: skip reason\"])\n+    # Make sure it doesn't point to skipping.py\n+    assert \"skipping.py\" not in result.stdout.str()\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15347",
        "model_patch": "diff --git a/tests/messages_tests/test_cookie.py b/tests/messages_tests/test_cookie.py\nindex 53cf693f61..c0a556af13 100644\n--- a/tests/messages_tests/test_cookie.py\n+++ b/tests/messages_tests/test_cookie.py\n@@ -177,3 +177,24 @@ class CookieTests(BaseTests, SimpleTestCase):\n         storage = self.get_storage()\n         self.assertIsInstance(encode_decode(mark_safe(\"<b>Hello Django!</b>\")), SafeData)\n         self.assertNotIsInstance(encode_decode(\"<b>Hello Django!</b>\"), SafeData)\n+\n+    def test_empty_extra_tags_serialization(self):\n+        \"\"\"\n+        Test that empty string extra_tags are correctly preserved when\n+        serializing and deserializing messages.\n+        \"\"\"\n+        # Create a message with empty string extra_tags\n+        original_message = Message(constants.INFO, \"Test message\", extra_tags=\"\")\n+        # Serialize the message\n+        encoder = MessageEncoder()\n+        encoded_message = encoder.encode(original_message)\n+        # Deserialize the message\n+        decoder = MessageDecoder()\n+        decoded_message = decoder.decode(encoded_message)\n+        # Check that extra_tags is still an empty string, not None\n+        self.assertEqual(original_message.extra_tags, \"\")\n+        self.assertEqual(decoded_message.extra_tags, \"\")\n+        self.assertIsNotNone(decoded_message.extra_tags)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12856",
        "model_patch": "diff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 6c062b2990..ad5faef353 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -1501,3 +1501,27 @@ class ConstraintsTests(TestCase):\n                 ]\n \n         self.assertEqual(Model.check(databases=self.databases), [])\n+\n+    def test_unique_constraint_nonexistent_field(self):\n+        @isolate_apps('django.contrib.auth')\n+        class Model(models.Model):\n+            field = models.IntegerField()\n+            class Meta:\n+                constraints = [\n+                    models.UniqueConstraint(\n+                        fields=['field', 'nonexistent_field'],\n+                        name='name',\n+                    ),\n+                ]\n+        errors = Model.check()\n+        expected = [\n+            Error(\n+                \"'nonexistent_field' is not a valid field.\",\n+                obj=Model,\n+                id='models.E012',\n+            ),\n+        ]\n+        self.assertEqual(errors, expected)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12589",
        "model_patch": "diff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py\nindex 95b77ef87b..f8c5882224 100644\n--- a/tests/aggregation/tests.py\n+++ b/tests/aggregation/tests.py\n@@ -1254,6 +1254,33 @@ class AggregateTestCase(TestCase):\n         ).annotate(total=Count('*'))\n         self.assertEqual(dict(long_books_count_breakdown), {None: 1, 1: 4})\n \n+    def test_group_by_subquery_annotation_ambiguous(self):\n+        \"\"\"\n+        Test that GROUP BY works correctly when a field annotation has the\n+        same name as a model field, which could cause ambiguous column errors.\n+        \"\"\"\n+        # Create a model structure similar to the one in the issue\n+        # We'll use the existing models but simulate the same scenario\n+        # Create a subquery that selects a value from a related model\n+        subquery = Book.objects.filter(\n+            publisher=OuterRef('pk'),\n+            pages__gt=400,\n+        ).values('pages')[:1]\n+        # Annotate with a field name that exists in the Book model\n+        # This creates a potential ambiguity with the 'name' field\n+        publishers = Publisher.objects.annotate(\n+            name=Subquery(subquery, output_field=IntegerField()),\n+            book_count=Count('book'),\n+        )\n+        # Group by the annotated field, which should not cause ambiguity\n+        result = publishers.values('name').annotate(\n+            total_count=Count('name')\n+        )\n+        # Force query execution to check for database errors\n+        list(result)\n+    \n+\n+\n     @skipUnlessDBFeature('supports_subqueries_in_group_by')\n     def test_group_by_exists_annotation(self):\n         \"\"\"\n@@ -1294,3 +1321,4 @@ class AggregateTestCase(TestCase):\n         # with self.assertNumQueries(1) as ctx:\n         #     self.assertSequenceEqual(books_qs, [book])\n         # self.assertEqual(ctx[0]['sql'].count('SELECT'), 2)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-22835",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex e8e90b7680..f4f3ff0951 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1085,6 +1085,25 @@ def test_image_cursor_formatting():\n     data = np.nan\n     assert im.format_cursor_data(data) == '[nan]'\n \n+def test_boundarynorm_cursor_formatting():\n+    from matplotlib.backend_bases import MouseEvent\n+    \"\"\"Test that cursor formatting works with BoundaryNorm.\"\"\"\n+    fig, ax = plt.subplots()\n+    norm = colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n+    X = np.random.randn(10, 10)\n+    pc = ax.imshow(X, cmap='RdBu_r', norm=norm)\n+    # Create a MouseEvent at a specific position\n+    x, y = 5, 5\n+    event = MouseEvent('motion_notify_event', fig.canvas, x, y)\n+    # Get the cursor data\n+    data = pc.get_cursor_data(event)\n+    # This should not raise an exception\n+    formatted = pc.format_cursor_data(data)\n+    # Verify that we get a string representation\n+    assert isinstance(formatted, str)\n+    assert formatted.startswith(\"[\") and formatted.endswith(\"]\")\n+\n+\n \n @check_figures_equal()\n def test_image_array_alpha(fig_test, fig_ref):\n@@ -1416,3 +1435,4 @@ def test_large_image(fig_test, fig_ref, dim, size, msg, origin):\n                        extent=(0, 1, 0, 1),\n                        interpolation='none',\n                        origin=origin)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13964",
        "model_patch": "diff --git a/tests/custom_pk/tests.py b/tests/custom_pk/tests.py\nindex abb4ccd90b..396349299d 100644\n--- a/tests/custom_pk/tests.py\n+++ b/tests/custom_pk/tests.py\n@@ -230,3 +230,33 @@ class CustomPKTests(TestCase):\n         with self.assertRaises(IntegrityError):\n             with transaction.atomic():\n                 Employee.objects.create(first_name=\"Tom\", last_name=\"Smith\")\n+\n+    def test_fk_to_custom_pk_parent_save_after_assignment(self):\n+        \"\"\"\n+        Test that saving a parent object after setting a child with a non-numeric\n+        primary key correctly sets the foreign key value.\n+        \"\"\"\n+        with self.assertRaises(IntegrityError):\n+            with transaction.atomic():\n+                # Create an order with a product that doesn't have its PK set initially\n+                business = Business()\n+                business.employee = Employee()\n+                business.employee.name = \"John\"\n+                business.employee.save()\n+                business.save()\n+                # This should fail because the FK should be set to \"John\", not empty string\n+                self.assertTrue(Business.objects.filter(employee_id=\"\").exists())\n+                # This should succeed but will fail because the FK is not properly set\n+                self.assertTrue(Business.objects.filter(employee=business.employee).exists())\n+        # This should work correctly\n+        with transaction.atomic():\n+            business = Business()\n+            business.employee = Employee(name=\"John\")\n+            business.employee.save()\n+            business.save()\n+            # Verify the relationship is correctly established\n+            self.assertTrue(Business.objects.filter(employee=business.employee).exists())\n+            self.assertFalse(Business.objects.filter(employee_id=\"\").exists())\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-15609",
        "model_patch": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 1f9428c4a2..8dc99f8473 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1749,6 +1749,25 @@ def test_MatrixSymbol_printing():\n     assert latex(A - A*B - B) == r\"A - A B - B\"\n     assert latex(-A*B - A*B*C - B) == r\"- A B - A B C - B\"\n \n+def test_indexed_matrix_expr_latex():\n+    i, j, k = symbols(\"i j k\")\n+    M = MatrixSymbol(\"M\", k, k)\n+    N = MatrixSymbol(\"N\", k, k)\n+    # Test that the LaTeX output for indexed matrix expressions is correct\n+    # and doesn't contain double subscripts\n+    expr = (M*N)[i, j]\n+    latex_str = latex(expr)\n+    # The incorrect output would contain \"_i_1\" (double subscript)\n+    # Correct output should use comma separation or another valid format\n+    assert \"_i_\" not in latex_str\n+    # Check that the output contains the expected summation structure\n+    assert r\"\\sum\" in latex_str\n+    assert \"M\" in latex_str\n+    assert \"N\" in latex_str\n+    assert \"i\" in latex_str\n+    assert \"j\" in latex_str\n+\n+\n \n def test_Quaternion_latex_printing():\n     q = Quaternion(x, y, z, t)\n@@ -1907,3 +1926,4 @@ def unimplemented_expr_sup_sub(expr):\n     assert latex(unimplemented_expr(x)) == r'UnimplementedExpr\\left(x\\right)'\n     assert latex(unimplemented_expr(x**2)) == r'UnimplementedExpr\\left(x^{2}\\right)'\n     assert latex(unimplemented_expr_sup_sub(x)) == r'UnimplementedExpr^{1}_{x}\\left(x\\right)'\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11999",
        "model_patch": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex 0d6e930b06..1b13321d60 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -186,6 +186,22 @@ class GetFieldDisplayTests(SimpleTestCase):\n         self.assertIsNone(WhizIterEmpty(c=None).c)         # Blank value\n         self.assertEqual(WhizIterEmpty(c='').c, '')        # Empty value\n \n+    def test_override_field_display(self):\n+        \"\"\"\n+        Test that get_FOO_display() methods can be overridden.\n+        \"\"\"\n+        class OverrideFieldDisplayModel(models.Model):\n+            choice_field = models.CharField(\n+                max_length=10,\n+                choices=[('A', 'Option A'), ('B', 'Option B')]\n+            )\n+            def get_choice_field_display(self):\n+                return \"overridden value\"\n+        model = OverrideFieldDisplayModel(choice_field='A')\n+        self.assertEqual(model.get_choice_field_display(), \"overridden value\")\n+    \n+\n+\n \n class GetChoicesTests(SimpleTestCase):\n \n@@ -300,3 +316,4 @@ class GetChoicesLimitChoicesToTests(TestCase):\n             field.get_choices(include_blank=False, limit_choices_to={}),\n             [self.bar1, self.bar2],\n         )\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-16041",
        "model_patch": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex c36a79d4e0..3163582453 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -179,6 +179,27 @@ class FormsFormsetTestCase(SimpleTestCase):\n         self.assertTrue(hasattr(formset.empty_form, \"custom_kwarg\"))\n         self.assertEqual(formset.empty_form.custom_kwarg, 1)\n \n+    def test_empty_permitted_in_form_kwargs(self):\n+        \"\"\"\n+        Test that passing empty_permitted in form_kwargs doesn't cause an error\n+        when accessing the empty_form.\n+        \"\"\"\n+        FormSet = formset_factory(CustomKwargForm)\n+        # Test with empty_permitted=True\n+        formset = FormSet(form_kwargs={\"custom_kwarg\": 1, \"empty_permitted\": True})\n+        # This should not raise a KeyError\n+        empty_form = formset.empty_form\n+        self.assertTrue(hasattr(empty_form, \"custom_kwarg\"))\n+        self.assertEqual(empty_form.custom_kwarg, 1)\n+        # Test with empty_permitted=False\n+        formset = FormSet(form_kwargs={\"custom_kwarg\": 1, \"empty_permitted\": False})\n+        # This should not raise a KeyError\n+        empty_form = formset.empty_form\n+        self.assertTrue(hasattr(empty_form, \"custom_kwarg\"))\n+        self.assertEqual(empty_form.custom_kwarg, 1)\n+    \n+\n+\n     def test_formset_validation(self):\n         # FormSet instances can also have an error attribute if validation failed for\n         # any of the forms.\n@@ -1921,3 +1942,4 @@ class DeprecationTests(SimpleTestCase):\n             ChoiceFormSet = formset_factory(Choice, formset=BaseFormSet)\n             formset = ChoiceFormSet()\n             str(formset.management_form)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-9359",
        "model_patch": "diff --git a/testing/code/test_source.py b/testing/code/test_source.py\nindex 53e1bb985..c1e70de3e 100644\n--- a/testing/code/test_source.py\n+++ b/testing/code/test_source.py\n@@ -502,6 +502,31 @@ def test_single_line_finally() -> None:\n     source = getstatement(1, \"try: 1\\nfinally: 3\")\n     assert str(source) == \"finally: 3\"\n \n+def test_decorator_statement_range() -> None:\n+    \"\"\"Test that decorators don't appear in assertion error messages.\"\"\"\n+    def t(func):\n+        return func\n+    source = \"\"\"\n+def test_function():\n+    assert 1 == 2\n+    @t\n+    def inner():\n+        return 42\n+    assert True\n+\"\"\"\n+    source = Source(source.strip())\n+    # Get the statement range for the first assertion (line 2 in the source)\n+    astnode = ast.parse(str(source))\n+    _, start, end = getstatementrange_ast(2, source, assertion=True, astnode=astnode)\n+    # Verify that the statement range doesn't include the decorator\n+    # The range should only include the \"assert 1 == 2\" line\n+    assert end - start == 1, f\"Statement range {start}:{end} includes decorator lines\"\n+    # Verify the content of the extracted statement\n+    statement = source.lines[start:end]\n+    assert len(statement) == 1\n+    assert statement[0].strip() == \"assert 1 == 2\"\n+\n+\n \n def test_issue55() -> None:\n     source = (\n@@ -641,3 +666,4 @@ def test_getstartingblock_multiline() -> None:\n     # fmt: on\n     values = [i for i in x.source.lines if i.strip()]\n     assert len(values) == 4\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14915",
        "model_patch": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex 2a0c05d803..8cc3cbeefe 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -373,3 +373,27 @@ class ModelChoiceFieldTests(TestCase):\n         )\n         with self.assertNumQueries(2):\n             template.render(Context({'form': CategoriesForm()}))\n+\n+    def test_modelchoiceiteratorvalue_is_hashable(self):\n+        \"\"\"\n+        ModelChoiceIteratorValue should be hashable so it can be used\n+        as a dictionary key or in a set.\n+        \"\"\"\n+        field = forms.ModelChoiceField(Author.objects.all())\n+        iterator = field.choices\n+        # Get a ModelChoiceIteratorValue\n+        for _, value in iterator:\n+            if value:  # Skip empty label\n+                # Should be able to use as a dictionary key\n+                d = {value: 'test'}\n+                self.assertEqual(d[value], 'test')\n+                # Should be able to use in a set\n+                s = {value}\n+                self.assertIn(value, s)\n+                # Should be able to compare with original value\n+                self.assertEqual(value, value)\n+                # Only need to test one value\n+                break\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15789",
        "model_patch": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\nindex 22a43fd4cd..b69e5a5c9c 100644\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -217,6 +217,23 @@ class TestUtilsHtml(SimpleTestCase):\n             '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n         )\n \n+    def test_json_script_custom_encoder(self):\n+        import json\n+        \"\"\"Test that json_script accepts a custom encoder parameter.\"\"\"\n+        class CustomJSONEncoder(json.JSONEncoder):\n+            def default(self, o):\n+                if isinstance(o, datetime):\n+                    return o.isoformat()\n+                return super().default(o)\n+        now = datetime.now()\n+        result = json_script(now, \"test_id\", encoder=CustomJSONEncoder)\n+        expected = (\n+            f'<script id=\"test_id\" type=\"application/json\">\"{now.isoformat()}\"</script>'\n+        )\n+        self.assertEqual(result, expected)\n+    \n+\n+\n     def test_smart_urlquote(self):\n         items = (\n             (\"http://\u00f6\u00e4\u00fc.com/\", \"http://xn--4ca9at.com/\"),\n@@ -335,3 +352,4 @@ class TestUtilsHtml(SimpleTestCase):\n         for value in tests:\n             with self.subTest(value=value):\n                 self.assertEqual(urlize(value), value)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-11870",
        "model_patch": "diff --git a/sympy/simplify/tests/test_trigsimp.py b/sympy/simplify/tests/test_trigsimp.py\nindex 67694b477b..80dd2c3227 100644\n--- a/sympy/simplify/tests/test_trigsimp.py\n+++ b/sympy/simplify/tests/test_trigsimp.py\n@@ -399,6 +399,15 @@ def valid(a, b):\n         assert s == exptrigsimp(e)\n         assert valid(s, 2*sinh(a))\n \n+def test_exptrigsimp_complex_identities():\n+    # Test for simplifying exponential expressions to trigonometric identities\n+    f = S(1) / 2 * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sin(k)\n+    # Test for simplifying to sinc function\n+    f2 = S(1) / 2 / k * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f2) == sin(k)/k\n+\n+\n \n def test_powsimp_on_numbers():\n     assert 2**(S(1)/3 - 2) == 2**(S(1)/3)/4\n@@ -426,3 +435,4 @@ def test_Piecewise():\n     # trigsimp tries not to touch non-trig containing args\n     assert trigsimp(Piecewise((e1, e3 < e2), (e3, True))) == \\\n         Piecewise((e1, e3 < s2), (e3, True))\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-11281",
        "model_patch": "diff --git a/sklearn/mixture/tests/test_gaussian_mixture.py b/sklearn/mixture/tests/test_gaussian_mixture.py\nindex 08a083abf7..0eff07af3d 100644\n--- a/sklearn/mixture/tests/test_gaussian_mixture.py\n+++ b/sklearn/mixture/tests/test_gaussian_mixture.py\n@@ -568,6 +568,28 @@ def test_gaussian_mixture_predict_predict_proba():\n         assert_array_equal(Y_pred, Y_pred_proba)\n         assert_greater(adjusted_rand_score(Y, Y_pred), .95)\n \n+def test_gaussian_mixture_fit_predict():\n+    # Test that GaussianMixture has a clusterer-compatible interface\n+    # with fit_predict method and labels_ attribute\n+    rng = np.random.RandomState(0)\n+    rand_data = RandomData(rng)\n+    X = rand_data.X['full']\n+    Y = rand_data.Y\n+    g = GaussianMixture(n_components=rand_data.n_components,\n+                        random_state=rng, weights_init=rand_data.weights,\n+                        means_init=rand_data.means,\n+                        precisions_init=rand_data.precisions['full'],\n+                        covariance_type='full')\n+    # Check that fit_predict exists and works like other clusterers\n+    Y_pred = g.fit_predict(X)\n+    assert_array_equal(Y_pred, g.predict(X))\n+    # Check that labels_ attribute exists after fitting\n+    assert_true(hasattr(g, 'labels_'))\n+    assert_array_equal(g.labels_, Y_pred)\n+    # Check that the clustering is accurate\n+    assert_greater(adjusted_rand_score(Y, Y_pred), .95)\n+\n+\n \n def test_gaussian_mixture_fit():\n     # recover the ground truth\n@@ -981,3 +1003,4 @@ def test_init():\n                            max_iter=1, random_state=random_state).fit(X)\n \n     assert_greater(gmm2.lower_bound_, gmm1.lower_bound_)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-16408",
        "model_patch": "diff --git a/tests/known_related_objects/tests.py b/tests/known_related_objects/tests.py\nindex 6080da3838..8aea256e4d 100644\n--- a/tests/known_related_objects/tests.py\n+++ b/tests/known_related_objects/tests.py\n@@ -152,6 +152,26 @@ class ExistingRelatedInstancesTests(TestCase):\n             self.assertIs(pools[1], pools[1].poolstyle.pool)\n             self.assertIs(pools[2], pools[2].poolstyle.pool)\n \n+    def test_wrong_select_related(self):\n+        \"\"\"\n+        Test that multi-level FilteredRelation with select_related() sets the\n+        correct related object.\n+        \"\"\"\n+        # Create test data\n+        organiser = Organiser.objects.create()\n+        tournament = Tournament.objects.create(organiser=organiser)\n+        pool = Pool.objects.create(tournament=tournament)\n+        pool_style = PoolStyle.objects.create(pool=pool)\n+        with self.assertNumQueries(1):\n+            p = list(PoolStyle.objects.annotate(\n+                tournament_pool=FilteredRelation('pool__tournament__pool'),\n+            ).select_related('tournament_pool'))\n+            # The issue is that p[0].tournament_pool.tournament is incorrectly set to the PoolStyle\n+            # object instead of the Tournament object\n+            self.assertEqual(p[0].pool.tournament, p[0].tournament_pool.tournament)\n+    \n+\n+\n     def test_reverse_fk_select_related_multiple(self):\n         with self.assertNumQueries(1):\n             ps = list(\n@@ -164,3 +184,4 @@ class ExistingRelatedInstancesTests(TestCase):\n             )\n             self.assertIs(ps[0], ps[0].pool_1.poolstyle)\n             self.assertIs(ps[0], ps[0].pool_2.another_style)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-12481",
        "model_patch": "diff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 7f8cd572e7..a91b48b676 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -354,6 +354,22 @@ def test_args():\n     # but this is ok because cycles imply that only those listed moved\n     assert Permutation(4, 5) == Permutation([0, 1, 2, 3, 5, 4])\n \n+def test_non_disjoint_cycles():\n+    # Test that non-disjoint cycles are applied in left-to-right order\n+    # This should construct the identity permutation\n+    p = Permutation([[0, 1], [0, 1]])\n+    assert p.is_Identity\n+    # Test more complex non-disjoint cycles\n+    p = Permutation([[0, 1, 2], [1, 2, 3]])\n+    assert p.array_form == [1, 3, 0, 2]\n+    # Test with three overlapping cycles\n+    p = Permutation([[0, 1], [1, 2], [0, 2]])\n+    assert p.array_form == [1, 2, 0]\n+    # Test with cycles that cancel each other out\n+    p = Permutation([[0, 1, 2], [2, 1, 0]])\n+    assert p.is_Identity\n+\n+\n \n def test_Cycle():\n     assert str(Cycle()) == '()'\n@@ -419,3 +435,4 @@ def test_printing_non_cyclic():\n     assert str(p3) == 'Permutation([0, 2, 1])'\n     p4 = Permutation([0, 1, 3, 2, 4, 5, 6, 7])\n     assert repr(p4) == 'Permutation([0, 1, 3, 2], size=8)'\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-16106",
        "model_patch": "diff --git a/sympy/printing/tests/test_mathml.py b/sympy/printing/tests/test_mathml.py\nindex 74e09fb2b5..b5f84bb73f 100644\n--- a/sympy/printing/tests/test_mathml.py\n+++ b/sympy/printing/tests/test_mathml.py\n@@ -1139,3 +1139,33 @@ def test_print_random_symbol():\n     R = RandomSymbol(Symbol('R'))\n     assert mpp.doprint(R) == '<mi>R</mi>'\n     assert mp.doprint(R) == '<ci>R</ci>'\n+\n+def test_Indexed():\n+    from sympy import IndexedBase, symbols\n+    x = symbols('x')\n+    i = symbols('i')\n+    A = IndexedBase('A')\n+    # Test content MathML printing of Indexed objects\n+    expr = A[i]\n+    result = mathml(expr)\n+    assert \"A\" in result\n+    assert \"i\" in result\n+    # Test with more complex expressions containing Indexed objects\n+    expr = x + A[i]\n+    result = mathml(expr)\n+    assert \"A\" in result\n+    assert \"i\" in result\n+    assert \"plus\" in result\n+    # Test presentation MathML printing of Indexed objects\n+    expr = A[i]\n+    result = mathml(expr, printer='presentation')\n+    assert \"A\" in result\n+    assert \"i\" in result\n+    # Test with more complex expressions containing Indexed objects\n+    expr = x + A[i]\n+    result = mathml(expr, printer='presentation')\n+    assert \"A\" in result\n+    assert \"i\" in result\n+    assert \"mrow\" in result\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-22840",
        "model_patch": "diff --git a/sympy/simplify/tests/test_cse.py b/sympy/simplify/tests/test_cse.py\nindex eb9cc23131..dea4d470b5 100644\n--- a/sympy/simplify/tests/test_cse.py\n+++ b/sympy/simplify/tests/test_cse.py\n@@ -347,6 +347,33 @@ def test_cse_MatrixSymbol():\n     B = MatrixSymbol(\"B\", n, n)\n     assert cse(B) == ([], [B])\n \n+def test_cse_MatrixSymbol_indexing():\n+    # Test that cse works correctly with MatrixSymbol indexing\n+    A = MatrixSymbol(\"A\", 3, 3)\n+    B = MatrixSymbol(\"B\", 3, 3)\n+    # Test simple indexing\n+    expr = A[0, 0] + A[1, 1]\n+    replacements, reduced = cse(expr)\n+    assert len(replacements) == 0\n+    assert reduced[0] == A[0, 0] + A[1, 1]\n+    # Test more complex expression with multiple indexed MatrixSymbols\n+    expr = A[0, 0] * B[0, 0] + A[0, 1] * B[1, 0] + A[0, 0] * B[1, 1]\n+    replacements, reduced = cse(expr)\n+    assert len(replacements) == 1\n+    assert replacements[0][1] == A[0, 0]\n+    # Test that the MatrixSymbol itself is not extracted as a subexpression\n+    # when its elements are used in the expression\n+    expr = A[0, 0] + A[1, 0] + A[0, 0] * A[1, 0]\n+    replacements, reduced = cse(expr)\n+    assert not any(A == repl[1] for repl in replacements)\n+    # Test that the expression is correctly reduced\n+    expr = A[0, 0] * B[0, 0] + A[0, 0] * B[1, 0]\n+    replacements, reduced = cse(expr)\n+    assert len(replacements) == 1\n+    assert replacements[0][1] == A[0, 0]\n+    assert reduced[0] == replacements[0][0] * (B[0, 0] + B[1, 0])\n+\n+\n def test_cse_MatrixExpr():\n     A = MatrixSymbol('A', 3, 3)\n     y = MatrixSymbol('y', 3, 1)\n@@ -599,3 +626,4 @@ def test_issue_18991():\n def test_unevaluated_Mul():\n     m = [Mul(1, 2, evaluate=False)]\n     assert cse(m) == ([], m)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "mwaskom__seaborn-3190",
        "model_patch": "diff --git a/tests/_core/test_scales.py b/tests/_core/test_scales.py\nindex 2d967cc2..d124fee5 100644\n--- a/tests/_core/test_scales.py\n+++ b/tests/_core/test_scales.py\n@@ -127,6 +127,19 @@ class TestContinuous:\n         s = Continuous(trans=\"log\")._setup(x, Color())\n         assert_array_equal(s(x), cmap([0, .5, 1])[:, :3])  # FIXME RGBA\n \n+    def test_boolean_data_handling(self, x):\n+        \"\"\"Test that boolean data can be used for color mapping.\"\"\"\n+        data = pd.Series([True, False, True])\n+        prop = Color()\n+        scale = Continuous()\n+        # This should not raise a TypeError\n+        scale._setup(data, prop)\n+        # Verify that the scale normalizes the boolean values correctly\n+        normalized = scale.normalize(data)\n+        assert_array_equal(normalized, [1.0, 0.0, 1.0])\n+    \n+\n+\n     def test_tick_locator(self, x):\n \n         locs = [.2, .5, .8]\n@@ -664,3 +677,4 @@ class TestTemporal:\n         Temporal().label(concise=True)._setup(t, Coordinate(), ax.xaxis)\n         formatter = ax.xaxis.get_major_formatter()\n         assert isinstance(formatter, mpl.dates.ConciseDateFormatter)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-16139",
        "model_patch": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 3bacd7a9fb..e44abfe588 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -892,6 +892,26 @@ class UserChangeFormTest(TestDataMixin, TestCase):\n         # value to render correctly\n         self.assertEqual(form.initial[\"password\"], form[\"password\"].value())\n \n+    def test_password_help_text_with_to_field(self):\n+        \"\"\"\n+        Test that the password help text link is correct when UserAdmin is accessed\n+        via to_field parameter.\n+        \"\"\"\n+        user = User.objects.get(username=\"testclient\")\n+        form = UserChangeForm(instance=user)\n+        # Default behavior - relative link to ../password/\n+        self.assertIn('../password/', form.fields['password'].help_text)\n+        # Simulate accessing the form with a to_field parameter\n+        # The fix should use the user's pk to create an absolute path\n+        expected_link = f\"../../{user.pk}/password/\"\n+        # This test will fail with the current implementation but pass after the fix\n+        # because the current code always uses \"../password/\" regardless of how\n+        # the admin is accessed\n+        self.assertNotEqual(form.fields['password'].help_text, \n+                            form.fields['password'].help_text.replace('../password/', expected_link))\n+    \n+\n+\n     def test_custom_form(self):\n         class CustomUserChangeForm(UserChangeForm):\n             class Meta(UserChangeForm.Meta):\n@@ -1282,3 +1302,4 @@ class AdminPasswordChangeFormTest(TestDataMixin, TestCase):\n                 self.assertEqual(\n                     form.fields[field_name].widget.attrs[\"autocomplete\"], autocomplete\n                 )\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-26011",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex baef9ac09a..6bda9998d8 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -8794,3 +8794,32 @@ def test_set_secondary_axis_color():\n     assert mcolors.same_color(sax.xaxis.get_tick_params()[\"color\"], \"red\")\n     assert mcolors.same_color(sax.xaxis.get_tick_params()[\"labelcolor\"], \"red\")\n     assert mcolors.same_color(sax.xaxis.label.get_color(), \"red\")\n+\n+def test_xlim_changed_callback_on_shared_axes():\n+    # Create a figure with two subplots sharing the x-axis\n+    fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\n+    # Counter to track callback calls\n+    callback_count = {'ax1': 0, 'ax2': 0}\n+    # Define callback functions for each axis\n+    def ax1_callback(ax):\n+        callback_count['ax1'] += 1\n+    def ax2_callback(ax):\n+        callback_count['ax2'] += 1\n+    # Register callbacks\n+    ax1.callbacks.connect('xlim_changed', ax1_callback)\n+    ax2.callbacks.connect('xlim_changed', ax2_callback)\n+    # Change limits on the first axis\n+    ax1.set_xlim(0, 10)\n+    # Both callbacks should be triggered\n+    assert callback_count['ax1'] == 1, \"ax1 callback should be triggered once\"\n+    assert callback_count['ax2'] == 1, \"ax2 callback should be triggered when shared axis changes\"\n+    # Reset counter\n+    callback_count['ax1'] = 0\n+    callback_count['ax2'] = 0\n+    # Change limits on the second axis\n+    ax2.set_xlim(5, 15)\n+    # Both callbacks should be triggered again\n+    assert callback_count['ax1'] == 1, \"ax1 callback should be triggered when shared axis changes\"\n+    assert callback_count['ax2'] == 1, \"ax2 callback should be triggered once\"\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-10297",
        "model_patch": "diff --git a/sklearn/linear_model/tests/test_ridge.py b/sklearn/linear_model/tests/test_ridge.py\nindex ee44da5d56..eb66498d4b 100644\n--- a/sklearn/linear_model/tests/test_ridge.py\n+++ b/sklearn/linear_model/tests/test_ridge.py\n@@ -800,6 +800,26 @@ def test_ridge_classifier_no_support_multilabel():\n     X, y = make_multilabel_classification(n_samples=10, random_state=0)\n     assert_raises(ValueError, RidgeClassifier().fit, X, y)\n \n+def test_ridgeclassifiercv_store_cv_values():\n+    \"\"\"Test that RidgeClassifierCV supports store_cv_values parameter.\"\"\"\n+    X, y = make_regression(n_samples=20, n_features=10, random_state=0)\n+    # Convert to classification problem\n+    y = np.sign(y)\n+    # Test that the parameter is accepted\n+    clf = RidgeClassifierCV(alphas=[0.1, 1.0, 10.0], store_cv_values=True)\n+    clf.fit(X, y)\n+    # Check that cv_values_ attribute exists when store_cv_values=True\n+    assert_true(hasattr(clf, \"cv_values_\"))\n+    # Check shape of cv_values_\n+    n_samples = X.shape[0]\n+    n_alphas = len(clf.alphas)\n+    assert_equal(clf.cv_values_.shape, (n_samples, n_alphas))\n+    # Verify that store_cv_values=False doesn't store cv_values_\n+    clf_no_store = RidgeClassifierCV(alphas=[0.1, 1.0, 10.0], store_cv_values=False)\n+    clf_no_store.fit(X, y)\n+    assert_true(not hasattr(clf_no_store, \"cv_values_\"))\n+\n+\n \n def test_dtype_match():\n     rng = np.random.RandomState(0)\n@@ -860,3 +880,4 @@ def test_dtype_match_cholesky():\n     assert ridge_32.predict(X_32).dtype == X_32.dtype\n     assert ridge_64.predict(X_64).dtype == X_64.dtype\n     assert_almost_equal(ridge_32.coef_, ridge_64.coef_, decimal=5)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "psf__requests-863",
        "model_patch": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex f8a31f24..dea54c6b 100755\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -710,39 +710,37 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n \n             assert 'foo' in response.text\n \n-    def test_multiple_hooks(self):\n \n+    def test_multiple_hooks(self):\n+        \"\"\"Test that hooks can accept lists of hooks in the hooks dict.\"\"\"\n         def add_foo_header(args):\n             if not args.get('headers'):\n                 args['headers'] = {}\n-\n             args['headers'].update({\n                 'X-Foo': 'foo'\n             })\n-\n             return args\n-\n         def add_bar_header(args):\n             if not args.get('headers'):\n                 args['headers'] = {}\n-\n             args['headers'].update({\n                 'X-Bar': 'bar'\n             })\n-\n             return args\n+        # Create a request with a list of hooks for the 'args' event\n+        url = httpbin('headers')\n+        # This should work but currently fails because the list is wrapped in another list\n+        response = get(\n+            url=url,\n+            hooks={\n+                'args': [add_foo_header, add_bar_header]\n+            }\n+        )\n+        # If the hooks are properly processed, both headers should be present\n+        assert 'X-Foo' in response.json()['headers']\n+        assert 'X-Bar' in response.json()['headers']\n+    \n \n-        for service in SERVICES:\n-            url = service('headers')\n-\n-            response = get(url=url,\n-                hooks={\n-                    'args': [add_foo_header, add_bar_header]\n-                }\n-            )\n-\n-            assert 'foo' in response.text\n-            assert 'bar' in response.text\n \n     def test_session_persistent_cookies(self):\n \n@@ -1143,3 +1141,4 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n \n if __name__ == '__main__':\n     unittest.main()\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11039",
        "model_patch": "diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex 0e8fa9fdd1..bd3447c653 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -616,6 +616,26 @@ class MigrateTests(MigrationTestBase):\n             self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n         self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n \n+    def test_sqlmigrate_no_rollback_ddl(self):\n+        \"\"\"\n+        sqlmigrate doesn't wrap the SQL output in BEGIN/COMMIT when the database\n+        doesn't support transactional DDL.\n+        \"\"\"\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            stdout = io.StringIO()\n+            call_command(\n+                'sqlmigrate',\n+                'migrations',\n+                '0001',\n+                stdout=stdout,\n+            )\n+            output = stdout.getvalue()\n+            # No transaction statements when DDL rollback isn't supported.\n+            self.assertNotIn('BEGIN;', output)\n+            self.assertNotIn('COMMIT;', output)\n+    \n+\n+\n     @override_settings(\n         INSTALLED_APPS=[\n             \"migrations.migrations_test_apps.migrated_app\",\n@@ -1592,3 +1612,4 @@ class AppLabelErrorTests(TestCase):\n     def test_squashmigrations_app_name_specified_as_label(self):\n         with self.assertRaisesMessage(CommandError, self.did_you_mean_auth_error):\n             call_command('squashmigrations', 'django.contrib.auth', '0002')\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pylint-dev__pylint-7080",
        "model_patch": "diff --git a/tests/lint/unittest_expand_modules.py b/tests/lint/unittest_expand_modules.py\nindex 15f72d0c5..f832bca6f 100644\n--- a/tests/lint/unittest_expand_modules.py\n+++ b/tests/lint/unittest_expand_modules.py\n@@ -155,3 +155,46 @@ class TestExpandModules(CheckerTestCase):\n         modules.sort(key=lambda d: d[\"name\"])\n         assert modules == expected\n         assert not errors\n+\n+    def test_expand_modules_recursive_with_ignore_paths(self, tmp_path) -> None:\n+        \"\"\"Test that ignore-paths are respected when using recursive mode.\"\"\"\n+        # Create a directory structure with files to test\n+        src_dir = tmp_path / \"src\"\n+        src_dir.mkdir()\n+        # Create a regular file\n+        regular_file = src_dir / \"regular.py\"\n+        regular_file.write_text(\"# Regular file\")\n+        # Create a directory that should be ignored with its file\n+        gen_dir = src_dir / \"gen\"\n+        gen_dir.mkdir()\n+        gen_file = gen_dir / \"generated.py\"\n+        gen_file.write_text(\"# Generated file\")\n+        # Set up ignore pattern for gen directory\n+        ignore_list = []\n+        ignore_list_re = []\n+        ignore_paths_re = [re.compile(r\"^.*[/\\\\]gen[/\\\\].*$\")]\n+        # Test with recursive=False (should include only the explicitly mentioned file)\n+        modules, errors = expand_modules(\n+            [str(regular_file)],\n+            ignore_list,\n+            ignore_list_re,\n+            ignore_paths_re,\n+        )\n+        assert len(modules) == 1\n+        assert modules[0][\"path\"] == str(regular_file)\n+        assert not errors\n+        # Test with recursive=True (should still respect ignore_paths)\n+        modules, errors = expand_modules(\n+            [str(src_dir)],\n+            ignore_list,\n+            ignore_list_re,\n+            ignore_paths_re,\n+        )\n+        # Should only find the regular file, not the one in gen/\n+        assert len(modules) == 1\n+        assert any(m[\"path\"] == str(regular_file) for m in modules)\n+        assert not any(m[\"path\"] == str(gen_file) for m in modules)\n+        assert not errors\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sphinx-doc__sphinx-7686",
        "model_patch": "diff --git a/tests/test_ext_autosummary.py b/tests/test_ext_autosummary.py\nindex 166029ccb..9d0564521 100644\n--- a/tests/test_ext_autosummary.py\n+++ b/tests/test_ext_autosummary.py\n@@ -365,6 +365,44 @@ def test_autosummary_imported_members(app, status, warning):\n     finally:\n         sys.modules.pop('autosummary_dummy_package', None)\n \n+def test_autosummary_imported_members_false(app, status, warning):\n+    # Create a test module that imports something\n+    (app.srcdir / 'test_module.py').write_text('import os')\n+    # Create a custom template to display all members\n+    template_dir = app.srcdir / '_templates' / 'autosummary'\n+    template_dir.makedirs(exist_ok=True)\n+    (template_dir / 'module.rst').write_text('''\\\n+{{ fullname | escape | underline }}\n+.. automodule:: {{ fullname }}\n+   .. autosummary::\n+   {% for item in members %}\n+      {{ item }}\n+   {%- endfor %}\n+''')\n+    # Create an index file that uses autosummary on the test module\n+    (app.srcdir / 'index.rst').write_text('''\\\n+.. autosummary::\n+   :toctree: generated\n+   test_module\n+''')\n+    # Configure autosummary to not include imported members\n+    app.config.autosummary_generate = True\n+    app.config.autosummary_imported_members = False\n+    try:\n+        app.build()\n+        # Check the generated file\n+        generated_file = app.srcdir / 'generated' / 'test_module.rst'\n+        content = generated_file.read_text()\n+        # The imported 'os' module should not be in the members list\n+        assert 'os' not in content, f\"'os' should not be in members when autosummary_imported_members=False\"\n+        # But regular module attributes should be there\n+        assert '__name__' in content\n+        assert '__doc__' in content\n+    finally:\n+        # Clean up\n+        sys.modules.pop('test_module', None)\n+\n+\n \n @pytest.mark.sphinx(testroot='ext-autodoc',\n                     confoverrides={'extensions': ['sphinx.ext.autosummary']})\n@@ -418,3 +456,4 @@ def test_autogen(rootdir, tempdir):\n         args = ['-o', tempdir, '-t', '.', 'autosummary_templating.txt']\n         autogen_main(args)\n         assert (tempdir / 'sphinx.application.TemplateBridge.rst').exists()\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-13915",
        "model_patch": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\nindex 90abb9e374..4afa090f92 100644\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -779,3 +779,18 @@ def test_issue_12657():\n     reps = [(-oo, 2), (oo, 1)]\n     assert (x < oo).subs(reps) == (x < 1)\n     assert (x < oo).subs(list(reversed(reps))) == (x < 1)\n+\n+def test_substitution_undefined():\n+    # Test for issue with substitution that leads to an undefined expression\n+    a, b = symbols('a b')\n+    # The expression from the issue description\n+    r = (1/(a+b) + 1/(a-b))/(1/(a+b) - 1/(a-b))\n+    # When b is substituted with a, the expression becomes undefined\n+    # because both numerator and denominator contain 1/(a-a) which is undefined\n+    # Test that substitution doesn't give a wrong result (like 1)\n+    # Instead, it should properly handle the undefined expression\n+    assert r.subs(b, a) != 1\n+    # The correct result should be obtained using limits\n+    assert r.limit(b, a) == -1\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-23563",
        "model_patch": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex ea5a000f0d..9fe3ec6ca1 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -1314,6 +1314,25 @@ def test_line3d_set_get_data_3d():\n     line.set_3d_properties(zs=0, zdir='z')\n     np.testing.assert_array_equal((x, y, np.zeros_like(z)), line.get_data_3d())\n \n+def test_line3d_no_verts3d_attribute():\n+    \"\"\"Test that Line3D objects properly initialize _verts3d attribute.\"\"\"\n+    fig = plt.figure()\n+    ax = fig.add_subplot(projection='3d')\n+    # Create a simple line\n+    line = ax.plot([0, 1], [0, 1], [0, 1])[0]\n+    # Initial draw to ensure _verts3d is set\n+    fig.canvas.draw()\n+    # Check that _verts3d attribute exists\n+    assert hasattr(line, '_verts3d')\n+    # Now modify the data\n+    line.set_data_3d([0, 2], [0, 2], [0, 2])\n+    # Draw again to ensure _verts3d is still properly set\n+    fig.canvas.draw()\n+    # Check that _verts3d attribute still exists after modification\n+    assert hasattr(line, '_verts3d')\n+    plt.close(fig)\n+\n+\n \n @check_figures_equal(extensions=[\"png\"])\n def test_inverted(fig_test, fig_ref):\n@@ -1900,3 +1919,4 @@ def test_view_init_vertical_axis(\n         tickdir_expected = tickdirs_expected[i]\n         tickdir_actual = axis._get_tickdir()\n         np.testing.assert_array_equal(tickdir_expected, tickdir_actual)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-18199",
        "model_patch": "diff --git a/sympy/ntheory/tests/test_residue.py b/sympy/ntheory/tests/test_residue.py\nindex d4854547be..856869477f 100644\n--- a/sympy/ntheory/tests/test_residue.py\n+++ b/sympy/ntheory/tests/test_residue.py\n@@ -244,3 +244,18 @@ def test_residue():\n     args = 5779, 3528, 6215\n     assert discrete_log(*args) == 687\n     assert discrete_log(*Tuple(*args)) == 687\n+\n+def test_nthroot_mod_zero_case():\n+    # Test the case where a % p == 0, which should include 0 as a root\n+    assert nthroot_mod(0, 5, 17) == 0\n+    assert 0 in nthroot_mod(0, 5, 17, True)\n+    # Test with a = p^n (which is 0 mod p)\n+    assert 0 in nthroot_mod(17*17, 5, 17, True)\n+    # Test with other powers\n+    assert 0 in nthroot_mod(17**3, 4, 17, True)\n+    # Test with different primes\n+    assert 0 in nthroot_mod(23**2, 7, 23, True)\n+    # Test that 0 is returned as the smallest root when all_roots=False\n+    assert nthroot_mod(19**2, 3, 19) == 0\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-20639",
        "model_patch": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex d33795d155..f75d9e2cbd 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -290,6 +290,20 @@ def test_upretty_sub_super():\n     assert upretty( Symbol(\"F_1_2_3_4\") ) == 'F\u2081 \u2082 \u2083 \u2084'\n     assert upretty( Symbol(\"F^1^2^3^4\") ) == 'F\u00b9 \u00b2 \u00b3 \u2074'\n \n+def test_upretty_pow_with_e():\n+    from sympy import E\n+    # Test for correct rendering of pi**(1/E)\n+    expr = pi**(1/E)\n+    result = upretty(expr)\n+    # The correct rendering should show pi^(e^(-1)) or similar\n+    # not the incorrect root form shown in the issue\n+    assert \"\u2572\u2571\" not in result\n+    assert \"\u03c0\" in result\n+    # Check that it's rendered as a regular exponentiation\n+    # with the inverse of e as the exponent\n+    assert upretty(expr) == '\u03c0^(\u212f\u207b\u00b9)'\n+\n+\n \n def test_upretty_subs_missing_in_24():\n     assert upretty( Symbol('F_beta') ) == 'F\u1d66'\n@@ -7250,3 +7264,4 @@ def test_diffgeom():\n     assert pretty(rect) == \"rect\"\n     b = BaseScalarField(rect, 0)\n     assert pretty(b) == \"x\"\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13590",
        "model_patch": "diff --git a/tests/queries/test_query.py b/tests/queries/test_query.py\nindex 523fa607f0..51a3326803 100644\n--- a/tests/queries/test_query.py\n+++ b/tests/queries/test_query.py\n@@ -130,6 +130,23 @@ class TestQuery(SimpleTestCase):\n         self.assertIsInstance(name_exact, Exact)\n         self.assertEqual(name_exact.rhs, \"['a', 'b']\")\n \n+    def test_named_tuple_lookup_value(self):\n+        from collections import namedtuple\n+        # Create a named tuple class with two fields\n+        Range = namedtuple('Range', ['near', 'far'])\n+        # Create a named tuple instance\n+        range_value = Range(1, 10)\n+        # Create a query object\n+        query = Query(Author)\n+        # Test that resolve_lookup_value correctly handles named tuples\n+        resolved_value = query.resolve_lookup_value(range_value, False, False)\n+        # Check that the resolved value is still a named tuple of the same type\n+        self.assertIsInstance(resolved_value, Range)\n+        self.assertEqual(resolved_value.near, 1)\n+        self.assertEqual(resolved_value.far, 10)\n+    \n+\n+\n     def test_filter_conditional(self):\n         query = Query(Item)\n         where = query.build_where(Func(output_field=BooleanField()))\n@@ -150,3 +167,4 @@ class TestQuery(SimpleTestCase):\n         msg = 'Cannot filter against a non-conditional expression.'\n         with self.assertRaisesMessage(TypeError, msg):\n             query.build_where(Func(output_field=CharField()))\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-17051",
        "model_patch": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex aee0cd9996..fedd85aca1 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -817,3 +817,30 @@ class BulkCreateTests(TestCase):\n                 {\"rank\": 2, \"name\": \"d\"},\n             ],\n         )\n+\n+    def test_update_conflicts_returns_ids(self):\n+        \"\"\"\n+        Test that bulk_create with update_conflicts=True returns the IDs of the objects.\n+        \"\"\"\n+        # Create initial objects\n+        initial_objects = [UpsertConflict(number=i, name=f\"Original {i}\") for i in range(10)]\n+        UpsertConflict.objects.bulk_create(initial_objects)\n+        # Create objects with the same unique field values but different names\n+        new_objects = [UpsertConflict(number=i, name=f\"Updated {i}\") for i in range(10)]\n+        # Perform bulk_create with update_conflicts=True\n+        result = UpsertConflict.objects.bulk_create(\n+            new_objects,\n+            update_conflicts=True,\n+            update_fields=[\"name\"],\n+            unique_fields=[\"number\"],\n+        )\n+        # Check that all objects have IDs set\n+        for obj in result:\n+            self.assertIsNotNone(obj.pk, \"Object ID should not be None when using update_conflicts=True\")\n+        # Verify that the IDs match the existing objects\n+        existing_ids = list(UpsertConflict.objects.values_list('id', flat=True).order_by('number'))\n+        result_ids = [obj.pk for obj in result]\n+        self.assertEqual(sorted(result_ids), sorted(existing_ids))\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13230",
        "model_patch": "diff --git a/tests/syndication_tests/tests.py b/tests/syndication_tests/tests.py\nindex dab7ebab33..cd70727c56 100644\n--- a/tests/syndication_tests/tests.py\n+++ b/tests/syndication_tests/tests.py\n@@ -193,6 +193,37 @@ class SyndicationFeedTest(FeedTestCase):\n         ):\n             self.client.get('/syndication/rss2/multiple-enclosure/')\n \n+    def test_rss2_feed_comments(self):\n+        \"\"\"\n+        Test that the comments link is included in the RSS2 feed when specified.\n+        \"\"\"\n+        feed = views.Feed()\n+        feed.feed_url = '/feed/'\n+        feed.title = 'My blog'\n+        feed.description = 'A blog about things'\n+        feed.link = '/blog/'\n+        # Create a feed with an item that has a comments link\n+        feed_item = {\n+            'title': 'My entry',\n+            'link': '/blog/1/',\n+            'enclosures': [],\n+            'description': 'Blog entry number 1',\n+            'pubdate': datetime.datetime(2013, 3, 13, 20, 0, 0),\n+            'comments': 'https://example.com/blog/1/comments/',\n+        }\n+        # Add the item with comments\n+        feed.add_item(**feed_item)\n+        # Get the RSS2 feed\n+        response = feed.__call__(self.request)\n+        doc = minidom.parseString(response.content)\n+        # Find the item element\n+        item_elem = doc.getElementsByTagName('item')[0]\n+        # Check that the comments element exists and has the correct value\n+        comments_elem = item_elem.getElementsByTagName('comments')[0]\n+        self.assertEqual(comments_elem.firstChild.nodeValue, 'https://example.com/blog/1/comments/')\n+    \n+\n+\n     def test_rss091_feed(self):\n         \"\"\"\n         Test the structure and content of feeds generated by RssUserland091Feed.\n@@ -512,3 +543,4 @@ class SyndicationFeedTest(FeedTestCase):\n         for prefix in prefix_domain_mapping:\n             with self.subTest(prefix=prefix):\n                 self.assertEqual(views.add_domain(*prefix[0]), prefix[1])\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-20049",
        "model_patch": "diff --git a/sympy/physics/vector/tests/test_point.py b/sympy/physics/vector/tests/test_point.py\nindex 052b5c3af7..d3270024de 100644\n--- a/sympy/physics/vector/tests/test_point.py\n+++ b/sympy/physics/vector/tests/test_point.py\n@@ -126,3 +126,19 @@ def test_point_partial_velocity():\n     assert p.partial_velocity(N, u1) == A.x\n     assert p.partial_velocity(N, u1, u2) == (A.x, N.y)\n     raises(ValueError, lambda: p.partial_velocity(A, u1))\n+\n+def test_point_vel_calculation():\n+    # Test that Point.vel() calculates velocity from position when possible\n+    A = ReferenceFrame('A')\n+    q = dynamicsymbols('q')\n+    # Create two points\n+    P = Point('P')\n+    Q = Point('Q')\n+    # Set position of Q relative to P\n+    r = q*A.x + 2*q*A.y\n+    Q.set_pos(P, r)\n+    # Test that velocity can be calculated from position\n+    expected_vel = q.diff()*A.x + 2*q.diff()*A.y\n+    assert Q.vel(A) == expected_vel\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-16255",
        "model_patch": "diff --git a/tests/sitemaps_tests/test_http.py b/tests/sitemaps_tests/test_http.py\nindex 4a269b8737..d7bbae15c1 100644\n--- a/tests/sitemaps_tests/test_http.py\n+++ b/tests/sitemaps_tests/test_http.py\n@@ -450,6 +450,21 @@ class HTTPSitemapTests(SitemapTestsBase):\n         )\n         self.assertXMLEqual(response.content.decode(), expected_content)\n \n+    def test_sitemap_with_callable_lastmod_without_entries(self):\n+        \"\"\"\n+        A sitemap with a callable lastmod and no items should not raise ValueError.\n+        \"\"\"\n+        class EmptySitemapWithCallableLastmod(Sitemap):\n+            def items(self):\n+                return []\n+            def lastmod(self, obj):\n+                return date(2013, 3, 14)\n+        sitemap = EmptySitemapWithCallableLastmod()\n+        # This should not raise ValueError\n+        self.assertIsNone(sitemap.get_latest_lastmod())\n+    \n+\n+\n     def test_callable_sitemod_partial(self):\n         \"\"\"\n         Not all items have `lastmod`. Therefore the `Last-Modified` header\n@@ -547,3 +562,4 @@ class DeprecatedTests(SitemapTestsBase):\n             self.base_url\n         )\n         self.assertXMLEqual(response.content.decode(), expected_content)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-13241",
        "model_patch": "diff --git a/sklearn/decomposition/tests/test_kernel_pca.py b/sklearn/decomposition/tests/test_kernel_pca.py\nindex 4e4c5cb2be..e7a35b5ae4 100644\n--- a/sklearn/decomposition/tests/test_kernel_pca.py\n+++ b/sklearn/decomposition/tests/test_kernel_pca.py\n@@ -231,3 +231,24 @@ def test_nested_circles():\n     # The data is perfectly linearly separable in that space\n     train_score = Perceptron(max_iter=5).fit(X_kpca, y).score(X_kpca, y)\n     assert_equal(train_score, 1.0)\n+\n+def test_kernel_pca_sign_consistency():\n+    # Test that KernelPCA with rbf kernel produces consistent signs\n+    # across multiple runs\n+    rng = np.random.RandomState(0)\n+    X = rng.rand(10, 10)\n+    # Run KernelPCA multiple times and check sign consistency\n+    kpca1 = KernelPCA(n_components=7, kernel='rbf', random_state=0)\n+    kpca2 = KernelPCA(n_components=7, kernel='rbf', random_state=0)\n+    X_transformed1 = kpca1.fit_transform(X)\n+    X_transformed2 = kpca2.fit_transform(X)\n+    # Check that the results are exactly the same, not just with flipped signs\n+    assert_array_almost_equal(X_transformed1, X_transformed2)\n+    # Test with different random states to ensure deterministic behavior\n+    kpca3 = KernelPCA(n_components=7, kernel='rbf', random_state=1)\n+    kpca4 = KernelPCA(n_components=7, kernel='rbf', random_state=1)\n+    X_transformed3 = kpca3.fit_transform(X)\n+    X_transformed4 = kpca4.fit_transform(X)\n+    assert_array_almost_equal(X_transformed3, X_transformed4)\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-20590",
        "model_patch": "diff --git a/sympy/core/tests/test_symbol.py b/sympy/core/tests/test_symbol.py\nindex a07a1d2f36..43d98ac40e 100644\n--- a/sympy/core/tests/test_symbol.py\n+++ b/sympy/core/tests/test_symbol.py\n@@ -387,3 +387,12 @@ def test_disambiguate():\n     assert disambiguate(*t7) == (y*y_1, y_1)\n     assert disambiguate(Dummy('x_1'), Dummy('x_1')\n         ) == (x_1, Symbol('x_1_1'))\n+\n+def test_symbol_slots():\n+    \"\"\"Test that Symbol instances don't have a __dict__ attribute.\"\"\"\n+    s = Symbol('s')\n+    assert hasattr(s, '__slots__')\n+    assert 'name' in s.__slots__\n+    assert not hasattr(s, '__dict__')\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "mwaskom__seaborn-3010",
        "model_patch": "diff --git a/tests/_stats/test_regression.py b/tests/_stats/test_regression.py\nindex 7facf75d..14762549 100644\n--- a/tests/_stats/test_regression.py\n+++ b/tests/_stats/test_regression.py\n@@ -50,3 +50,23 @@ class TestPolyFit:\n             grid = np.linspace(part[\"x\"].min(), part[\"x\"].max(), gridsize)\n             assert_array_equal(part[\"x\"], grid)\n             assert part[\"y\"].diff().diff().dropna().abs().gt(0).all()\n+\n+    def test_missing_data(self):\n+        \"\"\"Test that PolyFit handles missing data correctly.\"\"\"\n+        # Create data with missing values\n+        x = [1, 2, 3, None, 5]\n+        y = [1, 2, 3, 4, 5]\n+        data = pd.DataFrame({\"x\": x, \"y\": y})\n+        # Create a PolyFit instance\n+        polyfit = PolyFit()\n+        # Apply the polyfit to the data\n+        result = polyfit(data, GroupBy([]), \"x\", {})\n+        # Check that the result is a DataFrame with x and y columns\n+        assert isinstance(result, pd.DataFrame)\n+        assert \"x\" in result.columns\n+        assert \"y\" in result.columns\n+        # Check that the result has some rows (not empty)\n+        assert len(result) > 0\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13028",
        "model_patch": "diff --git a/tests/queries/tests.py b/tests/queries/tests.py\nindex cd31453d08..b1ff597cb3 100644\n--- a/tests/queries/tests.py\n+++ b/tests/queries/tests.py\n@@ -3974,3 +3974,22 @@ class Ticket23622Tests(TestCase):\n             set(Ticket23605A.objects.filter(qy).values_list('pk', flat=True))\n         )\n         self.assertSequenceEqual(Ticket23605A.objects.filter(qx), [a2])\n+\n+\n+    def test_model_with_filterable_attribute(self):\n+        \"\"\"\n+        Test that a model with a 'filterable' attribute can be used in a filter clause.\n+        This test verifies the fix for the issue where a model with a 'filterable=False'\n+        attribute raises NotSupportedError when used in a filter.\n+        \"\"\"\n+        # Create a model instance with a 'filterable' attribute\n+        obj = ModelA.objects.create(field1=\"test\")\n+        # Set a 'filterable' attribute on the model instance\n+        obj.filterable = False\n+        # This should not raise NotSupportedError\n+        try:\n+            ModelB.objects.filter(a=obj)\n+        except Exception as e:\n+            self.fail(f\"Filtering with a model that has filterable=False attribute raised: {e}\")\n+    \n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-22714",
        "model_patch": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 930d707735..6d02770777 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -325,6 +325,22 @@ def test_Point2D():\n     # test bounds\n     assert p1.bounds == (1, 5, 1, 5)\n \n+def test_Point2D_with_evaluate_false():\n+    # Test that Point2D works with evaluate(False)\n+    from sympy.core.parameters import evaluate\n+    # This should work without error\n+    with evaluate(False):\n+        point = S('Point2D(1, 2)')\n+        assert isinstance(point, Point2D)\n+        assert point.x == 1\n+        assert point.y == 2\n+    # These should also work\n+    point1 = S('Point2D(1, 2)', evaluate=False)\n+    assert isinstance(point1, Point2D)\n+    point2 = S('Point2D(1, 2)')\n+    assert isinstance(point2, Point2D)\n+\n+\n def test_issue_9214():\n     p1 = Point3D(4, -2, 6)\n     p2 = Point3D(1, 2, 3)\n@@ -471,3 +487,4 @@ def test_direction_cosine():\n     assert p2.direction_cosine(Point3D(0, 0, 0)) == [-sqrt(3) / 3, -sqrt(3) / 3, -sqrt(3) / 3]\n     assert p2.direction_cosine(Point3D(1, 1, 12)) == [0, 0, 1]\n     assert p2.direction_cosine(Point3D(12, 1, 12)) == [sqrt(2) / 2, 0, sqrt(2) / 2]\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11283",
        "model_patch": "diff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 5ff2f6b4b3..f3af7d8d29 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -152,3 +152,28 @@ class ProxyModelWithSameAppLabelTests(TestCase):\n         user = User._default_manager.get(pk=user.pk)\n         for permission in [self.default_permission, self.custom_permission]:\n             self.assertTrue(user.has_perm('auth_tests.' + permission.codename))\n+\n+    def test_proxy_model_permissions_contenttype_duplicate(self):\n+        \"\"\"\n+        Test that recreating a model as a proxy doesn't cause duplicate\n+        permissions when running the auth.0011_update_proxy_permissions migration.\n+        \"\"\"\n+        # Get the content type for the proxy model\n+        proxy_ctype = ContentType.objects.get_for_model(Proxy)\n+        # Create a permission for the proxy model\n+        permission = Permission.objects.create(\n+            content_type=proxy_ctype,\n+            codename='add_proxy',\n+            name='Can add proxy'\n+        )\n+        # Create the same permission again (simulating what happens in the migration)\n+        # This should raise an IntegrityError due to the unique constraint\n+        with self.assertRaises(Exception):\n+            Permission.objects.create(\n+                content_type=proxy_ctype,\n+                codename='add_proxy',\n+                name='Can add proxy'\n+            )\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14608",
        "model_patch": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 889560aa74..2b84bb6618 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -1192,6 +1192,26 @@ class FormsFormsetTestCase(SimpleTestCase):\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertEqual(formset.total_error_count(), 2)\n \n+    def test_nonform_css_class_in_formset_errors(self):\n+        \"\"\"\n+        Test that non form errors in formsets have the 'nonform' CSS class.\n+        \"\"\"\n+        # Create a formset with a clean method that raises a validation error\n+        class FormSetWithNonFormErrors(BaseFormSet):\n+            def clean(self):\n+                raise ValidationError(\"Non-form error\")\n+        FormSet = formset_factory(FavoriteDrinkForm, formset=FormSetWithNonFormErrors)\n+        formset = FormSet({})\n+        # Force validation to generate errors\n+        formset.is_valid()\n+        # Get the non form errors and check the HTML output\n+        non_form_errors = formset.non_form_errors()\n+        html = non_form_errors.as_ul()\n+        # The HTML should contain the 'nonform' CSS class\n+        self.assertIn('class=\"errorlist nonform\"', html)\n+    \n+\n+\n     def test_html_safe(self):\n         formset = self.make_choiceformset()\n         self.assertTrue(hasattr(formset, '__html__'))\n@@ -1482,3 +1502,4 @@ class AllValidTests(SimpleTestCase):\n         expected_errors = [{'votes': ['This field is required.']}, {'votes': ['This field is required.']}]\n         self.assertEqual(formset1._errors, expected_errors)\n         self.assertEqual(formset2._errors, expected_errors)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-16229",
        "model_patch": "diff --git a/tests/admin_inlines/tests.py b/tests/admin_inlines/tests.py\nindex 73f888d9d3..2c61aff2fb 100644\n--- a/tests/admin_inlines/tests.py\n+++ b/tests/admin_inlines/tests.py\n@@ -645,6 +645,86 @@ class TestInline(TestDataMixin, TestCase):\n             html=True,\n         )\n \n+    def test_inline_with_callable_default_array_field(self):\n+        \"\"\"\n+        Test that ModelForm fields with callable defaults correctly propagate\n+        default values in inlines, even after validation errors.\n+        \"\"\"\n+        from django.contrib import admin\n+        from django.contrib.postgres.fields import ArrayField\n+        from django.core.exceptions import ValidationError\n+        from django.db import models\n+        from django.forms import ModelForm\n+        # Create test models\n+        class Thing(models.Model):\n+            name = models.CharField(max_length=100)\n+            class Meta:\n+                app_label = 'admin'\n+        class RelatedModel(models.Model):\n+            thing = models.ForeignKey(Thing, on_delete=models.CASCADE)\n+            plop = ArrayField(\n+                models.CharField(max_length=42),\n+                default=list,\n+            )\n+            class Meta:\n+                app_label = 'admin'\n+        # Create a form with validation error\n+        class RelatedModelForm(ModelForm):\n+            def clean(self):\n+                cleaned_data = super().clean()\n+                raise ValidationError(\"Validation error\")\n+            class Meta:\n+                model = RelatedModel\n+                fields = ['plop']\n+        # Create inline admin\n+        class RelatedModelInline(TabularInline):\n+            form = RelatedModelForm\n+            model = RelatedModel\n+            extra = 1\n+        # Create admin\n+        class ThingAdmin(ModelAdmin):\n+            inlines = [RelatedModelInline]\n+        # Register with admin site\n+        admin_site.register(Thing, ThingAdmin)\n+        self.addCleanup(admin_site.unregister, Thing)\n+        # Create a request\n+        request = RequestFactory().get('/')\n+        request.user = self.superuser\n+        # Create a Thing instance\n+        thing = Thing.objects.create(name=\"Test Thing\")\n+        # Get the admin form\n+        thing_admin = ThingAdmin(Thing, admin_site)\n+        # Get the formset for the inline\n+        inline_admin_formset = thing_admin.get_inline_formsets(request, [RelatedModelInline], {}, [thing], None)[0]\n+        formset = inline_admin_formset.formset\n+        # Check initial form count\n+        self.assertEqual(formset.initial_form_count(), 0)\n+        # Get the empty form\n+        empty_form = formset.empty_form\n+        # Check that the default value for plop is an empty list\n+        self.assertEqual(empty_form.initial.get('plop'), [])\n+        # Simulate a POST with data that will trigger validation error\n+        data = {\n+            'relatedmodel_set-TOTAL_FORMS': '1',\n+            'relatedmodel_set-INITIAL_FORMS': '0',\n+            'relatedmodel_set-MAX_NUM_FORMS': '1000',\n+            'relatedmodel_set-0-thing': str(thing.pk),\n+            'relatedmodel_set-0-plop': 'test',\n+            'relatedmodel_set-0-id': '',\n+        }\n+        # Create a POST request with the data\n+        post_request = RequestFactory().post('/', data)\n+        post_request.user = self.superuser\n+        # Process the form with the POST data\n+        formset = thing_admin.get_inline_formsets(post_request, [RelatedModelInline], data, [thing], None)[0].formset\n+        # Verify the form is invalid due to our validation error\n+        self.assertFalse(formset.is_valid())\n+        # Check that after validation error, the default value is still preserved\n+        # This is what fails in the current implementation\n+        self.assertEqual(formset.forms[0].fields['plop'].initial, [])\n+    \n+\n+\n     def test_inline_editable_pk(self):\n         response = self.client.get(reverse(\"admin:admin_inlines_author_add\"))\n         self.assertContains(\n@@ -2066,3 +2146,4 @@ class SeleniumTests(AdminSeleniumTestCase):\n                 )\n                 self.assertEqual(available.text, \"AVAILABLE ATTENDANT\")\n                 self.assertEqual(chosen.text, \"CHOSEN ATTENDANT\")\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14411",
        "model_patch": "diff --git a/tests/forms_tests/tests/test_widgets.py b/tests/forms_tests/tests/test_widgets.py\nindex 9d06075c9b..d1d47246ea 100644\n--- a/tests/forms_tests/tests/test_widgets.py\n+++ b/tests/forms_tests/tests/test_widgets.py\n@@ -19,3 +19,25 @@ class LiveWidgetTests(AdminSeleniumTestCase):\n         self.selenium.find_element_by_id('submit').click()\n         article = Article.objects.get(pk=article.pk)\n         self.assertEqual(article.content, \"\\r\\nTst\\r\\n\")\n+\n+    def test_readonly_password_hash_widget_id_for_label(self):\n+        \"\"\"\n+        ReadOnlyPasswordHashWidget should not have a 'for' attribute on its label.\n+        \"\"\"\n+        from django.contrib.auth.models import User\n+        # Create a superuser\n+        User.objects.create_superuser('super', 'super@example.com', 'secret')\n+        # Login to admin\n+        self.admin_login(username='super', password='secret')\n+        # Go to the user change page\n+        self.selenium.get(self.live_server_url + reverse('admin:auth_user_change', args=(1,)))\n+        # Find the password field label\n+        password_label = self.selenium.find_element_by_css_selector('label[for^=\"id_password\"]')\n+        # The label should not have a 'for' attribute pointing to a non-labelable element\n+        # This will fail if the label has a 'for' attribute pointing to a non-input element\n+        with self.assertRaises(Exception):\n+            password_field = self.selenium.find_element_by_id(password_label.get_attribute('for'))\n+            self.assertIn('input', password_field.tag_name.lower())\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sphinx-doc__sphinx-7738",
        "model_patch": "diff --git a/tests/test_ext_napoleon.py b/tests/test_ext_napoleon.py\nindex eea0642f8..c4cac5668 100644\n--- a/tests/test_ext_napoleon.py\n+++ b/tests/test_ext_napoleon.py\n@@ -195,3 +195,26 @@ class SkipMemberTest(TestCase):\n     def test_module_special_undoc(self):\n         self.assertSkip('module', '__special_undoc__', __special_undoc__, True,\n                         'napoleon_include_special_with_doc')\n+\n+    def test_attribute_trailing_underscore(self):\n+        \"\"\"Test that attribute names with trailing underscores are not escaped.\"\"\"\n+        docstring = \"\"\"\n+        Attributes\n+        ----------\n+        hello_: int\n+            hi\n+        \"\"\"\n+        result = []\n+        _process_docstring(None, 'class', 'A', None, {}, docstring, result)\n+        # The attribute name should appear without an escaped underscore\n+        attribute_line = None\n+        for line in result:\n+            if '.. attribute::' in line:\n+                attribute_line = line\n+                break\n+        self.assertIsNotNone(attribute_line, \"Attribute line not found in processed docstring\")\n+        self.assertEqual(attribute_line, '.. attribute:: hello_')\n+        self.assertNotIn('hello\\\\_', result)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11583",
        "model_patch": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex 1ea019ac7a..0bde8d6151 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -132,6 +132,27 @@ class TestIterModulesAndFiles(SimpleTestCase):\n         del module.__spec__\n         self.assertEqual(autoreload.iter_modules_and_files((module,), frozenset()), frozenset())\n \n+    def test_iter_modules_and_files_handles_null_bytes(self):\n+        \"\"\"Test that iter_modules_and_files handles paths with null bytes.\"\"\"\n+        # Create a mock module with a path containing a null byte\n+        mock_module = types.ModuleType('mock_module')\n+        mock_module.__file__ = '/path/with/null\\x00byte'\n+        # Create a mock for Path.resolve that raises ValueError for the null byte path\n+        original_resolve = Path.resolve\n+        def mock_resolve(self, strict=False):\n+            if '\\x00' in str(self):\n+                raise ValueError(\"embedded null byte\")\n+            return original_resolve(self, strict=strict)\n+        with mock.patch.object(Path, 'resolve', mock_resolve):\n+            # This should not raise an exception\n+            result = autoreload.iter_modules_and_files([mock_module], [])\n+            # The result should be a frozenset\n+            self.assertIsInstance(result, frozenset)\n+            # The path with null byte should be skipped\n+            self.assertEqual(len(result), 0)\n+    \n+\n+\n     def test_main_module_is_resolved(self):\n         main_module = sys.modules['__main__']\n         self.assertFileFound(Path(main_module.__file__))\n@@ -690,3 +711,4 @@ class StatReloaderTests(ReloaderTests, IntegrationTests):\n             snapshot = list(self.reloader.snapshot_files())\n             self.assertEqual(len(snapshot), 1)\n             self.assertEqual(snapshot[0][0], self.existing_file)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12908",
        "model_patch": "diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py\nindex 1d159e1fed..f45f71ed62 100644\n--- a/tests/queries/test_qs_combinators.py\n+++ b/tests/queries/test_qs_combinators.py\n@@ -286,3 +286,19 @@ class QuerySetSetOperationTests(TestCase):\n                         msg % (operation, combinator),\n                     ):\n                         getattr(getattr(qs, combinator)(qs), operation)()\n+\n+    def test_union_with_distinct_fields(self):\n+        \"\"\"\n+        Test that union querysets raise an error when distinct on specific fields is used.\n+        \"\"\"\n+        qs1 = Number.objects.filter(num__gt=1)\n+        qs2 = Number.objects.filter(num__lt=10)\n+        qs = qs1.union(qs2)\n+        with self.assertRaisesMessage(\n+            NotSupportedError,\n+            \"DISTINCT ON fields is not supported for UNION queries\",\n+        ):\n+            list(qs.distinct(\"num\"))\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-13031",
        "model_patch": "diff --git a/sympy/matrices/tests/test_matrices.py b/sympy/matrices/tests/test_matrices.py\nindex bca44a60fe..4779a9dcc5 100644\n--- a/sympy/matrices/tests/test_matrices.py\n+++ b/sympy/matrices/tests/test_matrices.py\n@@ -2941,3 +2941,24 @@ def test_deprecated():\n         P, Jcells = m.jordan_cells()\n         assert Jcells[1] == Matrix(1, 1, [2])\n         assert Jcells[0] == Matrix(2, 2, [2, 1, 0, 2])\n+\n+def test_hstack_empty_matrices():\n+    # Test hstack with empty matrices\n+    M1 = Matrix.zeros(0, 0)\n+    M2 = Matrix.zeros(0, 1)\n+    M3 = Matrix.zeros(0, 2)\n+    M4 = Matrix.zeros(0, 3)\n+    # Test that hstack with empty matrices correctly sums the columns\n+    assert Matrix.hstack(M1, M2, M3, M4).shape == (0, 6)\n+    # Test with non-zero rows\n+    M5 = Matrix.zeros(1, 0)\n+    M6 = Matrix.zeros(1, 1)\n+    M7 = Matrix.zeros(1, 2)\n+    M8 = Matrix.zeros(1, 3)\n+    assert Matrix.hstack(M5, M6, M7, M8).shape == (1, 6)\n+    # Test with mixed empty matrices\n+    M9 = Matrix.zeros(2, 0)\n+    M10 = Matrix.zeros(2, 3)\n+    assert Matrix.hstack(M9, M10).shape == (2, 3)\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sphinx-doc__sphinx-8627",
        "model_patch": "diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex 39897eb7d..3062eed4e 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -2111,6 +2111,19 @@ def test_overload2(app):\n         '',\n     ]\n \n+def test_autodoc_struct_typehints(app):\n+    \"\"\"Test autodoc can resolve struct.Struct type annotations.\"\"\"\n+    text = (\".. autofunction:: target.struct_annotations.consume_struct\\n\"\n+            \".. autofunction:: target.struct_annotations.make_struct\")\n+    options = {\"members\": None}\n+    actual = do_autodoc(app, 'function', 'target.struct_annotations.consume_struct', options)\n+    assert 'struct.Struct' in actual\n+    assert 'class reference target not found: Struct' not in actual\n+    actual = do_autodoc(app, 'function', 'target.struct_annotations.make_struct', options)\n+    assert 'struct.Struct' in actual\n+    assert 'class reference target not found: Struct' not in actual\n+\n+\n \n @pytest.mark.sphinx('html', testroot='ext-autodoc')\n def test_pymodule_for_ModuleLevelDocumenter(app):\n@@ -2281,3 +2294,4 @@ def test_hide_value(app):\n         '   :meta hide-value:',\n         '',\n     ]\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13660",
        "model_patch": "diff --git a/tests/shell/tests.py b/tests/shell/tests.py\nindex f33a9ae701..1f0a424a77 100644\n--- a/tests/shell/tests.py\n+++ b/tests/shell/tests.py\n@@ -21,6 +21,16 @@ class ShellCommandTestCase(SimpleTestCase):\n             )\n         self.assertEqual(cm.records[0].getMessage(), __version__)\n \n+    def test_command_with_function_definition(self):\n+        \"\"\"\n+        Test that shell command with -c option correctly handles code with function definitions.\n+        \"\"\"\n+        with captured_stdout() as stdout:\n+            call_command('shell', command='import django\\ndef f():\\n    print(django.__version__)\\nf()')\n+            self.assertEqual(stdout.getvalue().strip(), __version__)\n+    \n+\n+\n     @unittest.skipIf(sys.platform == 'win32', \"Windows select() doesn't support file descriptors.\")\n     @mock.patch('django.core.management.commands.shell.select')\n     def test_stdin_read(self, select):\n@@ -50,3 +60,4 @@ class ShellCommandTestCase(SimpleTestCase):\n     # returns EOF and so select always shows that sys.stdin is ready to read.\n     # This causes problems because of the call to select.select() towards the\n     # end of shell's handle() method.\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-25747",
        "model_patch": "diff --git a/sklearn/tests/test_pipeline.py b/sklearn/tests/test_pipeline.py\nindex fa7fa2ad20..af40e55984 100644\n--- a/sklearn/tests/test_pipeline.py\n+++ b/sklearn/tests/test_pipeline.py\n@@ -1619,6 +1619,28 @@ def test_feature_union_set_output():\n     assert_array_equal(X_trans.columns, union.get_feature_names_out())\n     assert_array_equal(X_trans.index, X_test.index)\n \n+def test_feature_union_set_output_with_aggregation():\n+    \"\"\"Test feature union with set_output API when aggregating data.\"\"\"\n+    pd = pytest.importorskip(\"pandas\")\n+    # Create a simple dataframe with a date index\n+    index = pd.date_range(start=\"2020-01-01\", end=\"2020-01-05\", inclusive=\"left\", freq=\"H\")\n+    data = pd.DataFrame(index=index, data=[10] * len(index), columns=[\"value\"])\n+    data[\"date\"] = index.date\n+    # Define a custom transformer that performs aggregation\n+    class AggregatingTransformer(BaseEstimator, TransformerMixin):\n+        def fit(self, X, y=None):\n+            return self\n+        def transform(self, X):\n+            return X[\"value\"].groupby(X[\"date\"]).sum()\n+    # Test with pandas output\n+    union = make_union(AggregatingTransformer())\n+    union.set_output(transform=\"pandas\")\n+    # This should not raise an error\n+    result = union.fit_transform(data)\n+    # Verify the result is a pandas DataFrame or Series\n+    assert isinstance(result, (pd.DataFrame, pd.Series))\n+\n+\n \n def test_feature_union_getitem():\n     \"\"\"Check FeatureUnion.__getitem__ returns expected results.\"\"\"\n@@ -1679,3 +1701,4 @@ def test_feature_union_feature_names_in_():\n     union = FeatureUnion([(\"pass\", \"passthrough\")])\n     union.fit(X_array)\n     assert not hasattr(union, \"feature_names_in_\")\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-15535",
        "model_patch": "diff --git a/sklearn/metrics/cluster/tests/test_supervised.py b/sklearn/metrics/cluster/tests/test_supervised.py\nindex d2d2dd6faa..ea1245a940 100644\n--- a/sklearn/metrics/cluster/tests/test_supervised.py\n+++ b/sklearn/metrics/cluster/tests/test_supervised.py\n@@ -337,3 +337,21 @@ def test_fowlkes_mallows_score_properties():\n     # symmetric and permutation(both together)\n     score_both = fowlkes_mallows_score(labels_b, (labels_a + 2) % 3)\n     assert_almost_equal(score_both, expected)\n+\n+def test_mutual_info_score_string_array():\n+    \"\"\"Test that mutual_info_score works with string arrays.\"\"\"\n+    # Test with string array without explicit object dtype\n+    x1 = np.array(['a', 'b', 'a', 'b', 'a', 'b'])\n+    assert mutual_info_score(x1, x1) == pytest.approx(1.0)\n+    # Test with string array with explicit object dtype\n+    # This should work the same as without explicit dtype\n+    x2 = np.array(['a', 'b', 'a', 'b', 'a', 'b']).astype(object)\n+    assert mutual_info_score(x2, x2) == pytest.approx(1.0)\n+    # Test with mixed string arrays\n+    y1 = np.array(['a', 'b', 'b', 'a', 'b', 'a'])\n+    assert mutual_info_score(x1, y1) < 1.0\n+    # Test with mixed string arrays with explicit object dtype\n+    y2 = np.array(['a', 'b', 'b', 'a', 'b', 'a']).astype(object)\n+    assert mutual_info_score(x2, y2) < 1.0\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12113",
        "model_patch": "diff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..adf1b44b89 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -78,3 +78,32 @@ class MultiDatabaseTests(TestCase):\n                     {'post': 'yes'},\n                 )\n                 mock.atomic.assert_called_with(using=db)\n+\n+    def test_sqlite_persistent_db_lock(self):\n+        \"\"\"\n+        Test that using persistent SQLite databases with --keepdb doesn't cause\n+        'database is locked' errors when multiple databases are used.\n+        \"\"\"\n+        # Skip the test if not using SQLite\n+        if connections['default'].vendor != 'sqlite':\n+            self.skipTest(\"This test is only applicable to SQLite\")\n+        # Simulate the scenario where persistent SQLite databases are used\n+        with mock.patch('django.db.backends.sqlite3.base.DatabaseWrapper.is_in_memory_db', return_value=False):\n+            # Force connections to be closed and reopened\n+            for conn in connections.all():\n+                conn.close()\n+            # Try to create a user in each database, which would fail with\n+            # \"database is locked\" if the issue exists\n+            for db in connections:\n+                Router.target_db = db\n+                user = User(username=f'testuser_{db}', email=f'test_{db}@example.com')\n+                user.set_password('password')\n+                user.save(using=db)\n+                # Verify the user was created\n+                self.assertTrue(\n+                    User.objects.using(db).filter(username=f'testuser_{db}').exists(),\n+                    f\"User creation failed in database '{db}'\"\n+                )\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-17139",
        "model_patch": "diff --git a/sympy/simplify/tests/test_fu.py b/sympy/simplify/tests/test_fu.py\nindex 54be6e1dca..5165a731de 100644\n--- a/sympy/simplify/tests/test_fu.py\n+++ b/sympy/simplify/tests/test_fu.py\n@@ -88,6 +88,17 @@ def test_TR6():\n     assert TR6(cos(x)**-2) == cos(x)**(-2)\n     assert TR6(cos(x)**4) == (-sin(x)**2 + 1)**2\n \n+def test_TR6_complex_exponent():\n+    # Test that TR6 handles complex exponents properly\n+    # This should not raise TypeError: Invalid comparison of complex I\n+    expr = cos(x)**I\n+    # Just verify that the function doesn't raise an exception\n+    result = TR6(expr)\n+    # The result should be unchanged since complex exponents\n+    # should not be transformed by TR6\n+    assert result == expr\n+\n+\n \n def test_TR7():\n     assert TR7(cos(x)**2) == cos(2*x)/2 + S(1)/2\n@@ -438,3 +449,4 @@ def test_as_f_sign_1():\n     assert as_f_sign_1(2*x + 2) == (2, x, 1)\n     assert as_f_sign_1(x*y - y) == (y, x, -1)\n     assert as_f_sign_1(-x*y + y) == (-y, x, -1)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-11143",
        "model_patch": "diff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex d01803204..ddfd44a69 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -141,6 +141,18 @@ class TestAssertionRewrite:\n         assert isinstance(m.body[1], ast.Assert)\n         assert m.body[1].msg is None\n \n+    def test_dont_rewrite_with_number(self) -> None:\n+        s = \"\"\"123\\nassert 14\"\"\"\n+        m = rewrite(s)\n+        assert len(m.body) == 2\n+        assert isinstance(m.body[0], ast.Expr)\n+        assert isinstance(m.body[0].value, ast.Constant)\n+        assert m.body[0].value.value == 123\n+        assert isinstance(m.body[1], ast.Assert)\n+        assert m.body[1].msg is None\n+    \n+\n+\n     def test_dont_rewrite_plugin(self, pytester: Pytester) -> None:\n         contents = {\n             \"conftest.py\": \"pytest_plugins = 'plugin'; import plugin\",\n@@ -2042,3 +2054,4 @@ class TestReprSizeVerbosity:\n         self.create_test_file(pytester, DEFAULT_REPR_MAX_SIZE * 10)\n         result = pytester.runpytest(\"-vv\")\n         result.stdout.no_fnmatch_line(\"*xxx...xxx*\")\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-10924",
        "model_patch": "diff --git a/tests/model_fields/test_floatfield.py b/tests/model_fields/test_floatfield.py\nindex 481925cf11..24035d93a9 100644\n--- a/tests/model_fields/test_floatfield.py\n+++ b/tests/model_fields/test_floatfield.py\n@@ -31,3 +31,33 @@ class TestFloatField(TestCase):\n         obj.size = obj\n         with self.assertRaisesMessage(TypeError, msg):\n             obj.save()\n+\n+    def test_callable_path(self):\n+        \"\"\"\n+        Test that FilePathField accepts a callable for its path parameter.\n+        \"\"\"\n+        from django.db import models\n+        import os\n+        import tempfile\n+        # Create a temporary directory\n+        temp_dir = tempfile.mkdtemp()\n+        # Create a test file in the temporary directory\n+        test_file_path = os.path.join(temp_dir, 'test_file.txt')\n+        with open(test_file_path, 'w') as f:\n+            f.write('test content')\n+        # Define a callable that returns the path\n+        def get_path():\n+            return temp_dir\n+        # Create a model with FilePathField using a callable path\n+        class FilePathModel(models.Model):\n+            file_path = models.FilePathField(path=get_path)\n+            class Meta:\n+                app_label = 'test_app'\n+        # This should not raise an exception if callable paths are supported\n+        field = FilePathModel._meta.get_field('file_path')\n+        # Clean up\n+        os.unlink(test_file_path)\n+        os.rmdir(temp_dir)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14155",
        "model_patch": "diff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 09028be795..92f7ef3f48 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1145,6 +1145,27 @@ class ResolverMatchTests(SimpleTestCase):\n             \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n         )\n \n+    def test_partial_repr(self):\n+        \"\"\"\n+        ResolverMatch.__repr__() should handle functools.partial() views properly.\n+        \"\"\"\n+        import functools\n+        def view_func(request, arg1, arg2):\n+            return None\n+        partial_view = functools.partial(view_func, arg1='default')\n+        match = ResolverMatch(\n+            func=partial_view,\n+            args=(),\n+            kwargs={'arg2': 'value'},\n+            url_name='partial-view',\n+        )\n+        # The representation should include the original function name, not just \"functools.partial\"\n+        self.assertIn('view_func', repr(match))\n+        # The representation should include the partial arguments\n+        self.assertIn(\"arg1='default'\", repr(match))\n+    \n+\n+\n \n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n class ErroneousViewTests(SimpleTestCase):\n@@ -1310,3 +1331,4 @@ class LookaheadTests(SimpleTestCase):\n             with self.subTest(name=name, kwargs=kwargs):\n                 with self.assertRaises(NoReverseMatch):\n                     reverse(name, kwargs=kwargs)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-13439",
        "model_patch": "diff --git a/sklearn/tests/test_pipeline.py b/sklearn/tests/test_pipeline.py\nindex 8d6fe8f703..29f9d444c1 100644\n--- a/sklearn/tests/test_pipeline.py\n+++ b/sklearn/tests/test_pipeline.py\n@@ -551,6 +551,24 @@ def test_pipeline_index():\n     assert_raises(IndexError, lambda: pipe[3])\n     assert_raises(KeyError, lambda: pipe['foobar'])\n \n+def test_pipeline_len():\n+    \"\"\"Check that pipeline supports len.\"\"\"\n+    pipe = Pipeline([('transf1', Transf()), ('transf2', Transf())])\n+    # Test that len(pipe) returns the number of steps in the pipeline\n+    assert_equal(len(pipe), 2)\n+    # Test with a longer pipeline\n+    pipe = Pipeline([\n+        ('transf1', Transf()),\n+        ('transf2', Transf()),\n+        ('transf3', Transf()),\n+        ('transf4', Transf())\n+    ])\n+    assert_equal(len(pipe), 4)\n+    # Test that pipe[:len(pipe)] works (this was the specific issue mentioned)\n+    pipe_slice = pipe[:len(pipe)]\n+    assert_equal(len(pipe_slice), len(pipe))\n+\n+\n \n def test_set_pipeline_steps():\n     transf1 = Transf()\n@@ -1071,3 +1089,4 @@ def test_make_pipeline_memory():\n     assert pipeline.memory is None\n \n     shutil.rmtree(cachedir)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12308",
        "model_patch": "diff --git a/tests/admin_utils/tests.py b/tests/admin_utils/tests.py\nindex 463ba9556d..92188dc425 100644\n--- a/tests/admin_utils/tests.py\n+++ b/tests/admin_utils/tests.py\n@@ -387,3 +387,19 @@ class UtilsTests(SimpleTestCase):\n \n     def test_quote(self):\n         self.assertEqual(quote('something\\nor\\nother'), 'something_0Aor_0Aother')\n+\n+    def test_display_for_jsonfield_readonly(self):\n+        \"\"\"JSONField values should be displayed as valid JSON when readonly in admin.\"\"\"\n+        class JSONFieldModel(models.Model):\n+            json_field = models.JSONField()\n+        json_field = JSONFieldModel._meta.get_field('json_field')\n+        json_value = {\"foo\": \"bar\"}\n+        # This should return a properly formatted JSON string, not a Python dict representation\n+        result = display_for_field(json_value, json_field, empty_value_display='-')\n+        # The test should fail because currently it returns the Python dict representation\n+        # which looks like: {'foo': 'bar'} instead of proper JSON: {\"foo\": \"bar\"}\n+        self.assertNotEqual(str(result), str(json_value))\n+        self.assertEqual(result, '{\"foo\": \"bar\"}')\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-13647",
        "model_patch": "diff --git a/sympy/matrices/tests/test_matrices.py b/sympy/matrices/tests/test_matrices.py\nindex 78bd30fc81..707a1eacaf 100644\n--- a/sympy/matrices/tests/test_matrices.py\n+++ b/sympy/matrices/tests/test_matrices.py\n@@ -2234,6 +2234,24 @@ def test_col_insert():\n         l.insert(i, 4)\n         assert flatten(zeros(3).col_insert(i, c4).row(0).tolist()) == l\n \n+def test_col_insert_regression():\n+    # Test for regression in col_insert where identity matrix gets shifted incorrectly\n+    M = eye(6)\n+    V = 2 * ones(6, 2)\n+    # Insert the columns at position 3\n+    result = M.col_insert(3, V)\n+    # Expected result: original identity matrix with 2 columns of 2s inserted at position 3\n+    expected = Matrix([\n+        [1, 0, 0, 2, 2, 0, 0, 0],\n+        [0, 1, 0, 2, 2, 0, 0, 0],\n+        [0, 0, 1, 2, 2, 0, 0, 0],\n+        [0, 0, 0, 2, 2, 1, 0, 0],\n+        [0, 0, 0, 2, 2, 0, 1, 0],\n+        [0, 0, 0, 2, 2, 0, 0, 1]\n+    ])\n+    assert result == expected\n+\n+\n \n def test_normalized():\n     assert Matrix([3, 4]).normalized() == \\\n@@ -2996,3 +3014,4 @@ def test_deprecated():\n         P, Jcells = m.jordan_cells()\n         assert Jcells[1] == Matrix(1, 1, [2])\n         assert Jcells[0] == Matrix(2, 2, [2, 1, 0, 2])\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11815",
        "model_patch": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex f97d76e9ad..e94b2b26f9 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -306,6 +306,31 @@ class WriterTests(SimpleTestCase):\n             \"default=migrations.test_writer.IntEnum(1))\"\n         )\n \n+    def test_serialize_enum_by_name(self):\n+        \"\"\"Test that Enum objects are serialized by name rather than by value.\"\"\"\n+        class TranslatedEnum(enum.Enum):\n+            GOOD = _('Good')\n+            BAD = _('Bad')\n+            def __str__(self):\n+                return self.name\n+        # Test serialization of the enum value\n+        self.assertSerializedResultEqual(\n+            TranslatedEnum.GOOD,\n+                                                                (\"migrations.test_writer.TranslatedEnum['GOOD']\", {'import migrations.test_writer'})\n+        )\n+        # Test serialization in a model field\n+        field = models.CharField(default=TranslatedEnum.BAD, max_length=128)\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.TranslatedEnum['BAD']\",\n+            string\n+        )\n+        # Ensure it doesn't use the value which could be translated\n+        self.assertNotIn(\"TranslatedEnum('Bad')\", string)\n+        self.assertNotIn(\"TranslatedEnum(_('Bad'))\", string)\n+    \n+\n+\n     def test_serialize_choices(self):\n         class TextChoices(models.TextChoices):\n             A = 'A', 'A value'\n@@ -712,3 +737,4 @@ class WriterTests(SimpleTestCase):\n     def test_register_non_serializer(self):\n         with self.assertRaisesMessage(ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"):\n             MigrationWriter.register_serializer(complex, TestModel1)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-13971",
        "model_patch": "diff --git a/sympy/series/tests/test_sequences.py b/sympy/series/tests/test_sequences.py\nindex a63b81b2c5..38c8c1c629 100644\n--- a/sympy/series/tests/test_sequences.py\n+++ b/sympy/series/tests/test_sequences.py\n@@ -276,3 +276,19 @@ def test_find_linear_recurrence():\n     == ([19/2, -20, 27/2], (-31*x**2 + 32*x - 4)/(27*x**3 - 40*x**2 + 19*x -2))\n     assert sequence(fibonacci(n)).find_linear_recurrence(30,gfvar=x) \\\n     == ([1, 1], -x/(x**2 + x - 1))\n+\n+def test_SeqFormula_pretty_print():\n+    from sympy.printing.pretty.pretty import pretty\n+    from pretty_symbology import pretty_use_unicode\n+    n = symbols('n', integer=True)\n+    seq = SeqFormula(n**2, (n, 0, oo))\n+    # Test with ASCII mode\n+    result_ascii = pretty(seq, use_unicode=False)\n+    assert '[' in result_ascii and ']' in result_ascii\n+    assert '\\\\[' not in result_ascii and '\\\\]' not in result_ascii\n+    # Test with Unicode mode\n+    result_unicode = pretty(seq, use_unicode=True)\n+    assert '[' in result_unicode and ']' in result_unicode\n+    assert '\\\\[' not in result_unicode and '\\\\]' not in result_unicode\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-25442",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_offsetbox.py b/lib/matplotlib/tests/test_offsetbox.py\nindex cd57122272..ab6d86f868 100644\n--- a/lib/matplotlib/tests/test_offsetbox.py\n+++ b/lib/matplotlib/tests/test_offsetbox.py\n@@ -450,3 +450,33 @@ def test_paddedbox():\n     pb = PaddedBox(ta, pad=15, draw_frame=True)\n     ab = AnchoredOffsetbox('lower right', child=pb)\n     ax.add_artist(ab)\n+\n+def test_offsetbox_disconnect_with_none_ref_artist_figure():\n+    \"\"\"Test that disconnecting an OffsetBox with ref_artist.figure=None doesn't raise.\"\"\"\n+    fig, ax = plt.subplots()\n+    # Create a DrawingArea as the ref_artist\n+    da = DrawingArea(100, 20)\n+    ab = AnnotationBbox(da, (0.5, 0.5), \n+                        xycoords='axes fraction',\n+                        boxcoords=\"axes fraction\",\n+                        box_alignment=(0.5, 0.5))\n+    ax.add_artist(ab)\n+    # Simulate a mouse click event to trigger the picking mechanism\n+    canvas = fig.canvas\n+    # Create a MouseEvent\n+    event = MouseEvent('button_press_event', canvas, \n+                       0.5, 0.5,  # x, y in figure coordinates\n+                       MouseButton.LEFT)\n+    # Trigger the pick event\n+    canvas.callbacks.process('button_press_event', event)\n+    # Set figure to None to simulate the issue condition\n+    ab.offsetbox.ref_artist.figure = None\n+    # Create a release event that should trigger _check_still_parented and disconnect\n+    release_event = MouseEvent('button_release_event', canvas, \n+                              0.5, 0.5,  # x, y in figure coordinates\n+                              MouseButton.LEFT)\n+    # This should not raise an AttributeError\n+    canvas.callbacks.process('button_release_event', release_event)\n+    plt.close(fig)\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-16820",
        "model_patch": "diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex b1c91bcf5c..926945a255 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -2911,6 +2911,65 @@ class SquashMigrationsTests(MigrationTestBase):\n                     verbosity=0,\n                 )\n \n+    def test_squashmigrations_index_together_to_indexes(self):\n+        from django.db import migrations\n+        \"\"\"\n+        Tests that squashing migrations with index_together -> indexes transition\n+        removes the RemovedInDjango50Warning deprecation warnings.\n+        \"\"\"\n+        with self.temporary_migration_module() as migration_dir:\n+            # Create initial migration with index_together\n+            operations = [\n+                migrations.CreateModel(\n+                    \"TestModel\",\n+                    [\n+                        (\"id\", models.AutoField(primary_key=True)),\n+                        (\"first_name\", models.CharField(max_length=100)),\n+                        (\"last_name\", models.CharField(max_length=100)),\n+                    ],\n+                    options={\"index_together\": [(\"first_name\", \"last_name\")]},\n+                ),\n+            ]\n+            migration_a = self.get_migration_class(\"0001_initial\", operations)\n+            with open(os.path.join(migration_dir, \"0001_initial.py\"), \"w\") as fh:\n+                fh.write(migration_a)\n+            # Create second migration that transitions to indexes\n+            operations = [\n+                migrations.AlterField(\n+                    \"TestModel\",\n+                    \"first_name\",\n+                    models.CharField(max_length=150),\n+                ),\n+                migrations.AlterIndexTogether(\n+                    \"TestModel\",\n+                    set(),\n+                ),\n+                migrations.AddIndex(\n+                    \"TestModel\",\n+                    models.Index(fields=[\"first_name\", \"last_name\"], name=\"test_idx\"),\n+                ),\n+            ]\n+            migration_b = self.get_migration_class(\"0002_alter_index\", operations)\n+            with open(os.path.join(migration_dir, \"0002_alter_index.py\"), \"w\") as fh:\n+                fh.write(migration_b)\n+            # Ensure no deprecation warnings when squashing migrations\n+            with self.assertNoWarnings():\n+                call_command(\n+                    \"squashmigrations\",\n+                    \"migrations\",\n+                    \"0001\",\n+                    \"0002\",\n+                    interactive=False,\n+                    verbosity=0,\n+                )\n+            # Check that the squashed migration doesn't use index_together\n+            with open(os.path.join(migration_dir, \"0001_squashed_0002_alter_index.py\")) as fh:\n+                content = fh.read()\n+                self.assertNotIn(\"index_together\", content)\n+                self.assertIn(\"indexes\", content)\n+    \n+\n+\n     def test_squashmigrations_manual_porting(self):\n         out = io.StringIO()\n         with self.temporary_migration_module(\n@@ -3184,3 +3243,4 @@ class OptimizeMigrationTests(MigrationTestBase):\n         msg = \"Cannot find a migration matching 'nonexistent' from app 'migrations'.\"\n         with self.assertRaisesMessage(CommandError, msg):\n             call_command(\"optimizemigration\", \"migrations\", \"nonexistent\")\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14855",
        "model_patch": "diff --git a/tests/admin_views/test_history_view.py b/tests/admin_views/test_history_view.py\nindex 277990cc92..9ce6cbffcc 100644\n--- a/tests/admin_views/test_history_view.py\n+++ b/tests/admin_views/test_history_view.py\n@@ -43,3 +43,66 @@ class AdminHistoryViewTests(TestCase):\n             'nolabel_form_field and not_a_form_field. '\n             'Changed City verbose_name for city \u201c%s\u201d.' % city\n         )\n+\n+\n+    def test_readonly_foreignkey_links_custom_admin(self):\n+        \"\"\"\n+        ForeignKey readonly fields render as links with the correct admin URL\n+        when using a custom admin site.\n+        \"\"\"\n+        from django.contrib.admin import AdminSite\n+        from django.urls import path\n+        from django.test.client import RequestFactory\n+        from django.utils.html import format_html\n+        from django.contrib.admin.helpers import AdminReadonlyField\n+        from django.contrib.auth.admin import UserAdmin\n+        from django.contrib.admin import ModelAdmin\n+        from django.db import models\n+        # Create a custom admin site\n+        class CustomAdminSite(AdminSite):\n+            site_url = '/custom-admin/'\n+        custom_admin_site = CustomAdminSite(name='custom_admin')\n+        # Register the User model with the custom admin site\n+        custom_admin_site.register(User, UserAdmin)\n+        # Create a user object\n+        user = User.objects.create_user(username='testuser', password='password')\n+        # Create a mock request\n+        request = RequestFactory().get('/')\n+        request.user = self.superuser\n+        # Create a ModelAdmin instance for the custom admin site\n+        class CustomModelAdmin(ModelAdmin):\n+            readonly_fields = ['user']\n+            admin_site = custom_admin_site\n+        model_admin = CustomModelAdmin(User, custom_admin_site)\n+        # Create a form field\n+        field = models.ForeignKey(User, on_delete=models.CASCADE)\n+        field.name = 'user'\n+        field.remote_field = field.remote_field\n+        # Create an AdminReadonlyField\n+        admin_readonly_field = AdminReadonlyField(\n+            form=None,\n+            field=field,\n+            model_admin=model_admin,\n+            is_first=True,\n+            empty_value_display='',\n+        )\n+        # Override the get_urls method to include our custom admin site\n+        original_get_urls = custom_admin_site.get_urls\n+        def get_urls():\n+            url_patterns = original_get_urls()\n+            return [\n+                path(\n+                    'custom-admin/auth/user/<path:object_id>/change/',\n+                    custom_admin_site.admin_view(lambda request, object_id: None),\n+                    name='custom_admin:auth_user_change',\n+                ),\n+            ] + url_patterns\n+        custom_admin_site.get_urls = get_urls\n+        # Get the rendered HTML for the readonly field\n+        with self.settings(ROOT_URLCONF='django.contrib.admin.sites'):\n+            rendered_html = admin_readonly_field.contents()\n+        # The URL should contain 'custom-admin' instead of 'admin'\n+        self.assertIn('/custom-admin/', rendered_html)\n+        self.assertNotIn('/admin/', rendered_html)\n+    \n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13551",
        "model_patch": "diff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..b50a0f32bb 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -110,3 +110,22 @@ class TokenGeneratorTest(TestCase):\n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_by_email_change(self):\n+        \"\"\"\n+        Test that changing a user's email address invalidates password reset tokens.\n+        \"\"\"\n+        user = User.objects.create_user('emailtestuser', 'initial@example.com', 'testpw')\n+        token_generator = PasswordResetTokenGenerator()\n+        # Generate a token with the initial email\n+        token = token_generator.make_token(user)\n+        # Verify the token is valid\n+        self.assertTrue(token_generator.check_token(user, token))\n+        # Change the user's email address\n+        user.email = 'changed@example.com'\n+        user.save()\n+        # The token should now be invalid because the email changed\n+        self.assertFalse(token_generator.check_token(user, token))\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-21614",
        "model_patch": "diff --git a/sympy/core/tests/test_kind.py b/sympy/core/tests/test_kind.py\nindex eabf9ad0c4..55f8407615 100644\n--- a/sympy/core/tests/test_kind.py\n+++ b/sympy/core/tests/test_kind.py\n@@ -39,6 +39,17 @@ def test_Integral_kind():\n     assert Integral(comm_x, comm_x).kind is NumberKind\n     assert Integral(A, comm_x).kind is MatrixKind(NumberKind)\n \n+def test_Derivative_kind():\n+    from sympy import symbols\n+    from sympy.core.function import Derivative\n+    x = symbols('x')\n+    A = MatrixSymbol('A', 2, 2)\n+    # Test scalar derivative\n+    assert Derivative(x, x).kind is NumberKind\n+    # Test matrix derivative - this should be MatrixKind(NumberKind) but currently returns UndefinedKind\n+    assert Derivative(A, x).kind is MatrixKind(NumberKind)\n+\n+\n def test_Matrix_kind():\n     classes = (Matrix, SparseMatrix, ImmutableMatrix, ImmutableSparseMatrix)\n     for cls in classes:\n@@ -49,3 +60,4 @@ def test_MatMul_kind():\n     M = Matrix([[1,2],[3,4]])\n     assert MatMul(2, M).kind is MatrixKind(NumberKind)\n     assert MatMul(comm_x, M).kind is MatrixKind(NumberKind)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-20154",
        "model_patch": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex f3ebd270dc..afeff9f915 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -513,6 +513,35 @@ def test_partitions():\n             i += 1\n         assert i == RGS_enum(n)\n \n+def test_partitions_reuse():\n+    # Test that partitions() doesn't reuse dictionaries\n+    # This test should fail with the current implementation and pass when fixed\n+    # Direct list conversion should give different dictionaries\n+    part_list = list(partitions(4))\n+    # If dictionaries are reused, they'll all be the same (the last yielded one)\n+    assert len(set(map(str, part_list))) > 1\n+    # Test that modifications to one partition don't affect others\n+    parts = []\n+    for p in partitions(4):\n+        parts.append(p.copy())  # Currently needed workaround\n+    # Modify the first partition\n+    parts[0][1] = 999\n+    # Get fresh partitions to compare\n+    fresh_parts = [p.copy() for p in partitions(4)]\n+    # The second partition should not have been affected by modifying the first\n+    assert fresh_parts[1] != parts[0]\n+    # Test that we can safely use the partitions without copying\n+    results = []\n+    for p in partitions(5, k=3):\n+        # Store the partition and a value derived from it\n+        results.append((dict(p), sum(k*v for k, v in p.items())))\n+    # Verify we have the correct number of unique partitions\n+    assert len(results) == len(set(str(p) for p, _ in results))\n+    # Verify the sums are correct for each partition\n+    for p, total in results:\n+        assert total == 5  # All partitions of 5 should sum to 5\n+\n+\n \n def test_binary_partitions():\n     assert [i[:] for i in binary_partitions(10)] == [[8, 2], [8, 1, 1],\n@@ -834,3 +863,4 @@ def test_ibin():\n     assert list(ibin(2, '', str=True)) == ['00', '01', '10', '11']\n     raises(ValueError, lambda: ibin(-.5))\n     raises(ValueError, lambda: ibin(2, 1))\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-24213",
        "model_patch": "diff --git a/sympy/physics/units/tests/test_unitsystem.py b/sympy/physics/units/tests/test_unitsystem.py\nindex a04f3aabb6..81cc8101b3 100644\n--- a/sympy/physics/units/tests/test_unitsystem.py\n+++ b/sympy/physics/units/tests/test_unitsystem.py\n@@ -84,3 +84,27 @@ def test_derived_units_must_exist_in_unit_system():\n             units = preferred_unit.atoms(Quantity)\n             for unit in units:\n                 assert unit in unit_system._units, f\"Unit {unit} is not in unit system {unit_system}\"\n+\n+def test_collect_factor_and_dimension_with_equivalent_dimensions():\n+    from sympy.physics.units.quantities import Quantity\n+    from sympy.physics.units.systems import SI\n+    from sympy.physics.units import velocity, acceleration, time\n+    from sympy.physics.units import meter, second\n+    # Create quantities with specific dimensions and scale factors\n+    v1 = Quantity('v1')\n+    SI.set_quantity_dimension(v1, velocity)\n+    SI.set_quantity_scale_factor(v1, 2 * meter / second)\n+    a1 = Quantity('a1')\n+    SI.set_quantity_dimension(a1, acceleration)\n+    SI.set_quantity_scale_factor(a1, -9.8 * meter / second**2)\n+    t1 = Quantity('t1')\n+    SI.set_quantity_dimension(t1, time)\n+    SI.set_quantity_scale_factor(t1, 5 * second)\n+    # This should not raise an exception because a1*t1 has the same dimension as v1 (velocity)\n+    expr1 = a1*t1 + v1\n+    factor, dimension = SI._collect_factor_and_dimension(expr1)\n+    # Verify the result\n+    assert dimension == velocity.dimension\n+    assert factor == -9.8 * 5 + 2\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12286",
        "model_patch": "diff --git a/tests/check_framework/test_translation.py b/tests/check_framework/test_translation.py\nindex 4cd79d803f..45682711ba 100644\n--- a/tests/check_framework/test_translation.py\n+++ b/tests/check_framework/test_translation.py\n@@ -84,3 +84,14 @@ class TranslationCheckTests(SimpleTestCase):\n             self.assertEqual(check_language_settings_consistent(None), [\n                 Error(msg, id='translation.E004'),\n             ])\n+\n+    def test_sublanguage_with_base_language(self):\n+        \"\"\"\n+        No error when sublanguage is not in LANGUAGES but its base language is.\n+        \"\"\"\n+        with self.settings(LANGUAGE_CODE='de-at', LANGUAGES=[('de', 'German')]):\n+            errors = check_setting_language_code(None)\n+            self.assertEqual(errors, [])\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-15512",
        "model_patch": "diff --git a/sklearn/cluster/tests/test_affinity_propagation.py b/sklearn/cluster/tests/test_affinity_propagation.py\nindex 98f0f79ee7..b90ee73bd2 100644\n--- a/sklearn/cluster/tests/test_affinity_propagation.py\n+++ b/sklearn/cluster/tests/test_affinity_propagation.py\n@@ -93,18 +93,27 @@ def test_affinity_propagation_predict_error():\n         af.predict(X)\n \n \n+\n def test_affinity_propagation_fit_non_convergence():\n     # In case of non-convergence of affinity_propagation(), the cluster\n     # centers should be an empty array and training samples should be labelled\n     # as noise (-1)\n-    X = np.array([[0, 0], [1, 1], [-2, -2]])\n-\n-    # Force non-convergence by allowing only a single iteration\n-    af = AffinityPropagation(preference=-10, max_iter=1)\n-\n+    # Create a dataset that won't converge with limited iterations\n+    X = np.array([[1, 0, 0, 0, 0, 0], \n+                  [0, 1, 1, 1, 0, 0], \n+                  [0, 0, 1, 0, 0, 1]])\n+    # Force non-convergence by allowing only a few iterations\n+    af = AffinityPropagation(affinity='euclidean', max_iter=2)\n+    # The fit should raise a ConvergenceWarning\n     assert_warns(ConvergenceWarning, af.fit, X)\n-    assert_array_equal(np.empty((0, 2)), af.cluster_centers_)\n+    # Test that cluster_centers_indices_ is an empty array\n+    assert_array_equal(np.array([]), af.cluster_centers_indices_)\n+    # Test that all labels are -1 (indicating no cluster assignment)\n     assert_array_equal(np.array([-1, -1, -1]), af.labels_)\n+    # Test that cluster_centers_ is an empty array with correct shape\n+    # (0 centers, but with the right number of features)\n+    assert_array_equal(np.empty((0, X.shape[1])), af.cluster_centers_)\n+\n \n \n def test_affinity_propagation_equal_mutual_similarities():\n@@ -187,3 +196,4 @@ def test_affinity_propagation_convergence_warning_dense_sparse(centers):\n         assert_array_equal(ap.predict(X),\n                            np.zeros(X.shape[0], dtype=int))\n     assert len(record) == 0\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-22711",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_widgets.py b/lib/matplotlib/tests/test_widgets.py\nindex a19770e3b0..eb56f52434 100644\n--- a/lib/matplotlib/tests/test_widgets.py\n+++ b/lib/matplotlib/tests/test_widgets.py\n@@ -1119,6 +1119,24 @@ def test_range_slider(orientation):\n     slider.reset()\n     assert_allclose(slider.val, [0.1, 0.34])\n \n+def test_range_slider_init_value():\n+    \"\"\"Test that RangeSlider can be initialized with a value.\"\"\"\n+    fig, ax = plt.subplots()\n+    slider_ax = fig.add_axes([0.2, 0.1, 0.6, 0.03])\n+    # Create a RangeSlider with initial values\n+    initial_values = [0.3, 0.7]\n+    slider = widgets.RangeSlider(\n+        slider_ax, \"Threshold\", 0, 1, valinit=initial_values\n+    )\n+    # Check that the slider's value matches the initial values\n+    assert_allclose(slider.val, initial_values)\n+    # Test setting a new value\n+    new_values = [0.4, 0.8]\n+    slider.set_val(new_values)\n+    assert_allclose(slider.val, new_values)\n+    plt.close(fig)\n+\n+\n \n def check_polygon_selector(event_sequence, expected_result, selections_count,\n                            **kwargs):\n@@ -1478,3 +1496,4 @@ def test_MultiCursor(horizOn, vertOn):\n         assert l.get_xdata() == (.5, .5)\n     for l in multi.hlines:\n         assert l.get_ydata() == (.25, .25)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11620",
        "model_patch": "diff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex d26923ab9d..d3b3105254 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -482,6 +482,34 @@ class ResolverTests(SimpleTestCase):\n                                 'Wrong URL name.  Expected \"%s\", got \"%s\".' % (e['name'], t.name)\n                             )\n \n+    def test_http404_in_path_converter(self):\n+        \"\"\"\n+        When DEBUG is True, raising Http404 in a path converter's to_python method\n+        should result in a technical 404 response, not a generic server error.\n+        \"\"\"\n+        from django.http import Http404\n+        from django.urls import register_converter\n+        class Http404RaisingConverter:\n+            regex = '[0-9]+'\n+            def to_python(self, value):\n+                raise Http404(\"This object does not exist\")\n+            def to_url(self, value):\n+                return str(value)\n+        register_converter(Http404RaisingConverter, 'http404conv')\n+        urls = [\n+            path('http404/<http404conv:id>/', empty_view, name='http404'),\n+        ]\n+        with self.settings(ROOT_URLCONF=urls, DEBUG=True):\n+            response = self.client.get('/http404/1/')\n+            self.assertEqual(response.status_code, 404)\n+            # When the bug is fixed, the response should contain the technical 404 page\n+            # with the specific error message from the Http404 exception\n+            self.assertContains(response, \"This object does not exist\", status_code=404)\n+            # The response should not contain the generic server error message\n+            self.assertNotContains(response, \"A server error occurred\", status_code=404)\n+    \n+\n+\n     def test_namespaced_view_detail(self):\n         resolver = get_resolver('urlpatterns_reverse.nested_urls')\n         self.assertTrue(resolver._is_callback('urlpatterns_reverse.nested_urls.view1'))\n@@ -1302,3 +1330,4 @@ class LookaheadTests(SimpleTestCase):\n             with self.subTest(name=name, kwargs=kwargs):\n                 with self.assertRaises(NoReverseMatch):\n                     reverse(name, kwargs=kwargs)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11905",
        "model_patch": "diff --git a/tests/lookup/tests.py b/tests/lookup/tests.py\nindex 1958b995b2..2aa48809c1 100644\n--- a/tests/lookup/tests.py\n+++ b/tests/lookup/tests.py\n@@ -969,3 +969,20 @@ class LookupTests(TestCase):\n         ).values('max_id')\n         authors = Author.objects.filter(id=authors_max_ids[:1])\n         self.assertEqual(authors.get(), newest_author)\n+\n+    def test_isnull_non_boolean_value(self):\n+        \"\"\"\n+        Using non-boolean values with __isnull lookup should raise an error.\n+        \"\"\"\n+        with self.assertRaisesMessage(ValueError, \"The __isnull lookup only takes a boolean value\"):\n+            list(Article.objects.filter(name__isnull=1))\n+        with self.assertRaisesMessage(ValueError, \"The __isnull lookup only takes a boolean value\"):\n+            list(Article.objects.filter(name__isnull=\"\"))\n+        with self.assertRaisesMessage(ValueError, \"The __isnull lookup only takes a boolean value\"):\n+            list(Article.objects.filter(name__isnull=\"True\"))\n+        # These should still work\n+        list(Article.objects.filter(name__isnull=True))\n+        list(Article.objects.filter(name__isnull=False))\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12184",
        "model_patch": "diff --git a/tests/urlpatterns/tests.py b/tests/urlpatterns/tests.py\nindex 92c4e6399e..adb61f3820 100644\n--- a/tests/urlpatterns/tests.py\n+++ b/tests/urlpatterns/tests.py\n@@ -68,6 +68,34 @@ class SimplifiedURLTests(SimpleTestCase):\n                     r'^regex_optional/(?P<arg1>\\d+)/(?:(?P<arg2>\\d+)/)?',\n                 )\n \n+    def test_optional_param_view_function_call(self):\n+        \"\"\"\n+        Test that view functions with optional URL parameters are called correctly.\n+        \"\"\"\n+        # Define a view function with an optional parameter\n+        def view_with_optional_param(request, param=None):\n+            return param\n+        # Create URL patterns with optional parameters\n+        urlpatterns = [\n+            path('optional_param/', view_with_optional_param, name='optional_param'),\n+            path('optional_param/<str:param>/', view_with_optional_param, name='optional_param_with_value'),\n+        ]\n+        # Resolve the URL without the optional parameter\n+        match = resolve('/optional_param/', urlpatterns)\n+        # The view function should be called with just the request\n+        # and the optional parameter should use its default value\n+        self.assertEqual(match.func, view_with_optional_param)\n+        self.assertEqual(match.args, ())\n+        self.assertEqual(match.kwargs, {})\n+        # Resolve the URL with the optional parameter\n+        match = resolve('/optional_param/value/', urlpatterns)\n+        # The view function should be called with the request and the parameter value\n+        self.assertEqual(match.func, view_with_optional_param)\n+        self.assertEqual(match.args, ())\n+        self.assertEqual(match.kwargs, {'param': 'value'})\n+    \n+\n+\n     def test_path_lookup_with_inclusion(self):\n         match = resolve('/included_urls/extra/something/')\n         self.assertEqual(match.url_name, 'inner-extra')\n@@ -230,3 +258,4 @@ class ConversionExceptionTests(SimpleTestCase):\n             raise ValueError('This value error propagates.')\n         with self.assertRaisesMessage(ValueError, 'This value error propagates.'):\n             reverse('dynamic', kwargs={'value': object()})\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-16046",
        "model_patch": "diff --git a/tests/utils_tests/test_numberformat.py b/tests/utils_tests/test_numberformat.py\nindex cec3e4c385..1a4782dc13 100644\n--- a/tests/utils_tests/test_numberformat.py\n+++ b/tests/utils_tests/test_numberformat.py\n@@ -172,3 +172,11 @@ class TestNumberFormat(SimpleTestCase):\n \n         price = EuroDecimal(\"1.23\")\n         self.assertEqual(nformat(price, \",\"), \"\u20ac 1,23\")\n+\n+    def test_format_empty_string(self):\n+        \"\"\"Test that formatting an empty string doesn't raise an IndexError.\"\"\"\n+        self.assertEqual(nformat(\"\", \".\"), \"\")\n+        self.assertEqual(nformat(None, \".\"), \"\")\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12284",
        "model_patch": "diff --git a/tests/model_inheritance/test_abstract_inheritance.py b/tests/model_inheritance/test_abstract_inheritance.py\nindex dfcd47c111..82d35869d3 100644\n--- a/tests/model_inheritance/test_abstract_inheritance.py\n+++ b/tests/model_inheritance/test_abstract_inheritance.py\n@@ -351,3 +351,30 @@ class AbstractInheritanceTests(SimpleTestCase):\n                 ('name', models.CharField),\n             ]\n         )\n+\n+    @isolate_apps('model_inheritance')\n+    def test_inherited_choices_display(self):\n+        \"\"\"\n+        get_FOO_display() works correctly with inherited choices that are\n+        extended in the child model.\n+        \"\"\"\n+        class AbstractBase(models.Model):\n+            CHOICES = [('A', 'output1'), ('B', 'output2')]\n+            field_foo = models.CharField(max_length=254, choices=CHOICES)\n+            class Meta:\n+                abstract = True\n+        class Child(AbstractBase):\n+            # Override choices to add a new option\n+            CHOICES = [('A', 'output1'), ('B', 'output2'), ('C', 'output3')]\n+            field_foo = models.CharField(max_length=254, choices=CHOICES)\n+        # Create instances with different choices\n+        child_a = Child(field_foo='A')\n+        child_b = Child(field_foo='B')\n+        child_c = Child(field_foo='C')\n+        # Test that get_field_foo_display works for all choices\n+        self.assertEqual(child_a.get_field_foo_display(), 'output1')\n+        self.assertEqual(child_b.get_field_foo_display(), 'output2')\n+        self.assertEqual(child_c.get_field_foo_display(), 'output3')  # This will fail before the fix\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sphinx-doc__sphinx-7975",
        "model_patch": "diff --git a/tests/test_environment_indexentries.py b/tests/test_environment_indexentries.py\nindex 7f6003d54..9f4be6e27 100644\n--- a/tests/test_environment_indexentries.py\n+++ b/tests/test_environment_indexentries.py\n@@ -163,3 +163,24 @@ def test_create_index_by_key(app):\n     assert index[0] == ('D', [('docutils', [[('main', '#term-docutils')], [], None])])\n     assert index[1] == ('P', [('Python', [[('main', '#term-Python')], [], None])])\n     assert index[2] == ('\u30b9', [('\u30b9\u30d5\u30a3\u30f3\u30af\u30b9', [[('main', '#term-0')], [], '\u30b9'])])\n+\n+def test_symbols_in_index(app):\n+    # Create index entries with special characters that should all go under a single \"Symbols\" section\n+    text = (\".. index:: @symbol\\n\"\n+            \".. index:: \u00a3pound\\n\"\n+            \".. index:: \u2190arrow\\n\")\n+    restructuredtext.parse(app, text)\n+    index = IndexEntries(app.env).create_index(app.builder)\n+    # Count how many \"Symbols\" sections exist in the index\n+    symbol_sections = [section for section, entries in index if section == 'Symbols']\n+    # There should be exactly one \"Symbols\" section\n+    assert len(symbol_sections) == 1\n+    # Find the Symbols section and verify it contains all the special character entries\n+    for section, entries in index:\n+        if section == 'Symbols':\n+            entry_keys = [entry[0] for entry in entries]\n+            assert '@symbol' in entry_keys\n+            assert '\u00a3pound' in entry_keys\n+            assert '\u2190arrow' in entry_keys\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-13779",
        "model_patch": "diff --git a/sklearn/ensemble/tests/test_voting.py b/sklearn/ensemble/tests/test_voting.py\nindex 2a19bc9a64..081290886c 100644\n--- a/sklearn/ensemble/tests/test_voting.py\n+++ b/sklearn/ensemble/tests/test_voting.py\n@@ -454,6 +454,26 @@ def test_set_estimator_none():\n     assert_array_equal(eclf1.transform(X1), np.array([[0, 0], [1, 1]]))\n     assert_array_equal(eclf2.transform(X1), np.array([[0], [1]]))\n \n+def test_none_estimator_with_sample_weight():\n+    \"\"\"Test that VotingClassifier fit works when sample_weight is passed\n+    and one of the estimators is None.\"\"\"\n+    X, y = datasets.load_iris(return_X_y=True)\n+    sample_weight = np.ones(y.shape)\n+    # Create a VotingClassifier with two estimators\n+    voter = VotingClassifier(\n+        estimators=[('lr', LogisticRegression()),\n+                    ('rf', RandomForestClassifier())]\n+    )\n+    # Fit with sample_weight should work\n+    voter.fit(X, y, sample_weight=sample_weight)\n+    # Set one estimator to None\n+    voter.set_params(lr=None)\n+    # Fit with sample_weight should still work\n+    voter.fit(X, y, sample_weight=sample_weight)\n+    # Make sure we can predict with the remaining estimator\n+    voter.predict(X)\n+\n+\n \n @pytest.mark.filterwarnings('ignore: Default solver will be changed')  # 0.22\n @pytest.mark.filterwarnings('ignore: Default multi_class will')  # 0.22\n@@ -507,3 +527,4 @@ def test_transform():\n             eclf3.transform(X).swapaxes(0, 1).reshape((4, 6)),\n             eclf2.transform(X)\n     )\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-20322",
        "model_patch": "diff --git a/sympy/core/tests/test_sympify.py b/sympy/core/tests/test_sympify.py\nindex 55e77292de..2231f819e9 100644\n--- a/sympy/core/tests/test_sympify.py\n+++ b/sympy/core/tests/test_sympify.py\n@@ -769,3 +769,16 @@ def test_issue_14706():\n     raises(SympifyError, lambda: sympify(numpy.array([1]), strict=True))\n     raises(SympifyError, lambda: sympify(z1, strict=True))\n     raises(SympifyError, lambda: sympify(z2, strict=True))\n+\n+def test_ceiling_simplify_consistency():\n+    # Test for consistent behavior with ceiling expressions\n+    from sympy import ceiling\n+    # Both expressions should behave the same way regardless of evaluate flag\n+    expr1 = sympify('4*ceiling(x/4 - 3/4)', evaluate=False).simplify()\n+    expr2 = sympify('4*ceiling(x/4 - 3/4)', evaluate=True).simplify()\n+    # They should be equal to each other\n+    assert expr1 == expr2\n+    # And both should maintain the original form (not simplify to 4*ceiling(x/4) - 3)\n+    assert expr1 == 4*ceiling(x/4 - 3/4)\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-24265",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_style.py b/lib/matplotlib/tests/test_style.py\nindex e1388819ff..a6601aa8d0 100644\n--- a/lib/matplotlib/tests/test_style.py\n+++ b/lib/matplotlib/tests/test_style.py\n@@ -185,6 +185,22 @@ def test_deprecated_seaborn_styles():\n         mpl.style.use(\"seaborn-bright\")\n     assert mpl.rcParams == seaborn_bright\n \n+def test_seaborn_v0_8_styles_accessible():\n+    \"\"\"Test that seaborn-v0_8 styles are accessible in the style library.\"\"\"\n+    # Check that the old style name raises a KeyError\n+    with pytest.raises(KeyError):\n+        style.library[\"seaborn-colorblind\"]\n+    # Check that the new style name with v0_8 prefix is accessible\n+    assert \"seaborn-v0_8-colorblind\" in style.library\n+    # Verify we can actually use the new style\n+    with style.context(\"seaborn-v0_8-colorblind\"):\n+        colorblind_style = mpl.rcParams.copy()\n+    # Ensure the style actually changes parameters\n+    default_style = mpl.rcParams.copy()\n+    assert colorblind_style != default_style\n+\n+\n \n def test_up_to_date_blacklist():\n     assert mpl.style.core.STYLE_BLACKLIST <= {*mpl.rcsetup._validators}\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-15011",
        "model_patch": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex 149a7e3136..2a6d96429b 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -898,3 +898,21 @@ def test_issue_14941():\n     # test list\n     f3 = lambdify([x, y], [y, x], 'sympy')\n     assert f3(2, 3) == [3, 2]\n+\n+def test_matrix_symbol_with_curly_braces():\n+    from sympy.functions.elementary.trigonometric import atan as arctan\n+    from sympy.matrices.expressions import MatrixSymbol\n+    # Test that lambdify works with MatrixSymbol names containing curly braces\n+    # Regular MatrixSymbol works fine\n+    v = MatrixSymbol(\"v\", 2, 1)\n+    vector_id = lambdify(v, v)\n+    # Symbol with curly braces works fine\n+    curly_x = symbols(\"{x}\")\n+    curly_scalar_id = lambdify(curly_x, curly_x)\n+    # MatrixSymbol with curly braces should work with dummify=True\n+    curly_v = MatrixSymbol(\"{v}\", 2, 1)\n+    curly_vector_id = lambdify(curly_v, curly_v, dummify=True)\n+    # Test that the function works correctly\n+    assert curly_vector_id is not None\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-16400",
        "model_patch": "diff --git a/tests/auth_tests/test_management.py b/tests/auth_tests/test_management.py\nindex f567fd0dc1..5532561044 100644\n--- a/tests/auth_tests/test_management.py\n+++ b/tests/auth_tests/test_management.py\n@@ -1485,3 +1485,37 @@ class CreatePermissionsTests(TestCase):\n                 codename=codename,\n             ).exists()\n         )\n+\n+    def test_migrate_respects_database_parameter_for_permissions(self):\n+        \"\"\"\n+        Test that the migrate command respects the database parameter when creating permissions.\n+        \"\"\"\n+        # Create a custom database router that tracks calls\n+        class TrackingRouter:\n+            def __init__(self):\n+                self.read_calls = []\n+                self.write_calls = []\n+            def db_for_read(self, model, **hints):\n+                self.read_calls.append((model, hints))\n+                return None\n+            def db_for_write(self, model, **hints):\n+                self.write_calls.append((model, hints))\n+                return None\n+            def allow_migrate(self, db, app_label, model_name=None, **hints):\n+                return True\n+        # Set up the router\n+        router = TrackingRouter()\n+        with mock.patch('django.db.router.routers', [router]):\n+            # Run a migration with a specific database\n+            stdout = StringIO()\n+            call_command('migrate', 'auth', database='other', stdout=stdout)\n+            # Check that all Permission-related read operations used the specified database\n+            permission_reads = [call for call in router.read_calls \n+                               if call[0]._meta.model_name == 'permission']\n+            # The test passes if no Permission model read operations were routed through\n+            # the router (which would happen if the database parameter is respected)\n+            self.assertEqual(len(permission_reads), 0, \n+                            \"Permission model reads should not go through router when database is specified\")\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-16595",
        "model_patch": "diff --git a/tests/migrations/test_optimizer.py b/tests/migrations/test_optimizer.py\nindex 6485009eb4..5f07c071ad 100644\n--- a/tests/migrations/test_optimizer.py\n+++ b/tests/migrations/test_optimizer.py\n@@ -1152,3 +1152,41 @@ class OptimizerTests(SimpleTestCase):\n                 ),\n             ]\n         )\n+\n+    def test_reduce_multiple_alter_field(self):\n+        \"\"\"\n+        Tests that the optimizer reduces multiple AlterField operations\n+        on the same field to a single operation.\n+        \"\"\"\n+        # Multiple AlterField operations on the same field\n+        operations = [\n+            migrations.AlterField(\n+                model_name=\"book\",\n+                name=\"title\",\n+                field=models.CharField(max_length=128, null=True),\n+            ),\n+            migrations.AlterField(\n+                model_name=\"book\",\n+                name=\"title\",\n+                field=models.CharField(max_length=128, null=True, help_text=\"help\"),\n+            ),\n+            migrations.AlterField(\n+                model_name=\"book\",\n+                name=\"title\",\n+                field=models.CharField(max_length=128, null=True, help_text=\"help\", default=None),\n+            ),\n+        ]\n+        # The optimizer should reduce these to just the last AlterField operation\n+        self.assertOptimizesTo(\n+            operations,\n+            [\n+                migrations.AlterField(\n+                    model_name=\"book\",\n+                    name=\"title\",\n+                    field=models.CharField(max_length=128, null=True, help_text=\"help\", default=None),\n+                ),\n+            ],\n+        )\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13447",
        "model_patch": "diff --git a/tests/admin_views/test_adminsite.py b/tests/admin_views/test_adminsite.py\nindex efee6f39c6..2edb3da392 100644\n--- a/tests/admin_views/test_adminsite.py\n+++ b/tests/admin_views/test_adminsite.py\n@@ -75,6 +75,26 @@ class SiteEachContextTest(TestCase):\n         self.assertEqual(user['add_url'], '/test_admin/admin/auth/user/add/')\n         self.assertEqual(user['name'], 'Users')\n \n+    def test_model_class_in_app_list(self):\n+        \"\"\"Test that the model class is included in the app_list context.\"\"\"\n+        ctx = self.ctx\n+        apps = ctx['available_apps']\n+        # Check that we have apps in the context\n+        self.assertTrue(apps)\n+        # Get the first app and its first model\n+        app = apps[0]\n+        model_dict = app['models'][0]\n+        # Check that the model_class key exists and points to the actual model class\n+        self.assertIn('model', model_dict)\n+        # For admin_views.Article app, verify the model class is correct\n+        if app['app_label'] == 'admin_views':\n+            self.assertEqual(model_dict['model'], Article)\n+        # For auth.User app, verify the model class is correct\n+        elif app['app_label'] == 'auth':\n+            self.assertEqual(model_dict['model'], User)\n+    \n+\n+\n \n class SiteActionsTests(SimpleTestCase):\n     def setUp(self):\n@@ -99,3 +119,4 @@ class SiteActionsTests(SimpleTestCase):\n         self.assertEqual(self.site.get_action(action_name), delete_selected)\n         self.site.disable_action(action_name)\n         self.assertEqual(self.site.get_action(action_name), delete_selected)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pydata__xarray-3364",
        "model_patch": "diff --git a/xarray/tests/test_concat.py b/xarray/tests/test_concat.py\nindex c7af0fc9..00fc5ea5 100644\n--- a/xarray/tests/test_concat.py\n+++ b/xarray/tests/test_concat.py\n@@ -451,3 +451,31 @@ class TestConcatDataArray:\n         for join in expected:\n             actual = concat([ds1, ds2], join=join, dim=\"x\")\n             assert_equal(actual, expected[join].to_array())\n+\n+    def test_concat_different_variables(self):\n+        # Create datasets with different variables\n+        ds1 = Dataset({\"a\": (\"x\", [1, 2]), \"b\": (\"x\", [1, 2])})\n+        ds2 = Dataset({\"a\": (\"x\", [3, 4]), \"c\": (\"x\", [3, 4])})\n+        # This should work with the new behavior - concatenating datasets with different variables\n+        expected = Dataset(\n+            {\n+                \"a\": (\"x\", [1, 2, 3, 4]),\n+                \"b\": (\"x\", [1, 2, np.nan, np.nan]),\n+                \"c\": (\"x\", [np.nan, np.nan, 3, 4]),\n+            }\n+        )\n+        actual = concat([ds1, ds2], dim=\"x\")\n+        assert_equal(actual, expected)\n+        # Test with fill_value parameter\n+        expected_filled = Dataset(\n+            {\n+                \"a\": (\"x\", [1, 2, 3, 4]),\n+                \"b\": (\"x\", [1, 2, -1, -1]),\n+                \"c\": (\"x\", [-1, -1, 3, 4]),\n+            }\n+        )\n+        actual_filled = concat([ds1, ds2], dim=\"x\", fill_value=-1)\n+        assert_equal(actual_filled, expected_filled)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-21171",
        "model_patch": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 84227a1785..611672a62b 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -214,6 +214,20 @@ def test_latex_SingularityFunction():\n     assert latex(SingularityFunction(x, 4, -1)) == \\\n         r\"{\\left\\langle x - 4 \\right\\rangle}^{-1}\"\n \n+def test_latex_SingularityFunction_with_exp():\n+    # Test that SingularityFunction works when it's inside a Pow expression\n+    # This would trigger the exp keyword argument in _print_SingularityFunction\n+    expr = SingularityFunction(x, 4, 5)**2\n+    assert latex(expr) == r\"{\\left\\langle x - 4 \\right\\rangle}^{10}\"\n+    # Test with a symbolic exponent\n+    y = Symbol('y')\n+    expr = SingularityFunction(x, 4, 5)**y\n+    assert latex(expr) == r\"{\\left({\\left\\langle x - 4 \\right\\rangle}^{5}\\right)}^{y}\"\n+    # Test with a negative exponent\n+    expr = SingularityFunction(x, 4, 5)**(-1)\n+    assert latex(expr) == r\"{\\left\\langle x - 4 \\right\\rangle}^{-5}\"\n+\n+\n \n def test_latex_cycle():\n     assert latex(Cycle(1, 2, 4)) == r\"\\left( 1\\; 2\\; 4\\right)\"\n@@ -2704,3 +2718,4 @@ def test_pickleable():\n def test_printing_latex_array_expressions():\n     assert latex(ArraySymbol(\"A\", 2, 3, 4)) == \"A\"\n     assert latex(ArrayElement(\"A\", (2, 1/(1-x), 0))) == \"{{A}_{2, \\\\frac{1}{1 - x}, 0}}\"\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-23987",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_figure.py b/lib/matplotlib/tests/test_figure.py\nindex 48b4a880e0..6e27397bbb 100644\n--- a/lib/matplotlib/tests/test_figure.py\n+++ b/lib/matplotlib/tests/test_figure.py\n@@ -1380,6 +1380,18 @@ def test_rcparams(fig_test, fig_ref):\n         fig_test.supylabel(\"ylabel\")\n         fig_test.suptitle(\"Title\")\n \n+def test_constrained_layout_warning():\n+    \"\"\"Test that no warning is emitted when constrained_layout=False and subplots_adjust is used.\"\"\"\n+    fig, ax = plt.subplots(1, 2, constrained_layout=False)\n+    # Capture warnings during subplots_adjust call\n+    with warnings.catch_warnings(record=True) as w:\n+        warnings.simplefilter(\"always\")\n+        fig.subplots_adjust(wspace=0)\n+        # Check that no warning about incompatible layout engine was emitted\n+        for warning in w:\n+            assert \"layout engine that is incompatible with subplots_adjust\" not in str(warning.message)\n+\n+\n \n def test_deepcopy():\n     fig1, ax = plt.subplots()\n@@ -1412,3 +1424,4 @@ def test_unpickle_with_device_pixel_ratio():\n     assert fig.dpi == 42*7\n     fig2 = pickle.loads(pickle.dumps(fig))\n     assert fig2.dpi == 42\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13925",
        "model_patch": "diff --git a/tests/check_framework/test_model_checks.py b/tests/check_framework/test_model_checks.py\nindex d4342ada07..332a282e87 100644\n--- a/tests/check_framework/test_model_checks.py\n+++ b/tests/check_framework/test_model_checks.py\n@@ -415,3 +415,25 @@ class ModelDefaultAutoFieldTests(SimpleTestCase):\n                 app_label = 'check_framework.apps.CheckPKConfig'\n \n         self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n+\n+    @isolate_apps('model_checks')\n+    def test_inherited_pk_no_warning(self):\n+        \"\"\"\n+        No warning about auto-created primary key if the model inherits a\n+        manually-specified primary key.\n+        \"\"\"\n+        class Parent(models.Model):\n+            id = models.AutoField(primary_key=True)\n+        class Child(Parent):\n+            pass\n+        with mock.patch('django.core.checks.model_checks.Warning') as warning_mock:\n+            errors = checks.run_checks(app_configs=None)\n+            # No warning should be raised for Child model\n+            warning_calls = [\n+                call for call in warning_mock.call_args_list\n+                if call[0][0].startswith('Auto-created primary key used') and 'Child' in call[0][1]\n+            ]\n+            self.assertEqual(len(warning_calls), 0)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14787",
        "model_patch": "diff --git a/tests/decorators/tests.py b/tests/decorators/tests.py\nindex 46b01c1852..5da7688ec7 100644\n--- a/tests/decorators/tests.py\n+++ b/tests/decorators/tests.py\n@@ -393,6 +393,31 @@ class MethodDecoratorTests(SimpleTestCase):\n         self.assertEqual(TestFirst().method(), \"hello world?!\")\n         self.assertEqual(TestSecond().method(), \"hello world?!\")\n \n+    def test_preserve_wrapper_assignments(self):\n+        \"\"\"\n+        Test that method_decorator preserves wrapper assignments\n+        when the decorator uses @wraps.\n+        \"\"\"\n+        def logger(func):\n+            @wraps(func)\n+            def inner(*args, **kwargs):\n+                return func(*args, **kwargs)\n+            # Add an attribute to the wrapper function\n+            inner.debug = lambda msg: None\n+            return inner\n+        class Test:\n+            @method_decorator(logger)\n+            def hello_world(self):\n+                return \"hello\"\n+        # This should not raise AttributeError\n+        instance = Test()\n+        result = instance.hello_world()\n+        self.assertEqual(result, \"hello\")\n+        # The wrapper attribute should be preserved\n+        self.assertTrue(hasattr(instance.hello_world, 'debug'))\n+    \n+\n+\n     def test_invalid_non_callable_attribute_decoration(self):\n         \"\"\"\n         @method_decorator on a non-callable attribute raises an error.\n@@ -507,3 +532,4 @@ class CacheControlDecoratorTest(SimpleTestCase):\n         )\n         with self.assertRaisesMessage(TypeError, msg):\n             MyClass().a_view(HttpRequest())\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-16527",
        "model_patch": "diff --git a/tests/admin_views/test_templatetags.py b/tests/admin_views/test_templatetags.py\nindex a13133095b..ea82617de6 100644\n--- a/tests/admin_views/test_templatetags.py\n+++ b/tests/admin_views/test_templatetags.py\n@@ -54,6 +54,40 @@ class AdminTemplateTagsTest(AdminViewBasicTestCase):\n                     template_context[\"show_save_and_add_another\"], expected_flag\n                 )\n \n+    def test_submit_row_save_as_new_permissions(self):\n+        \"\"\"\n+        The \"Save as new\" button should respect the user's add permission.\n+        \"\"\"\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk])\n+        )\n+        request.user = self.superuser\n+        admin = UserAdmin(User, site)\n+        # Create a context where the user has change permission but not add permission\n+        context = {\n+            \"add\": False,\n+            \"change\": True,\n+            \"is_popup\": False,\n+            \"save_as\": True,\n+            \"has_add_permission\": False,\n+            \"has_change_permission\": True,\n+            \"has_view_permission\": True,\n+            \"has_delete_permission\": True,\n+            \"has_editable_inline_admin_formsets\": False,\n+            \"show_save\": True,\n+            \"show_save_and_add_another\": True,\n+            \"show_save_and_continue\": True,\n+        }\n+        template_context = submit_row(context)\n+        # The \"Save as new\" button should not be shown when the user doesn't have add permission\n+        self.assertFalse(template_context[\"show_save_as_new\"])\n+        # Now test with add permission\n+        context[\"has_add_permission\"] = True\n+        template_context = submit_row(context)\n+        self.assertTrue(template_context[\"show_save_as_new\"])\n+    \n+\n+\n     def test_override_change_form_template_tags(self):\n         \"\"\"\n         admin_modify template tags follow the standard search pattern\n@@ -199,3 +233,4 @@ class DateHierarchyTests(TestCase):\n                     for choice in expected_choices\n                 ]\n                 self.assertEqual(choices, expected_choices)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sphinx-doc__sphinx-10325",
        "model_patch": "diff --git a/tests/test_ext_autodoc_autoclass.py b/tests/test_ext_autodoc_autoclass.py\nindex 02e6d4990..0f24193cd 100644\n--- a/tests/test_ext_autodoc_autoclass.py\n+++ b/tests/test_ext_autodoc_autoclass.py\n@@ -454,3 +454,87 @@ def test_coroutine(app):\n         '      A documented coroutine staticmethod',\n         '',\n     ]\n+\n+def test_inherited_members_multiple_classes(app):\n+    # Test that inherited-members can accept a list of classes\n+    options = {'members': None,\n+               'inherited-members': ['object', 'Base1']}\n+    actual = do_autodoc(app, 'class', 'target.multiple_inheritance.Child', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Child()',\n+        '   :module: target.multiple_inheritance',\n+        '',\n+        '',\n+        '   .. py:attribute:: Child.attr1',\n+        '      :module: target.multiple_inheritance',\n+        '',\n+        '      Attribute from Base1',\n+        '',\n+        '',\n+        '   .. py:method:: Child.meth1()',\n+        '      :module: target.multiple_inheritance',\n+        '',\n+        '      Method from Base1',\n+        '',\n+        '',\n+        '   .. py:attribute:: Child.attr3',\n+        '      :module: target.multiple_inheritance',\n+        '',\n+        '      Attribute from Base3',\n+        '',\n+        '',\n+        '   .. py:method:: Child.meth3()',\n+        '      :module: target.multiple_inheritance',\n+        '',\n+        '      Method from Base3',\n+        '',\n+    ]\n+    # Test with a single class name as string (existing behavior)\n+    options = {'members': None,\n+               'inherited-members': 'Base1'}\n+    actual = do_autodoc(app, 'class', 'target.multiple_inheritance.Child', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Child()',\n+        '   :module: target.multiple_inheritance',\n+        '',\n+        '',\n+        '   .. py:attribute:: Child.attr1',\n+        '      :module: target.multiple_inheritance',\n+        '',\n+        '      Attribute from Base1',\n+        '',\n+        '',\n+        '   .. py:method:: Child.meth1()',\n+        '      :module: target.multiple_inheritance',\n+        '',\n+        '      Method from Base1',\n+        '',\n+        '',\n+        '   .. py:attribute:: Child.attr2',\n+        '      :module: target.multiple_inheritance',\n+        '',\n+        '      Attribute from Base2',\n+        '',\n+        '',\n+        '   .. py:method:: Child.meth2()',\n+        '      :module: target.multiple_inheritance',\n+        '',\n+        '      Method from Base2',\n+        '',\n+        '',\n+        '   .. py:attribute:: Child.attr3',\n+        '      :module: target.multiple_inheritance',\n+        '',\n+        '      Attribute from Base3',\n+        '',\n+        '',\n+        '   .. py:method:: Child.meth3()',\n+        '      :module: target.multiple_inheritance',\n+        '',\n+        '      Method from Base3',\n+        '',\n+    ]\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15738",
        "model_patch": "diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex 547e0b32c5..8dfbccf933 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -3787,6 +3787,62 @@ class AutodetectorTests(TestCase):\n             changes, \"testapp\", 0, 2, name=\"publishers\", model_name=\"author\"\n         )\n \n+    def test_fk_with_unique_together_to_many_to_many(self):\n+        \"\"\"\n+        Test that changing a ForeignKey field with unique_together constraint\n+        to a ManyToManyField properly removes the unique_together constraint.\n+        \"\"\"\n+        # Define models with ForeignKey and unique_together\n+        class AuthorWithFK(models.Model):\n+            project_data_set = models.ForeignKey(\"ProjectDataSet\", on_delete=models.PROTECT)\n+            state = models.IntegerField()\n+            start_date = models.DateField()\n+            class Meta:\n+                app_label = \"testapp\"\n+                unique_together = ((\"project_data_set\", \"state\", \"start_date\"),)\n+        class DataSet(models.Model):\n+            name = models.TextField(max_length=50)\n+            class Meta:\n+                app_label = \"testapp\"\n+        class Project(models.Model):\n+            data_sets = models.ManyToManyField(DataSet, through=\"ProjectDataSet\")\n+            name = models.TextField(max_length=50)\n+            class Meta:\n+                app_label = \"testapp\"\n+        class ProjectDataSet(models.Model):\n+            data_set = models.ForeignKey(DataSet, on_delete=models.PROTECT)\n+            project = models.ForeignKey(Project, on_delete=models.PROTECT)\n+            class Meta:\n+                app_label = \"testapp\"\n+                unique_together = ((\"data_set\", \"project\"),)\n+        # Define the same models but with ManyToManyField instead of ForeignKey\n+        class AuthorWithM2M(models.Model):\n+            project_data_set = models.ManyToManyField(\"ProjectDataSet\")\n+            state = models.IntegerField()\n+            start_date = models.DateField()\n+            class Meta:\n+                app_label = \"testapp\"\n+                # No unique_together here as it's not valid for M2M fields\n+        # Get the changes\n+        changes = self.get_changes(\n+            [AuthorWithFK, DataSet, Project, ProjectDataSet],\n+            [AuthorWithM2M, DataSet, Project, ProjectDataSet]\n+        )\n+        # Verify the changes\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(\n+            changes, \"testapp\", 0, [\"RemoveField\", \"AlterUniqueTogether\", \"AddField\"]\n+        )\n+        # Check that AlterUniqueTogether is removing the constraint\n+        self.assertOperationAttributes(\n+            changes, \"testapp\", 0, 1, name=\"unique_together\", model_name=\"authorwithfk\"\n+        )\n+        # Verify the unique_together is being set to an empty tuple\n+        unique_together_op = changes[\"testapp\"][0].operations[1]\n+        self.assertEqual(unique_together_op.unique_together, set())\n+    \n+\n+\n     def test_many_to_many_changed_to_concrete_field(self):\n         \"\"\"\n         #23938 - Changing a ManyToManyField into a concrete field\n@@ -4778,3 +4834,4 @@ class MigrationSuggestNameTests(SimpleTestCase):\n         migration = migrations.Migration(\"0001_initial\", \"test_app\")\n         suggest_name = migration.suggest_name()\n         self.assertIs(suggest_name.startswith(\"auto_\"), True)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-14087",
        "model_patch": "diff --git a/sklearn/linear_model/tests/test_logistic.py b/sklearn/linear_model/tests/test_logistic.py\nindex 6ad9a4ec99..c911421a20 100644\n--- a/sklearn/linear_model/tests/test_logistic.py\n+++ b/sklearn/linear_model/tests/test_logistic.py\n@@ -1533,25 +1533,36 @@ def test_LogisticRegressionCV_GridSearchCV_elastic_net_ovr():\n \n \n @pytest.mark.parametrize('multi_class', ('ovr', 'multinomial'))\n-def test_LogisticRegressionCV_no_refit(multi_class):\n-    # Test LogisticRegressionCV attribute shapes when refit is False\n \n-    n_classes = 3\n-    n_features = 20\n-    X, y = make_classification(n_samples=200, n_classes=n_classes,\n-                               n_informative=n_classes, n_features=n_features,\n-                               random_state=0)\n-\n-    Cs = np.logspace(-4, 4, 3)\n-    l1_ratios = np.linspace(0, 1, 2)\n-\n-    lrcv = LogisticRegressionCV(penalty='elasticnet', Cs=Cs, solver='saga',\n-                                l1_ratios=l1_ratios, random_state=0,\n-                                multi_class=multi_class, refit=False)\n+@pytest.mark.parametrize(\"solver\", [\"saga\", \"liblinear\"])\n+def test_LogisticRegressionCV_no_refit(solver):\n+    # Test LogisticRegressionCV with refit=False doesn't raise IndexError\n+    # This test specifically addresses the issue where an IndexError is thrown\n+    # when using LogisticRegressionCV with refit=False\n+    # Create a simple binary classification problem\n+    np.random.seed(29)\n+    X = np.random.normal(size=(1000, 3))\n+    beta = np.random.normal(size=3)\n+    intercept = np.random.normal(size=None)\n+    y = np.sign(intercept + X @ beta)\n+    # Test with refit=False\n+    lrcv = LogisticRegressionCV(\n+        cv=5,\n+        solver=solver,\n+        tol=1e-2,\n+        refit=False\n+    )\n+    # This should not raise an IndexError\n     lrcv.fit(X, y)\n-    assert lrcv.C_.shape == (n_classes,)\n-    assert lrcv.l1_ratio_.shape == (n_classes,)\n-    assert lrcv.coef_.shape == (n_classes, n_features)\n+    # Verify that the model has the expected attributes\n+    assert hasattr(lrcv, 'coef_')\n+    assert hasattr(lrcv, 'intercept_')\n+    assert hasattr(lrcv, 'C_')\n+    # For binary classification\n+    assert lrcv.coef_.shape == (1, X.shape[1])\n+    assert lrcv.intercept_.shape == (1,)\n+    assert np.isscalar(lrcv.C_) or lrcv.C_.shape == (1,)\n+\n \n \n def test_LogisticRegressionCV_elasticnet_attribute_shapes():\n@@ -1738,3 +1749,4 @@ def test_penalty_none(solver):\n         \"LogisticRegressionCV\",\n         lr.fit, X, y\n     )\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12700",
        "model_patch": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 8c64bc343e..63e8aa3554 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -1249,6 +1249,52 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             {'login': 'cooper', 'password': reporter_filter.cleansed_substitute},\n         )\n \n+    def test_cleanse_setting_recurses_in_iterables(self):\n+        \"\"\"\n+        The cleanse_setting method should cleanse sensitive data in iterables\n+        like lists and tuples, not just dictionaries.\n+        \"\"\"\n+        filter_ = get_default_exception_reporter_filter()\n+        nested_iterables = {\n+            'secret': 'super_secret',\n+            'list_data': [\n+                {'secret': 'nested_secret_1'},\n+                {'other': 'not_secret'},\n+                {'secret': 'nested_secret_2'},\n+            ],\n+            'tuple_data': (\n+                {'secret': 'nested_secret_3'},\n+                {'other': 'not_secret'},\n+            ),\n+            'nested_iterables': [\n+                [\n+                    {'secret': 'deeply_nested_secret'},\n+                    {'other': 'not_secret'},\n+                ],\n+                (\n+                    {'secret': 'deeply_nested_secret_2'},\n+                    {'other': 'not_secret'},\n+                ),\n+            ],\n+        }\n+        cleansed = filter_.cleanse_setting('TEST', nested_iterables)\n+        # Check that the top-level secret is cleansed\n+        self.assertEqual(cleansed['secret'], filter_.cleansed_substitute)\n+        # Check that secrets in lists are cleansed\n+        self.assertEqual(cleansed['list_data'][0]['secret'], filter_.cleansed_substitute)\n+        self.assertEqual(cleansed['list_data'][1]['other'], 'not_secret')\n+        self.assertEqual(cleansed['list_data'][2]['secret'], filter_.cleansed_substitute)\n+        # Check that secrets in tuples are cleansed\n+        self.assertEqual(cleansed['tuple_data'][0]['secret'], filter_.cleansed_substitute)\n+        self.assertEqual(cleansed['tuple_data'][1]['other'], 'not_secret')\n+        # Check that deeply nested secrets are cleansed\n+        self.assertEqual(cleansed['nested_iterables'][0][0]['secret'], filter_.cleansed_substitute)\n+        self.assertEqual(cleansed['nested_iterables'][0][1]['other'], 'not_secret')\n+        self.assertEqual(cleansed['nested_iterables'][1][0]['secret'], filter_.cleansed_substitute)\n+        self.assertEqual(cleansed['nested_iterables'][1][1]['other'], 'not_secret')\n+    \n+\n+\n     def test_request_meta_filtering(self):\n         request = self.rf.get('/', HTTP_SECRET_HEADER='super_secret')\n         reporter_filter = SafeExceptionReporterFilter()\n@@ -1388,3 +1434,4 @@ class DecoratorsTests(SimpleTestCase):\n             @sensitive_post_parameters\n             def test_func(request):\n                 return index_page(request)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11099",
        "model_patch": "diff --git a/tests/auth_tests/test_validators.py b/tests/auth_tests/test_validators.py\nindex 1c2c6b4aff..a401cfa471 100644\n--- a/tests/auth_tests/test_validators.py\n+++ b/tests/auth_tests/test_validators.py\n@@ -248,9 +248,10 @@ class UsernameValidatorsTests(SimpleTestCase):\n                 with self.assertRaises(ValidationError):\n                     v(invalid)\n \n+\n     def test_ascii_validator(self):\n         valid_usernames = ['glenn', 'GLEnN', 'jean-marc']\n-        invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\"]\n+        invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\", \"username\\n\"]\n         v = validators.ASCIIUsernameValidator()\n         for valid in valid_usernames:\n             with self.subTest(valid=valid):\n@@ -259,3 +260,6 @@ class UsernameValidatorsTests(SimpleTestCase):\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n                     v(invalid)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pydata__xarray-4248",
        "model_patch": "diff --git a/xarray/tests/test_formatting.py b/xarray/tests/test_formatting.py\nindex 82de8080..91e4cd5e 100644\n--- a/xarray/tests/test_formatting.py\n+++ b/xarray/tests/test_formatting.py\n@@ -421,3 +421,30 @@ def test_large_array_repr_length():\n \n     result = repr(da).splitlines()\n     assert len(result) < 50\n+\n+def test_dataset_repr_with_units():\n+    # Create a dataset with units in attributes\n+    ds = xr.Dataset(\n+        data_vars={\n+            \"rainfall\": ((\"time\", \"y\", \"x\"), np.random.rand(3, 2, 2), {\"units\": \"mm\"}),\n+            \"max_temp\": ((\"time\", \"y\", \"x\"), np.random.rand(3, 2, 2), {\"units\": \"deg C\"}),\n+        },\n+        coords={\n+            \"x\": (\"x\", [1, 2], {\"units\": \"metres\"}),\n+            \"y\": (\"y\", [1, 2], {\"units\": \"metres\"}),\n+            \"time\": pd.date_range(\"2000-01-01\", periods=3),\n+        },\n+    )\n+    # Get the string representation of the dataset\n+    repr_str = repr(ds)\n+    # Check if units are displayed in the representation\n+    expected_patterns = [\n+        \"* x, in metres\",\n+        \"* y, in metres\",\n+        \"rainfall, in mm\",\n+        \"max_temp, in deg C\"\n+    ]\n+    for pattern in expected_patterns:\n+        assert pattern in repr_str, f\"Expected '{pattern}' to be in dataset representation\"\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-23964",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_backend_ps.py b/lib/matplotlib/tests/test_backend_ps.py\nindex fc2556a47d..6d4701931a 100644\n--- a/lib/matplotlib/tests/test_backend_ps.py\n+++ b/lib/matplotlib/tests/test_backend_ps.py\n@@ -318,3 +318,19 @@ def test_path_collection():\n                                      facecolors='yellow', offsets=offsets)\n     ax.add_collection(pc)\n     ax.set_xlim(0, 1)\n+\n+@needs_ghostscript\n+def test_empty_line_text():\n+    \"\"\"Test that text with empty lines doesn't cause TypeError in PS backend.\"\"\"\n+    fig = Figure()\n+    ax = fig.add_subplot(111)\n+    # Test with annotation containing an empty line\n+    ax.annotate(text='\\nLower label', xy=(0, 0))\n+    # Test with title containing an empty line\n+    ax.set_title('\\nLower title')\n+    # Use BytesIO to avoid creating actual files\n+    with io.BytesIO() as buf:\n+        # This should not raise TypeError\n+        fig.savefig(buf, format='ps')\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sphinx-doc__sphinx-8595",
        "model_patch": "diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex 39897eb7d..6b5a08215 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -737,6 +737,37 @@ def test_autodoc_ignore_module_all(app):\n         '.. py:class:: StrRepr'\n     ]\n \n+def test_autodoc_empty_all(app):\n+    \"\"\"Test that empty __all__ attribute is respected.\"\"\"\n+    # Create a temporary module with empty __all__\n+    module_content = \"\"\"\n+__all__ = []\n+def foo():\n+    \"docstring\"\n+def bar():\n+    \"docstring\"\n+def baz():\n+    \"docstring\"\n+\"\"\"\n+    with open(app.srcdir / 'empty_all.py', 'w') as f:\n+        f.write(module_content)\n+    # Test with default behavior (should respect empty __all__)\n+    options = {\"members\": None}\n+    actual = do_autodoc(app, 'module', 'empty_all', options)\n+    # No members should be documented when __all__ is empty\n+    assert '.. py:function::' not in '\\n'.join(actual)\n+    assert 'foo' not in '\\n'.join(actual)\n+    assert 'bar' not in '\\n'.join(actual)\n+    assert 'baz' not in '\\n'.join(actual)\n+    # Test with ignore-module-all option\n+    options = {\"members\": None, \"ignore-module-all\": None}\n+    actual = do_autodoc(app, 'module', 'empty_all', options)\n+    # With ignore-module-all, all members should be documented\n+    assert '.. py:function:: foo()' in actual\n+    assert '.. py:function:: bar()' in actual\n+    assert '.. py:function:: baz()' in actual\n+\n+\n \n @pytest.mark.sphinx('html', testroot='ext-autodoc')\n def test_autodoc_noindex(app):\n@@ -2281,3 +2312,4 @@ def test_hide_value(app):\n         '   :meta hide-value:',\n         '',\n     ]\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-24066",
        "model_patch": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 25a68c7be5..4e3474f1db 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -376,6 +376,22 @@ def test_factor_and_dimension():\n     with warns_deprecated_sympy():\n         assert (3000, Dimension(1)) == Quantity._collect_factor_and_dimension(3000)\n \n+def test_dimensionless_exponent():\n+    from sympy.physics.units import second, ohm, farad\n+    from sympy.physics.units.systems import SI\n+    # Test case from the issue description\n+    expr = second / (ohm * farad)\n+    dim = SI._collect_factor_and_dimension(expr)[1]\n+    # Verify that the dimension is correctly identified as dimensionless\n+    assert SI.get_dimension_system().is_dimensionless(dim)\n+    # This should not raise an error\n+    buggy_expr = 100 + exp(expr)\n+    factor, dimension = SI._collect_factor_and_dimension(buggy_expr)\n+    # The dimension of the expression should be dimensionless\n+    assert dimension == Dimension(1)\n+    assert SI.get_dimension_system().is_dimensionless(dimension)\n+\n+\n \n @XFAIL\n def test_factor_and_dimension_with_Abs():\n@@ -570,3 +586,4 @@ def test_physics_constant():\n \n     assert not meter.is_physical_constant\n     assert not joule.is_physical_constant\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13265",
        "model_patch": "diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex 236af43834..a775a03709 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -2125,6 +2125,70 @@ class AutodetectorTests(TestCase):\n         self.assertOperationAttributes(changes, 'testapp', 0, 0, model_name=\"author\", name=\"book\")\n         self.assertOperationAttributes(changes, 'testapp', 0, 1, name=\"author\", order_with_respect_to=\"book\")\n \n+    def test_alter_order_with_respect_to_with_index(self):\n+        \"\"\"\n+        Test that AlterOrderWithRespectTo properly handles the case when\n+        _order is included in an Index.\n+        \"\"\"\n+        # Define models\n+        author_name = ModelState(\n+            \"testapp\", \"author\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"name\", models.CharField(max_length=200)),\n+            ],\n+        )\n+        book = ModelState(\n+            \"testapp\", \"book\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"title\", models.CharField(max_length=200)),\n+            ],\n+        )\n+        # Author with book foreign key and order_with_respect_to\n+        author_with_book_order_wrt_and_index = ModelState(\n+            \"testapp\", \"author\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"name\", models.CharField(max_length=200)),\n+                (\"book\", models.ForeignKey(\"testapp.Book\", models.CASCADE)),\n+            ],\n+            {\n+                \"order_with_respect_to\": \"book\",\n+                \"indexes\": [\n+                    models.Index(fields=[\"book\", \"_order\"]),\n+                ],\n+            },\n+        )\n+        # Get the changes\n+        changes = self.get_changes([author_name, book], [book, author_with_book_order_wrt_and_index])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        # Check that operations are in the correct order:\n+        # AddField, AlterOrderWithRespectTo, AddIndex\n+        self.assertOperationTypes(\n+            changes, \"testapp\", 0, \n+            [\"AddField\", \"AlterOrderWithRespectTo\", \"AddIndex\"]\n+        )\n+        # Check the details of each operation\n+        self.assertOperationAttributes(\n+            changes, \"testapp\", 0, 0, \n+            model_name=\"author\", name=\"book\"\n+        )\n+        self.assertOperationAttributes(\n+            changes, \"testapp\", 0, 1, \n+            name=\"author\", order_with_respect_to=\"book\"\n+        )\n+        self.assertOperationAttributes(\n+            changes, \"testapp\", 0, 2, \n+            model_name=\"author\"\n+        )\n+        # Verify the index contains the _order field\n+        index_operation = changes[\"testapp\"][0].operations[2]\n+        self.assertEqual(index_operation.index.fields, [\"book\", \"_order\"])\n+    \n+\n+\n     def test_remove_alter_order_with_respect_to(self):\n         \"\"\"\n         Removing order_with_respect_to when removing the FK too does\n@@ -2556,3 +2620,4 @@ class MigrationSuggestNameTests(SimpleTestCase):\n         migration = migrations.Migration('0001_initial', 'test_app')\n         suggest_name = migration.suggest_name()\n         self.assertIs(suggest_name.startswith('auto_'), True)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-14092",
        "model_patch": "diff --git a/sklearn/neighbors/tests/test_nca.py b/sklearn/neighbors/tests/test_nca.py\nindex 2397af5bc0..d9e9f60c60 100644\n--- a/sklearn/neighbors/tests/test_nca.py\n+++ b/sklearn/neighbors/tests/test_nca.py\n@@ -511,6 +511,29 @@ def test_expected_transformation_shape():\n     nca.fit(X, y)\n     assert_equal(transformation_storer.transformation.size, X.shape[1]**2)\n \n+def test_nca_gridsearch_compatibility():\n+    \"\"\"Test that NCA works in GridSearchCV with different numeric types.\"\"\"\n+    from sklearn.pipeline import Pipeline\n+    from sklearn.model_selection import GridSearchCV\n+    from classification import KNeighborsClassifier\n+    # Create a simple dataset\n+    X = np.random.random_sample((30, 5))\n+    y = np.random.randint(2, size=30)\n+    # Create a pipeline with NCA and KNN\n+    nca = NeighborhoodComponentsAnalysis()\n+    knn = KNeighborsClassifier()\n+    pipe = Pipeline([('nca', nca), ('knn', knn)])\n+    # Create a parameter grid with numpy numeric types\n+    # This should test both the int and float parameter validation\n+    params = {\n+        'nca__tol': [0.1, 0.5, np.float64(1.0)],  # np.float64 instead of float\n+        'nca__n_components': [2, np.int64(3)]     # np.int64 instead of int\n+    }\n+    # This should not raise TypeError about parameter types\n+    gs = GridSearchCV(estimator=pipe, param_grid=params, cv=2)\n+    gs.fit(X, y)\n+\n+\n \n def test_convergence_warning():\n     nca = NeighborhoodComponentsAnalysis(max_iter=2, verbose=1)\n@@ -518,3 +541,4 @@ def test_convergence_warning():\n     assert_warns_message(ConvergenceWarning,\n                          '[{}] NCA did not converge'.format(cls_name),\n                          nca.fit, iris_data, iris_target)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pydata__xarray-4094",
        "model_patch": "diff --git a/xarray/tests/test_dataset.py b/xarray/tests/test_dataset.py\nindex 9c8d4072..8486b2cb 100644\n--- a/xarray/tests/test_dataset.py\n+++ b/xarray/tests/test_dataset.py\n@@ -3055,6 +3055,22 @@ class TestDataset:\n         x = y.to_unstacked_dataset(\"features\")\n         assert_identical(D, x)\n \n+    def test_to_unstacked_dataset_single_dim(self):\n+        # Create a simple dataset with single-dimension variables\n+        arr = xr.DataArray(\n+            np.arange(3),\n+            coords=[(\"x\", [0, 1, 2])],\n+        )\n+        data = xr.Dataset({\"a\": arr, \"b\": arr})\n+        # Stack the dataset into an array\n+        stacked = data.to_stacked_array('y', sample_dims=['x'])\n+        # Unstack the array back to a dataset - this should work without errors\n+        unstacked = stacked.to_unstacked_dataset('y')\n+        # Verify the roundtrip works correctly\n+        assert_identical(data, unstacked)\n+    \n+\n+\n     def test_update(self):\n         data = create_test_data(seed=0)\n         expected = data.copy()\n@@ -6219,3 +6235,4 @@ def test_weakref():\n     ds = Dataset()\n     r = ref(ds)\n     assert r() is ds\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-25638",
        "model_patch": "diff --git a/sklearn/utils/tests/test_multiclass.py b/sklearn/utils/tests/test_multiclass.py\nindex cf5858d0f5..c98a9cf66e 100644\n--- a/sklearn/utils/tests/test_multiclass.py\n+++ b/sklearn/utils/tests/test_multiclass.py\n@@ -252,6 +252,17 @@ def test_unique_labels_mixed_types():\n     with pytest.raises(ValueError):\n         unique_labels([[\"1\", \"2\"], [2, 3]])\n \n+def test_unique_labels_pandas_nullable_dtypes():\n+    \"\"\"Test that unique_labels works with pandas nullable dtypes.\"\"\"\n+    pd = pytest.importorskip(\"pandas\")\n+    for dtype in [\"Int64\", \"Float64\", \"boolean\"]:\n+        y_true = pd.Series([1, 0, 0, 1, 0, 1, 1, 0, 1], dtype=dtype)\n+        y_predicted = pd.Series([0, 0, 1, 1, 0, 1, 1, 1, 1], dtype=\"int64\")\n+        # This should not raise an error\n+        with pytest.raises(ValueError, match=\"Mix type of y not allowed, got types\"):\n+            unique_labels(y_true, y_predicted)\n+\n+\n \n def test_is_multilabel():\n     for group, group_examples in EXAMPLES.items():\n@@ -456,3 +467,4 @@ def test_ovr_decision_function():\n     ]\n \n     assert_allclose(dec_values, dec_values_one, atol=1e-6)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15388",
        "model_patch": "diff --git a/tests/template_tests/test_autoreloader.py b/tests/template_tests/test_autoreloader.py\nindex d6ece4cc6d..fe2115ea66 100644\n--- a/tests/template_tests/test_autoreloader.py\n+++ b/tests/template_tests/test_autoreloader.py\n@@ -84,6 +84,26 @@ class TemplateReloadTests(SimpleTestCase):\n             }\n         )\n \n+    def test_pathlib_base_dir_in_template_dirs(self):\n+        \"\"\"\n+        Template directories containing Path objects like BASE_DIR are properly\n+        handled by get_template_directories().\n+        \"\"\"\n+        with override_settings(\n+            TEMPLATES=[\n+                {\n+                    'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+                    'DIRS': [Path('/path/to/templates')],\n+                    'APP_DIRS': True,\n+                    'OPTIONS': {},\n+                }\n+            ]\n+        ):\n+            directories = autoreload.get_template_directories()\n+            self.assertTrue(any(str(directory).endswith('/path/to/templates') for directory in directories))\n+    \n+\n+\n \n @require_jinja2\n @override_settings(INSTALLED_APPS=['template_tests'])\n@@ -110,3 +130,4 @@ class Jinja2TemplateReloadTests(SimpleTestCase):\n     def test_reset_all_loaders(self, mock_reset):\n         autoreload.reset_loaders()\n         self.assertEqual(mock_reset.call_count, 0)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "psf__requests-2317",
        "model_patch": "diff --git a/test_requests.py b/test_requests.py\nindex 467c5bc6..c9d1694d 100755\n--- a/test_requests.py\n+++ b/test_requests.py\n@@ -1516,5 +1516,32 @@ def test_prepare_unicode_url():\n     )\n     assert_copy(p, p.copy())\n \n+def test_binary_string_method(self):\n+    from io import BytesIO\n+    \"\"\"Test that binary string method is properly handled.\"\"\"\n+    # Create a session\n+    s = requests.Session()\n+    # Create a mock adapter to capture the request\n+    class MockAdapter(HTTPAdapter):\n+        def __init__(self):\n+            super(MockAdapter, self).__init__()\n+            self.last_request = None\n+        def send(self, request, **kwargs):\n+            self.last_request = request\n+            resp = requests.Response()\n+            resp.status_code = 200\n+            resp.raw = BytesIO(b'test data')\n+            return resp\n+    mock_adapter = MockAdapter()\n+    s.mount('http://', mock_adapter)\n+    # Test with binary string method\n+    binary_method = b'GET'\n+    s.request(method=binary_method, url='http://example.com')\n+    # Verify the method was properly converted and not wrapped with b''\n+    assert mock_adapter.last_request.method == 'GET'\n+    assert mock_adapter.last_request.method != \"b'GET'\"\n+\n+\n if __name__ == '__main__':\n     unittest.main()\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15790",
        "model_patch": "diff --git a/tests/check_framework/test_templates.py b/tests/check_framework/test_templates.py\nindex 352a017e55..6c1bd693f8 100644\n--- a/tests/check_framework/test_templates.py\n+++ b/tests/check_framework/test_templates.py\n@@ -207,3 +207,35 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n     )\n     def test_template_tags_with_different_name(self):\n         self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n+\n+    def test_template_tags_with_same_name_in_libraries(self):\n+        \"\"\"\n+        Test that the same template tag library path in multiple TEMPLATES\n+        configurations doesn't trigger an error.\n+        \"\"\"\n+        with self.settings(\n+            TEMPLATES=[\n+                {\n+                    \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n+                    \"OPTIONS\": {\n+                        \"libraries\": {\n+                            \"my_tags\": \"someapp.templatetags.my_tags\",\n+                        },\n+                    },\n+                },\n+                {\n+                    \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n+                    \"OPTIONS\": {\n+                        \"libraries\": {\n+                            \"my_tags\": \"someapp.templatetags.my_tags\",\n+                        },\n+                    },\n+                },\n+            ]\n+        ):\n+            # This should not report an error since it's the same library path\n+            # being used in different TEMPLATES configurations\n+            self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15851",
        "model_patch": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex 02924d0bcc..5b4f7e2701 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -151,11 +151,24 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n             ),\n         )\n \n+\n     def test_parameters(self):\n+        \"\"\"\n+        PostgreSQL's psql expects options to come before the database name.\n+        \"\"\"\n         self.assertEqual(\n             self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"--help\"]),\n-            ([\"psql\", \"dbname\", \"--help\"], None),\n+            ([\"psql\", \"--help\", \"dbname\"], None),\n         )\n+        # Test with multiple parameters\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env(\n+                {\"NAME\": \"dbname\"}, [\"-c\", \"SELECT version();\"]\n+            ),\n+            ([\"psql\", \"-c\", \"SELECT version();\", \"dbname\"], None),\n+        )\n+    \n+\n \n     @skipUnless(connection.vendor == \"postgresql\", \"Requires a PostgreSQL connection\")\n     def test_sigint_handler(self):\n@@ -184,3 +197,4 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         with self.assertRaises(subprocess.CalledProcessError) as ctx:\n             subprocess.run(args, check=True, env=env)\n         self.assertNotIn(\"somepassword\", str(ctx.exception))\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-18532",
        "model_patch": "diff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex 50f8f9ee7b..f6c48a6ad8 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -139,6 +139,27 @@ def test_subs_with_unicode_symbols():\n def test_atoms():\n     assert b21.atoms() == set()\n \n+def test_atoms_no_args():\n+    # Create a class that is a subclass of Atom but has args\n+    class AtomWithArgs(Atom):\n+        def __new__(cls):\n+            obj = Atom.__new__(cls)\n+            return obj\n+        @property\n+        def args(self):\n+            return (1, 2)\n+    # Create an expression containing this atom\n+    atom_with_args = AtomWithArgs()\n+    expr = atom_with_args + Symbol('x')\n+    # The current behavior will include atom_with_args in atoms()\n+    # because it's a subclass of Atom\n+    # But the correct behavior should exclude it because it has args\n+    atoms = expr.atoms()\n+    # This should fail with the current implementation but pass after the fix\n+    assert atom_with_args not in atoms\n+    assert Symbol('x') in atoms\n+\n+\n \n def test_free_symbols_empty():\n     assert b21.free_symbols == set()\n@@ -298,3 +319,4 @@ def test_replace_exceptions():\n     raises(TypeError, lambda: e.replace(b*c, c.is_real))\n     raises(TypeError, lambda: e.replace(b.is_real, 1))\n     raises(TypeError, lambda: e.replace(lambda d: d.is_Number, 1))\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "astropy__astropy-14365",
        "model_patch": "diff --git a/astropy/io/ascii/tests/test_qdp.py b/astropy/io/ascii/tests/test_qdp.py\nindex ef24e6f6a3..626114a59d 100644\n--- a/astropy/io/ascii/tests/test_qdp.py\n+++ b/astropy/io/ascii/tests/test_qdp.py\n@@ -245,3 +245,21 @@ def test_get_lines_from_qdp(tmp_path):\n         assert file_output[i] == line\n         assert list_output[i] == line\n         assert text_output[i] == line\n+\n+def test_read_lowercase_commands(tmp_path):\n+    \"\"\"Test that QDP files with lowercase commands can be read.\"\"\"\n+    # Create a QDP file with lowercase commands\n+    qdp_file = tmp_path / \"test_lowercase.qdp\"\n+    with open(qdp_file, \"w\") as f:\n+        f.write(\"read serr 1 2\\n\")\n+        f.write(\"1 0.5 1 0.5\\n\")\n+    # This should not raise an error\n+    t = Table.read(qdp_file, format=\"ascii.qdp\")\n+    # Verify the data was read correctly\n+    assert len(t) == 1\n+    assert t[0][0] == 1\n+    assert t[0][1] == 1\n+    assert t[0][\"col1_err\"] == 0.5\n+    assert t[0][\"col2_err\"] == 0.5\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "astropy__astropy-6938",
        "model_patch": "diff --git a/astropy/io/fits/tests/test_table.py b/astropy/io/fits/tests/test_table.py\nindex 67fe21aa72..3063e8cc6d 100644\n--- a/astropy/io/fits/tests/test_table.py\n+++ b/astropy/io/fits/tests/test_table.py\n@@ -3074,3 +3074,24 @@ def test_regression_scalar_indexing():\n     x1b = x[(1,)]\n     # FITS_record does not define __eq__; so test elements.\n     assert all(a == b for a, b in zip(x1a, x1b))\n+\n+def test_ascii_table_d_exponent():\n+    import self\n+    \"\"\"\n+    Test that ASCII table columns with 'D' exponent notation are correctly\n+    converted to float values.\n+    \"\"\"\n+    # Create a simple ASCII table with a column containing 'D' exponent\n+    a = np.array(['1.23D+45', '5.67D-89'], dtype='S10')\n+    col = fits.Column(name='floats', format='A10', array=a)\n+    hdu = fits.TableHDU.from_columns([col])\n+    # Write to a file and read back\n+    with fits.HDUList(hdu) as hdul:\n+        hdul.writeto(self.temp('test_d_exponent.fits'), overwrite=True)\n+    with fits.open(self.temp('test_d_exponent.fits')) as hdul:\n+        # Check that the values were correctly converted from 'D' to 'E' notation\n+        data = hdul[1].data\n+        assert data['floats'][0] == 1.23e+45\n+        assert data['floats'][1] == 5.67e-89\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pydata__xarray-4493",
        "model_patch": "diff --git a/xarray/tests/test_dask.py b/xarray/tests/test_dask.py\nindex 19a61c60..b51ac722 100644\n--- a/xarray/tests/test_dask.py\n+++ b/xarray/tests/test_dask.py\n@@ -1592,6 +1592,28 @@ def test_more_transforms_pass_lazy_array_equiv(map_da, map_ds):\n         assert_equal(map_da.astype(map_da.dtype), map_da)\n         assert_equal(map_da.transpose(\"y\", \"x\", transpose_coords=False).cxy, map_da.cxy)\n \n+def test_dask_array_preserved_in_update():\n+    # Create a chunked dask array\n+    foo = xr.DataArray(np.random.randn(3, 3), dims=(\"x\", \"y\")).chunk()\n+    ds = xr.Dataset({\"foo\": foo, \"bar\": (\"x\", [1, 2, 3])})\n+    # Verify that foo is initially chunked\n+    assert isinstance(ds.foo.data, dask.array.Array)\n+    # Create an update dictionary with slices of the original data\n+    update_dict = {\"foo\": ((\"x\", \"y\"), ds.foo[1:, :]), \"bar\": (\"x\", ds.bar[1:])}\n+    # Verify that foo in the update dict is still chunked\n+    assert isinstance(update_dict[\"foo\"][1].data, dask.array.Array)\n+    # Update the dataset\n+    with raise_if_dask_computes():\n+        ds_updated = ds.update(update_dict)\n+    # Verify that foo is still chunked after the update\n+    assert isinstance(ds_updated.foo.data, dask.array.Array)\n+    # Ensure the data is correct\n+    ds_expected = xr.Dataset(\n+        {\"foo\": ((\"x\", \"y\"), ds.foo[1:, :]), \"bar\": (\"x\", ds.bar[1:])}\n+    )\n+    xr.testing.assert_equal(ds_updated, ds_expected)\n+\n+\n \n def test_optimize():\n     # https://github.com/pydata/xarray/issues/3698\n@@ -1599,3 +1621,4 @@ def test_optimize():\n     arr = xr.DataArray(a).chunk(5)\n     (arr2,) = dask.optimize(arr)\n     arr2.compute()\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sphinx-doc__sphinx-8474",
        "model_patch": "diff --git a/tests/test_build_latex.py b/tests/test_build_latex.py\nindex 69ffa36e0..021ed0450 100644\n--- a/tests/test_build_latex.py\n+++ b/tests/test_build_latex.py\n@@ -1558,3 +1558,17 @@ def test_latex_elements_extrapackages(app, status, warning):\n def test_latex_nested_tables(app, status, warning):\n     app.builder.build_all()\n     assert '' == warning.getvalue()\n+\n+@pytest.mark.sphinx('latex', testroot='numref')\n+def test_table_numref_warning(app, status, warning):\n+    \"\"\"Test that no warning is emitted for tables without numbers.\"\"\"\n+    app.builder.build_all()\n+    # Check that the warning about no number assigned for table is not present\n+    warnings = warning.getvalue()\n+    assert \"WARNING: no number is assigned for table\" not in warnings\n+    # Verify that tables with numref still work correctly\n+    result = (app.outdir / 'python.tex').read_text()\n+    assert ('\\\\hyperref[\\\\detokenize{index:table-1}]'\n+            '{Table \\\\ref{\\\\detokenize{index:table-1}}}') in result\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11964",
        "model_patch": "diff --git a/tests/model_fields/test_field_flags.py b/tests/model_fields/test_field_flags.py\nindex 0e9256207c..dfa624377f 100644\n--- a/tests/model_fields/test_field_flags.py\n+++ b/tests/model_fields/test_field_flags.py\n@@ -221,3 +221,31 @@ class FieldFlagsTests(test.SimpleTestCase):\n         # True causes backwards compatibility problems (#25320).\n         self.assertFalse(AllFieldsModel._meta.get_field('m2m').null)\n         self.assertTrue(AllFieldsModel._meta.get_field('reverse2').null)\n+\n+    def test_enum_field_values_type(self):\n+        \"\"\"\n+        Test that TextChoices and IntegerChoices field values have the correct type\n+        when retrieved from a model instance.\n+        \"\"\"\n+        class TextChoice(models.TextChoices):\n+            FIRST = \"first\", \"First Choice\"\n+            SECOND = \"second\", \"Second Choice\"\n+        class IntegerChoice(models.IntegerChoices):\n+            ONE = 1, \"One\"\n+            TWO = 2, \"Two\"\n+        class ChoiceModel(models.Model):\n+            text_field = models.CharField(max_length=10, choices=TextChoice.choices)\n+            integer_field = models.IntegerField(choices=IntegerChoice.choices)\n+            class Meta:\n+                app_label = \"model_fields\"\n+        # Test with TextChoices\n+        model = ChoiceModel(text_field=TextChoice.FIRST, integer_field=IntegerChoice.ONE)\n+        # The value should be a string, not an enum\n+        self.assertIsInstance(model.text_field, str)\n+        self.assertEqual(model.text_field, \"first\")\n+        # Test with IntegerChoices\n+        self.assertIsInstance(model.integer_field, int)\n+        self.assertEqual(model.integer_field, 1)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11564",
        "model_patch": "diff --git a/tests/staticfiles_tests/test_templatetags.py b/tests/staticfiles_tests/test_templatetags.py\nindex cd3f7d4bfa..b400b6d939 100644\n--- a/tests/staticfiles_tests/test_templatetags.py\n+++ b/tests/staticfiles_tests/test_templatetags.py\n@@ -19,3 +19,23 @@ class TestTemplateTag(StaticFilesTestCase):\n         \"\"\"\n         self.assertStaticRenders('a.html', 'a.html?a=b&amp;c=d')\n         self.assertStaticRenders('a.html', 'a.html?a=b&c=d', autoescape=False)\n+\n+    def test_script_name_in_static_url(self):\n+        \"\"\"\n+        Test that {% static %} tag respects SCRIPT_NAME in WSGI environment.\n+        \"\"\"\n+        with override_settings(STATIC_URL='/static/'):\n+            # Create a request with SCRIPT_NAME set\n+            script_name = '/app-prefix'\n+            request = self.request_factory.get('/')\n+            request.META['SCRIPT_NAME'] = script_name\n+            # Render a template with the static tag\n+            template = self.engine.from_string('{% load static %}{% static \"test.css\" %}')\n+            context = {'request': request}\n+            url = template.render(context)\n+            # The URL should include the SCRIPT_NAME prefix\n+            expected_url = f\"{script_name}/static/test.css\"\n+            self.assertEqual(url, expected_url)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-11148",
        "model_patch": "diff --git a/testing/python/collect.py b/testing/python/collect.py\nindex 8de216d8f..e00d4c27d 100644\n--- a/testing/python/collect.py\n+++ b/testing/python/collect.py\n@@ -42,6 +42,44 @@ class TestModule:\n             ]\n         )\n \n+    def test_import_duplicate_importlib(pytester: Pytester) -> None:\n+        \"\"\"Test that modules are not imported twice when using import-mode=importlib.\"\"\"\n+        a = pytester.mkdir(\"a\")\n+        b = pytester.mkdir(\"b\")\n+        p1 = a.joinpath(\"test_whatever.py\")\n+        p1.write_text(\"def test_func(): pass\")\n+        p2 = b.joinpath(\"test_whatever.py\")\n+        p2.write_text(\"def test_func(): pass\")\n+        # ensure we don't have it imported already\n+        sys.modules.pop(p1.stem, None)\n+        # Create a simple module that tracks imports\n+        tracker = pytester.makepyfile(\n+            tracker=\"\"\"\n+            imports = set()\n+            def track_import(name):\n+                imports.add(name)\n+                return len(imports)\n+            \"\"\"\n+        )\n+        # Create a test that imports the tracker and uses it\n+        test_file = pytester.makepyfile(\n+            test_track=\"\"\"\n+            import sys\n+            from tracker import track_import, imports\n+            def test_import_count():\n+                # Import the module and track it\n+                count = track_import('test_whatever')\n+                # Assert that it's only imported once\n+                assert count == 1\n+                assert len(imports) == 1\n+            \"\"\"\n+        )\n+        # Run with importlib mode\n+        result = pytester.runpytest(\"-v\", \"--import-mode=importlib\", \"test_track.py\")\n+        result.stdout.fnmatch_lines([\"*1 passed*\"])\n+    \n+\n+\n     def test_import_prepend_append(\n         self, pytester: Pytester, monkeypatch: MonkeyPatch\n     ) -> None:\n@@ -1515,3 +1553,4 @@ def test_package_ordering(pytester: Pytester) -> None:\n     # Execute from .\n     result = pytester.runpytest(\"-v\", \"-s\")\n     result.assert_outcomes(passed=3)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-11897",
        "model_patch": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 8a70549050..edcbb7f606 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1594,3 +1594,26 @@ def test_latex_UnevaluatedExpr():\n     assert latex(he**2) == r\"\\left(\\frac{1}{x}\\right)^{2}\"\n     assert latex(he + 1) == r\"1 + \\frac{1}{x}\"\n     assert latex(x*he) == r\"x \\frac{1}{x}\"\n+\n+def test_latex_printer_consistency():\n+    # Test case 1: exp(-x)*log(x)\n+    expr1 = exp(-x)*log(x)\n+    latex_expr1 = latex(expr1)\n+    # The LaTeX output should be consistent with pretty printer\n+    # which shows \"\u212f^(-x)\u22c5log(x)\" and not \"\\\\frac{1}{e^{x}} \\\\log{\\\\left (x \\\\right )}\"\n+    assert latex_expr1 == r\"e^{-x} \\log{\\left(x \\right)}\"\n+    # Test case 2: 1/(x + y)/2\n+    y = Symbol('y')\n+    expr2 = 1/(x + y)/2\n+    latex_expr2 = latex(expr2)\n+    # The LaTeX output should be consistent with pretty printer\n+    # which shows \"1/(2\u22c5(x + y))\" and not \"\\\\frac{1}{2 x + 2 y}\"\n+    assert latex_expr2 == r\"\\frac{1}{2 \\left(x + y\\right)}\"\n+    # Test with positive assumption\n+    x_pos = Symbol('x', positive=True)\n+    expr3 = exp(-x_pos)*log(x_pos)\n+    latex_expr3 = latex(expr3)\n+    # Assumptions should not affect printing\n+    assert latex_expr3 == r\"e^{-x} \\log{\\left(x \\right)}\"\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-7220",
        "model_patch": "diff --git a/testing/test_terminal.py b/testing/test_terminal.py\nindex 0f5b4cb68..68aa3e5da 100644\n--- a/testing/test_terminal.py\n+++ b/testing/test_terminal.py\n@@ -2135,6 +2135,33 @@ def test_via_exec(testdir: Testdir) -> None:\n         [\"test_via_exec.py::test_via_exec <- <string> PASSED*\", \"*= 1 passed in *\"]\n     )\n \n+def test_path_not_affected_by_chdir(testdir):\n+    \"\"\"Test that the path displayed in the error message is not affected by chdir.\"\"\"\n+    testdir.makepyfile(\n+        test_path_error=\"\"\"\n+        import os\n+        import pytest\n+        @pytest.fixture\n+        def change_dir():\n+            out_dir = 'subdir'\n+            os.makedirs(out_dir, exist_ok=True)\n+            old_dir = os.getcwd()\n+            os.chdir(out_dir)\n+            yield out_dir\n+            os.chdir(old_dir)\n+        def test_show_path(change_dir):\n+            assert False\n+        \"\"\"\n+    )\n+    result = testdir.runpytest(\"test_path_error.py\", \"-v\")\n+    # The path in the error message should be the original path, not a relative path\n+    # from the changed directory\n+    result.stdout.fnmatch_lines([\"*test_path_error.py:*: AssertionError\"])\n+    # Make sure we don't see \"../test_path_error.py\" which would indicate the path\n+    # is being displayed relative to the changed directory\n+    assert \"../test_path_error.py\" not in result.stdout.str()\n+\n+\n \n class TestCodeHighlight:\n     def test_code_highlight_simple(self, testdir: Testdir, color_mapping) -> None:\n@@ -2177,3 +2204,4 @@ class TestCodeHighlight:\n                 ]\n             )\n         )\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-12171",
        "model_patch": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex 8fd05ae544..ad51afe073 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -81,3 +81,15 @@ def test_Sum():\n                      (y, -oo, oo))) == \\\n         \"Hold[Sum[Exp[-x^2 - y^2], {x, -Infinity, Infinity}, \" \\\n         \"{y, -Infinity, Infinity}]]\"\n+\n+def test_Derivative_and_Float():\n+    x, y, t = symbols('x y t')\n+    f = Function('f')\n+    # Test Derivative handling\n+    assert mcode(f(t).diff(t)) == \"D[f[t], t]\"\n+    assert mcode(f(x, y).diff(x, y)) == \"D[f[x, y], x, y]\"\n+    # Test Float with exponents\n+    assert mcode(1.0e-4) == \"1.0*^-4\"\n+    assert mcode(5.5e10) == \"5.5*^10\"\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-18621",
        "model_patch": "diff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex 9d778737b0..13e1c7b9fa 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -185,6 +185,16 @@ def test_BlockDiagMatrix():\n     assert (X._blockmul(M)).is_MatMul\n     assert (X._blockadd(M)).is_MatAdd\n \n+def test_BlockDiagMatrix_single_element():\n+    # Test that a BlockDiagMatrix with a single element can be converted to a regular Matrix\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M)\n+    # This should not raise an error\n+    B = Matrix(D)\n+    # Verify the result is correct\n+    assert B == M\n+\n+\n def test_blockcut():\n     A = MatrixSymbol('A', n, m)\n     B = blockcut(A, (n/2, n/2), (m/2, m/2))\n@@ -228,3 +238,4 @@ def test_block_collapse_type():\n     assert block_collapse(Transpose(bm1)).__class__ == BlockDiagMatrix\n     assert bc_transpose(Transpose(bm1)).__class__ == BlockDiagMatrix\n     assert bc_inverse(Inverse(bm1)).__class__ == BlockDiagMatrix\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-14317",
        "model_patch": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 57de1d4849..b4baaebf78 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1147,6 +1147,15 @@ def test_latex_Poly():\n     assert latex(Poly(2.0*x + y)) == \\\n         r\"\\operatorname{Poly}{\\left( 2.0 x + 1.0 y, x, y, domain=\\mathbb{R} \\right)}\"\n \n+def test_latex_Poly_monomial_order():\n+    # Test that the latex printer preserves the same monomial order as str and pretty\n+    a, b, c, x = symbols('a b c x')\n+    p = Poly([a, 1, b, 2, c, 3], x)\n+    # The expected output should have monomials in descending degree order\n+    expected = r\"\\operatorname{Poly}{\\left( a x^{5} + x^{4} + b x^{3} + 2 x^{2} + c x + 3, x, domain=\\mathbb{Z}\\left[a, b, c\\right] \\right)}\"\n+    assert latex(p) == expected\n+\n+\n \n def test_latex_ComplexRootOf():\n     assert latex(rootof(x**5 + x + 3, 0)) == \\\n@@ -1761,3 +1770,4 @@ def test_latex_degree():\n     assert latex(expr2) == r\"x ^\\circ\"\n     expr3 = cos(x*degree + 90*degree)\n     assert latex(expr3) == r'\\cos{\\left (x ^\\circ + 90 ^\\circ \\right )}'\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13158",
        "model_patch": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex 8f41ce9c40..d237bf1fe3 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -373,3 +373,36 @@ class ModelChoiceFieldTests(TestCase):\n         )\n         with self.assertNumQueries(2):\n             template.render(Context({'form': CategoriesForm()}))\n+\n+    def test_union_queryset_none(self):\n+        \"\"\"\n+        Test that calling none() on a union queryset returns an empty queryset.\n+        \"\"\"\n+        # Create some test data\n+        writer1 = Writer.objects.create(name=\"Writer 1\")\n+        writer2 = Writer.objects.create(name=\"Writer 2\")\n+        writer3 = Writer.objects.create(name=\"Writer 3\")\n+        # Create a union queryset\n+        qs1 = Writer.objects.filter(pk=writer1.pk)\n+        qs2 = Writer.objects.filter(pk=writer2.pk)\n+        union_qs = qs1.union(qs2)\n+        # Test that the union queryset contains the expected objects\n+        self.assertEqual(union_qs.count(), 2)\n+        # Test that calling none() on the union queryset returns an empty queryset\n+        none_qs = union_qs.none()\n+        self.assertEqual(none_qs.count(), 0)\n+        # Create a form with a ModelMultipleChoiceField using the union queryset\n+        class WriterForm(forms.Form):\n+            writers = forms.ModelMultipleChoiceField(\n+                queryset=Writer.objects.filter(pk=writer1.pk).union(\n+                    Writer.objects.filter(pk=writer2.pk)\n+                ),\n+                required=False,\n+            )\n+        # Test that submitting an empty form doesn't select any writers\n+        form = WriterForm(data={'writers': []})\n+        self.assertTrue(form.is_valid())\n+        self.assertEqual(len(form.cleaned_data['writers']), 0)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-16910",
        "model_patch": "diff --git a/tests/defer/tests.py b/tests/defer/tests.py\nindex c7eb03dc8a..7e152d52b7 100644\n--- a/tests/defer/tests.py\n+++ b/tests/defer/tests.py\n@@ -130,6 +130,25 @@ class DeferTests(AssertionMixin, TestCase):\n         self.assertEqual(obj.related_id, self.s1.pk)\n         self.assertEqual(obj.name, \"p1\")\n \n+    def test_only_with_select_related_reverse_onetoone(self):\n+        \"\"\"\n+        Test that only() with select_related() works correctly on reverse OneToOneField relations.\n+        \"\"\"\n+        # Create a Primary object with a related Secondary object\n+        primary = Primary.objects.create(name=\"p_reverse\")\n+        secondary = Secondary.objects.create(name=\"s_reverse\", value=1, primary=primary)\n+        # Query using the reverse lookup with only() and select_related()\n+        obj = Secondary.objects.select_related('primary').only('name', 'primary__name').get(pk=secondary.pk)\n+        # The primary object should have only the 'name' field loaded\n+        self.assert_delayed(obj.primary, 1)\n+        # The secondary object should have only the 'name' field loaded\n+        self.assert_delayed(obj, 2)\n+        # Verify the values are correct\n+        self.assertEqual(obj.name, \"s_reverse\")\n+        self.assertEqual(obj.primary.name, \"p_reverse\")\n+    \n+\n+\n     def test_defer_foreign_keys_are_deferred_and_not_traversed(self):\n         # select_related() overrides defer().\n         with self.assertNumQueries(1):\n@@ -326,3 +345,4 @@ class InvalidDeferTests(SimpleTestCase):\n         )\n         with self.assertRaisesMessage(FieldError, msg):\n             Primary.objects.only(\"name\").select_related(\"related\")[0]\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-5103",
        "model_patch": "diff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex 87dada213..01c2ea3fc 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -1286,6 +1286,23 @@ def test_rewrite_infinite_recursion(testdir, pytestconfig, monkeypatch):\n     assert hook.find_module(\"test_foo\") is not None\n     assert len(write_pyc_called) == 1\n \n+def test_all_any_unrolling(testdir):\n+    testdir.makepyfile(\"\"\"\n+        def is_even(n):\n+            return n % 2 == 0\n+        def test_all_even():\n+            even_stevens = list(range(1, 5, 2))  # [1, 3]\n+            assert all(is_even(number) for number in even_stevens)\n+    \"\"\")\n+    result = testdir.runpytest(\"-v\")\n+    result.stdout.fnmatch_lines([\n+        \"*test_all_even*\",\n+        \"*assert is_even(1)*\",\n+        \"*where False = is_even(1)*\"\n+    ])\n+    assert result.ret == 1\n+\n+\n \n class TestEarlyRewriteBailout(object):\n     @pytest.fixture\n@@ -1395,3 +1412,4 @@ class TestEarlyRewriteBailout(object):\n         )\n         result = testdir.runpytest()\n         result.stdout.fnmatch_lines([\"* 1 passed in *\"])\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-25311",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex ec6bdcc2fe..d279822515 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -282,3 +282,22 @@ def test_dynamic_norm():\n def test_vertexselector():\n     line, = plt.plot([0, 1], picker=True)\n     pickle.loads(pickle.dumps(VertexSelector(line)))\n+\n+def test_pickle_draggable_legend():\n+    \"\"\"Test that a figure with a draggable legend can be pickled.\"\"\"\n+    fig = plt.figure()\n+    ax = fig.add_subplot(111)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40, 43, 45, 47, 48]\n+    ax.plot(time, speed, label=\"speed\")\n+    leg = ax.legend()\n+    leg.set_draggable(True)  # This is what causes the pickling to fail\n+    # Try to pickle the figure\n+    pickle_data = pickle.dumps(fig)\n+    # Make sure we can unpickle it too\n+    fig_unpickled = pickle.loads(pickle_data)\n+    # Clean up\n+    plt.close(fig)\n+    plt.close(fig_unpickled)\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14730",
        "model_patch": "diff --git a/tests/model_fields/test_manytomanyfield.py b/tests/model_fields/test_manytomanyfield.py\nindex 0ddf57ceaf..4867af31d5 100644\n--- a/tests/model_fields/test_manytomanyfield.py\n+++ b/tests/model_fields/test_manytomanyfield.py\n@@ -87,6 +87,21 @@ class ManyToManyFieldTests(SimpleTestCase):\n                     db_table='custom_name',\n                 )\n \n+    @isolate_apps('model_fields')\n+    def test_symmetrical_with_related_name(self):\n+        \"\"\"\n+        ManyToManyField should raise an error if symmetrical=True and\n+        related_name is provided.\n+        \"\"\"\n+        with self.assertRaisesMessage(\n+            ValueError,\n+            'Cannot specify a related_name on a ManyToManyField with symmetrical=True.',\n+        ):\n+            class MyModel(models.Model):\n+                friends = models.ManyToManyField('self', symmetrical=True, related_name='followers')\n+    \n+\n+\n \n class ManyToManyFieldDBTests(TestCase):\n \n@@ -99,3 +114,4 @@ class ManyToManyFieldDBTests(TestCase):\n         related_obj = ManyToMany.objects.create()\n         obj.m2m.add(related_obj)\n         self.assertEqual(obj._meta.get_field('m2m').value_from_object(obj), [related_obj])\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-18869",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_matplotlib.py b/lib/matplotlib/tests/test_matplotlib.py\nindex cad9433a56..f9119be91b 100644\n--- a/lib/matplotlib/tests/test_matplotlib.py\n+++ b/lib/matplotlib/tests/test_matplotlib.py\n@@ -65,3 +65,20 @@ def test_importable_with__OO():\n     )\n     cmd = [sys.executable, \"-OO\", \"-c\", program]\n     assert subprocess.call(cmd, env={**os.environ, \"MPLBACKEND\": \"\"}) == 0\n+\n+def test_version_info():\n+    \"\"\"Test that matplotlib has a version_info attribute that is comparable.\"\"\"\n+    assert hasattr(matplotlib, 'version_info')\n+    # Test that version_info is a tuple of integers (and possibly strings for dev/rc versions)\n+    assert isinstance(matplotlib.version_info, tuple)\n+    # Test that the version_info corresponds to __version__\n+    version_str = matplotlib.__version__\n+    # Basic check: first element of version_info should match the major version in __version__\n+    assert str(matplotlib.version_info[0]) == version_str.split('.')[0]\n+    # Test comparability with another tuple\n+    # This should work regardless of the actual version\n+    current_version = matplotlib.version_info\n+    older_version = (matplotlib.version_info[0] - 1,) + matplotlib.version_info[1:]\n+    assert current_version > older_version\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11179",
        "model_patch": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 55eeb226ea..a6cca12cf5 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -425,6 +425,22 @@ class DeletionTests(TestCase):\n         for k, v in existed_objs.items():\n             self.assertEqual(deleted_objs[k], v)\n \n+    def test_model_delete_clears_pk(self):\n+        \"\"\"\n+        Model.delete() should clear the primary key of the deleted instance.\n+        \"\"\"\n+        m = M.objects.create()\n+        pk = m.pk\n+        m.delete()\n+        self.assertIsNone(m.pk, \"Primary key should be set to None after delete()\")\n+        # Also test with a model that has no dependencies\n+        a = A.objects.create()\n+        pk = a.pk\n+        a.delete()\n+        self.assertIsNone(a.pk, \"Primary key should be set to None after delete() for models without dependencies\")\n+    \n+\n+\n     def test_proxied_model_duplicate_queries(self):\n         \"\"\"\n         #25685 - Deleting instances of a model with existing proxy\n@@ -522,3 +538,4 @@ class FastDeleteTests(TestCase):\n                 User.objects.filter(avatar__desc='missing').delete(),\n                 (0, {'delete.User': 0})\n             )\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13710",
        "model_patch": "diff --git a/tests/admin_inlines/tests.py b/tests/admin_inlines/tests.py\nindex 261c4f0148..59651e0206 100644\n--- a/tests/admin_inlines/tests.py\n+++ b/tests/admin_inlines/tests.py\n@@ -1504,3 +1504,24 @@ class SeleniumTests(AdminSeleniumTestCase):\n                 available, chosen = self.selenium.find_elements_by_css_selector(css_selector % 2)\n                 self.assertEqual(available.text, 'AVAILABLE ATTENDANT')\n                 self.assertEqual(chosen.text, 'CHOSEN ATTENDANT')\n+\n+    def test_inline_verbose_name_plural_default(self):\n+        \"\"\"\n+        Test that verbose_name_plural defaults to verbose_name + 's'\n+        when only verbose_name is provided in an inline.\n+        \"\"\"\n+        class CustomVerboseNameInline(TabularInline):\n+            model = Profile\n+            verbose_name = \"Custom Profile\"\n+        ma = ModelAdmin(Author, admin_site)\n+        ma.inlines = [CustomVerboseNameInline]\n+        request = RequestFactory().get('/admin/admin_inlines/author/add/')\n+        request.user = User(username='super', is_superuser=True)\n+        formset = ma.get_inline_formsets(request, None)[0]\n+        # This should fail with the current implementation and pass after the fix\n+        # Currently, it would use the model's verbose_name_plural instead of \n+        # deriving it from the inline's verbose_name\n+        self.assertEqual(formset.opts.verbose_name_plural, \"Custom Profiles\")\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-13437",
        "model_patch": "diff --git a/sympy/series/tests/test_limits.py b/sympy/series/tests/test_limits.py\nindex 627517526f..4b1846f14e 100644\n--- a/sympy/series/tests/test_limits.py\n+++ b/sympy/series/tests/test_limits.py\n@@ -412,6 +412,12 @@ def test_factorial():\n     assert limit(f, x, x**2) == factorial(x**2)\n     assert limit(f, x, -x**2) == factorial(-x**2)\n \n+def test_bell_limit():\n+    from sympy.functions.combinatorial.numbers import bell\n+    n = Symbol('n')\n+    assert limit(bell(n), n, oo) == oo\n+\n+\n \n def test_issue_6560():\n     e = (5*x**3/4 - 3*x/4 + (y*(3*x**2/2 - S(1)/2) +\n@@ -505,3 +511,4 @@ def test_issue_6599():\n def test_issue_12555():\n     assert limit((3**x + 2* x**10) / (x**10 + exp(x)), x, -oo) == 2\n     assert limit((3**x + 2* x**10) / (x**10 + exp(x)), x, oo) == oo\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-13773",
        "model_patch": "diff --git a/sympy/matrices/expressions/tests/test_matmul.py b/sympy/matrices/expressions/tests/test_matmul.py\nindex 5a76ec12ee..c476b2ba09 100644\n--- a/sympy/matrices/expressions/tests/test_matmul.py\n+++ b/sympy/matrices/expressions/tests/test_matmul.py\n@@ -135,3 +135,22 @@ def test_matmul_args_cnc():\n def test_issue_12950():\n     M = Matrix([[Symbol(\"x\")]]) * MatrixSymbol(\"A\", 1, 1)\n     assert MatrixSymbol(\"A\", 1, 1).as_explicit()[0]*Symbol('x') == M.as_explicit()[0]\n+\n+def test_matmul_scalar_error():\n+    # Test that matmul raises an error when one operand is a scalar\n+    A = Matrix([[1, 2], [3, 4]])\n+    # Test scalar @ matrix\n+    import pytest\n+    with pytest.raises(TypeError):\n+        2 @ A\n+    # Test matrix @ scalar\n+    with pytest.raises(TypeError):\n+        A @ 2\n+    # Ensure regular matrix multiplication still works\n+    B = Matrix([[2, 3], [1, 2]])\n+    assert A @ B == Matrix([[4, 7], [10, 17]])\n+    # Ensure scalar multiplication still works with *\n+    assert 2 * A == Matrix([[2, 4], [6, 8]])\n+    assert A * 2 == Matrix([[2, 4], [6, 8]])\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sphinx-doc__sphinx-8282",
        "model_patch": "diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex c0676f23f..b3d790f4f 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -2025,6 +2025,32 @@ def test_overload2(app):\n         '',\n     ]\n \n+def test_autodoc_typehints_for_overloaded_functions(app):\n+    text = (\".. autofunction:: target.overload_func\\n\"\n+            \".. autofunction:: target.overload_func2\\n\")\n+    # Test with autodoc_typehints = 'none'\n+    app.config.autodoc_typehints = 'none'\n+    result = app.build(force_all=True)\n+    assert result == 0\n+    content = (app.outdir / 'index.txt').read_text(encoding='utf8')\n+    assert 'target.overload_func(x)' in content\n+    assert 'target.overload_func(x: int)' not in content\n+    assert 'target.overload_func(x: float)' not in content\n+    assert 'target.overload_func2(x)' in content\n+    assert 'target.overload_func2(x: str)' not in content\n+    assert 'target.overload_func2(x: list)' not in content\n+    # Test with autodoc_typehints = 'description'\n+    app.config.autodoc_typehints = 'description'\n+    result = app.build(force_all=True)\n+    assert result == 0\n+    content = (app.outdir / 'index.txt').read_text(encoding='utf8')\n+    assert 'target.overload_func(x)' in content\n+    assert 'target.overload_func(x: int)' not in content\n+    assert 'target.overload_func(x: float)' not in content\n+    assert ':type x: int or float' in content\n+    assert ':rtype: int or float' in content\n+\n+\n \n @pytest.mark.sphinx('html', testroot='ext-autodoc')\n def test_pymodule_for_ModuleLevelDocumenter(app):\n@@ -2149,3 +2175,4 @@ def test_name_mangling(app):\n         '      name of Foo',\n         '',\n     ]\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-23262",
        "model_patch": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex 023c2fb55a..8f348d30f0 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1570,3 +1570,24 @@ def assertAllClose(self, result, *, abstol=1e-15, reltol=1e-15):\n def test_deprecated_set():\n     with warns_deprecated_sympy():\n         lambdify({x, y}, x + y)\n+\n+def test_lambdify_tuple_output():\n+    # Test that lambdify correctly handles tuples with one element\n+    # The issue is that the comma is missing in the generated code for single-element tuples\n+    f = lambdify([], tuple([1]))\n+    source = inspect.getsource(f)\n+    # Check that the generated code includes the comma after the single element\n+    assert \"(1,)\" in source\n+    # Verify that the function actually returns a tuple, not an integer\n+    result = f()\n+    assert isinstance(result, tuple)\n+    assert result == (1,)\n+    # Verify that tuples with multiple elements work correctly\n+    g = lambdify([], tuple([1, 2]))\n+    source_g = inspect.getsource(g)\n+    assert \"(1, 2)\" in source_g\n+    result_g = g()\n+    assert isinstance(result_g, tuple)\n+    assert result_g == (1, 2)\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pydata__xarray-5131",
        "model_patch": "diff --git a/xarray/tests/test_groupby.py b/xarray/tests/test_groupby.py\nindex 5ef7677c..b8e06b93 100644\n--- a/xarray/tests/test_groupby.py\n+++ b/xarray/tests/test_groupby.py\n@@ -385,10 +385,11 @@ repr_da = xr.DataArray(\n \n @pytest.mark.parametrize(\"dim\", [\"x\", \"y\", \"z\", \"month\"])\n @pytest.mark.parametrize(\"obj\", [repr_da, repr_da.to_dataset(name=\"a\")])\n+\n def test_groupby_repr(obj, dim):\n     actual = repr(obj.groupby(dim))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over %r \" % dim\n+    expected += \", grouped over %r\" % dim  # Removed trailing space\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj[dim])))\n     if dim == \"x\":\n         expected += \"1, 2, 3, 4, 5.\"\n@@ -401,6 +402,7 @@ def test_groupby_repr(obj, dim):\n     assert actual == expected\n \n \n+\n @pytest.mark.parametrize(\"obj\", [repr_da, repr_da.to_dataset(name=\"a\")])\n def test_groupby_repr_datetime(obj):\n     actual = repr(obj.groupby(\"t.month\"))\n@@ -563,3 +565,4 @@ def test_groupby_getitem(dataset):\n \n \n # TODO: move other groupby tests from test_dataset and test_dataarray over here\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "astropy__astropy-14182",
        "model_patch": "diff --git a/astropy/io/ascii/tests/test_rst.py b/astropy/io/ascii/tests/test_rst.py\nindex 84d6fed401..d201c01782 100644\n--- a/astropy/io/ascii/tests/test_rst.py\n+++ b/astropy/io/ascii/tests/test_rst.py\n@@ -185,3 +185,38 @@ Col1      Col2 Col3 Col4\n ==== ========= ==== ====\n \"\"\",\n     )\n+\n+def test_write_with_header_rows():\n+    \"\"\"Test writing a table with header_rows to RST format.\"\"\"\n+    from astropy.table import QTable\n+    from astropy import units as u\n+    # Create a simple table with units\n+    tbl = QTable({'wave': [350, 950] * u.nm, 'response': [0.7, 1.2] * u.count})\n+    # Test writing with header_rows parameter\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"name\", \"unit\"])\n+    # Expected output with name and unit rows\n+    expected = \"\"\"\\\n+===== ========\n+ wave response\n+  nm      ct  \n+===== ========\n+350.0      0.7\n+950.0      1.2\n+===== ========\n+\"\"\"\n+    assert_equal(out.getvalue().strip(), expected.strip())\n+    # Test with different header_rows\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"unit\"])\n+    expected = \"\"\"\\\n+===== ========\n+  nm      ct  \n+===== ========\n+350.0      0.7\n+950.0      1.2\n+===== ========\n+\"\"\"\n+    assert_equal(out.getvalue().strip(), expected.strip())\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14382",
        "model_patch": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex fd94d4919f..e558712693 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -2021,6 +2021,22 @@ class StartProject(LiveServerTestCase, AdminScriptTestCase):\n         self.assertTrue(os.path.isdir(testproject_dir))\n         self.assertTrue(os.path.exists(os.path.join(testproject_dir, 'additional_dir')))\n \n+    def test_startapp_dir_with_trailing_slash(self):\n+        \"\"\"\n+        Test that startapp works when the directory has a trailing slash.\n+        \"\"\"\n+        app_name = 'trailingslashapp'\n+        target_dir = os.path.join(self.test_dir, 'subdir' + os.sep)\n+        os.makedirs(target_dir)\n+        args = ['startapp', app_name, target_dir]\n+        out, err = self.run_django_admin(args)\n+        self.assertNoOutput(err)\n+        self.assertTrue(os.path.isdir(os.path.join(target_dir, app_name)))\n+        self.assertTrue(os.path.exists(os.path.join(target_dir, app_name, '__init__.py')))\n+        self.assertTrue(os.path.exists(os.path.join(target_dir, app_name, 'apps.py')))\n+    \n+\n+\n     def test_custom_project_template_from_tarball_by_path(self):\n         \"Make sure the startproject management command is able to use a different project template from a tarball\"\n         template_path = os.path.join(custom_templates_dir, 'project_template.tgz')\n@@ -2345,3 +2361,4 @@ class DjangoAdminSuggestions(AdminScriptTestCase):\n         out, err = self.run_django_admin(args)\n         self.assertNoOutput(out)\n         self.assertNotInOutput(err, 'Did you mean')\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sphinx-doc__sphinx-8435",
        "model_patch": "diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex d8e1f730e..c3d778e2b 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -2028,6 +2028,31 @@ def test_overload2(app):\n         '',\n     ]\n \n+def test_autodoc_type_aliases_for_variables(app):\n+    app.config.autodoc_type_aliases = {\n+        'String': 'target.Class',\n+    }\n+    # Create a temporary module with variables and attributes using type aliases\n+    with open(app.srcdir / 'alias_vars.py', 'w') as f:\n+        f.write('''\n+from __future__ import annotations\n+#: variable with type alias\n+var: String\n+class MyClass:\n+    \"\"\"A class with a variable using type alias.\"\"\"\n+    #: attribute with type alias\n+    attr: String\n+''')\n+    # Test that type aliases are applied to module variables and class attributes\n+    options = {\"members\": None, \"undoc-members\": True}\n+    actual = do_autodoc(app, 'module', 'alias_vars', options)\n+    # Check that the type aliases are correctly applied\n+    assert '.. py:data:: var' in '\\n'.join(actual)\n+    assert ':type: target.Class' in '\\n'.join(actual)\n+    assert '.. py:attribute:: MyClass.attr' in '\\n'.join(actual)\n+    assert ':type: target.Class' in '\\n'.join(actual)\n+\n+\n \n @pytest.mark.sphinx('html', testroot='ext-autodoc')\n def test_pymodule_for_ModuleLevelDocumenter(app):\n@@ -2152,3 +2177,4 @@ def test_name_mangling(app):\n         '      name of Foo',\n         '',\n     ]\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-23314",
        "model_patch": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex 966eb50b21..e5afe0c3e4 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -1647,6 +1647,33 @@ def test_scatter_spiral():\n     # force at least 1 draw!\n     fig.canvas.draw()\n \n+def test_set_visible():\n+    \"\"\"Test that set_visible works properly for 3D axes.\"\"\"\n+    # Create a figure with two 3D subplots\n+    fig = plt.figure()\n+    ax1 = fig.add_subplot(1, 2, 1, projection='3d')\n+    ax2 = fig.add_subplot(1, 2, 2, projection='3d')\n+    # Add some content to both axes\n+    ax1.scatter([1], [1], [1])\n+    ax2.scatter([1], [1], [1], c='r')\n+    # Set the first axis to not be visible\n+    ax1.set_visible(False)\n+    # Check that the visibility state is correctly set\n+    assert not ax1.get_visible()\n+    assert ax2.get_visible()\n+    # Check that the first axis's artists are not visible\n+    for artist in ax1.get_children():\n+        if hasattr(artist, 'get_visible'):\n+            assert not artist.get_visible()\n+    # The second axis's artists should still be visible\n+    visible_artists = False\n+    for artist in ax2.get_children():\n+        if hasattr(artist, 'get_visible') and artist.get_visible():\n+            visible_artists = True\n+            break\n+    assert visible_artists\n+\n+\n \n @pytest.mark.parametrize(\n     \"vertical_axis, proj_expected, axis_lines_expected, tickdirs_expected\",\n@@ -1736,3 +1763,4 @@ def test_view_init_vertical_axis(\n         tickdir_expected = tickdirs_expected[i]\n         tickdir_actual = axis._get_tickdir()\n         np.testing.assert_array_equal(tickdir_expected, tickdir_actual)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13220",
        "model_patch": "diff --git a/tests/validators/tests.py b/tests/validators/tests.py\nindex d6d013c026..a8a09f3244 100644\n--- a/tests/validators/tests.py\n+++ b/tests/validators/tests.py\n@@ -512,6 +512,38 @@ class TestValidatorEquality(TestCase):\n             ProhibitNullCharactersValidator(message='message', code='code2')\n         )\n \n+    def test_validation_error_equality(self):\n+        # Test that ValidationErrors with identical messages are equal\n+        error1 = ValidationError(\"Invalid value\")\n+        error2 = ValidationError(\"Invalid value\")\n+        self.assertEqual(error1, error2)\n+        # Test with message lists\n+        error1 = ValidationError([\"Error 1\", \"Error 2\"])\n+        error2 = ValidationError([\"Error 1\", \"Error 2\"])\n+        self.assertEqual(error1, error2)\n+        # Test with message lists in different order\n+        error1 = ValidationError([\"Error 1\", \"Error 2\"])\n+        error2 = ValidationError([\"Error 2\", \"Error 1\"])\n+        self.assertEqual(error1, error2)\n+        # Test with message dictionaries\n+        error1 = ValidationError({'field1': ['Error 1', 'Error 2'], 'field2': ['Error 3']})\n+        error2 = ValidationError({'field1': ['Error 1', 'Error 2'], 'field2': ['Error 3']})\n+        self.assertEqual(error1, error2)\n+        # Test with message dictionaries with lists in different order\n+        error1 = ValidationError({'field1': ['Error 1', 'Error 2'], 'field2': ['Error 3']})\n+        error2 = ValidationError({'field1': ['Error 2', 'Error 1'], 'field2': ['Error 3']})\n+        self.assertEqual(error1, error2)\n+        # Test that different ValidationErrors are not equal\n+        error1 = ValidationError(\"Invalid value\")\n+        error2 = ValidationError(\"Different message\")\n+        self.assertNotEqual(error1, error2)\n+        # Test with different message dictionaries\n+        error1 = ValidationError({'field1': ['Error 1'], 'field2': ['Error 3']})\n+        error2 = ValidationError({'field1': ['Error 2'], 'field2': ['Error 3']})\n+        self.assertNotEqual(error1, error2)\n+    \n+\n+\n \n class DeprecationTests(SimpleTestCase):\n     @ignore_warnings(category=RemovedInDjango41Warning)\n@@ -550,3 +582,4 @@ class DeprecationTests(SimpleTestCase):\n         )\n         with self.assertRaisesMessage(RemovedInDjango41Warning, msg):\n             validator.domain_whitelist = ['mydomain']\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13933",
        "model_patch": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex 9931fa50e3..1d31197cb0 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -1863,6 +1863,23 @@ class ModelMultipleChoiceFieldTests(TestCase):\n         with self.assertNumQueries(1):\n             template.render(Context({'field': field}))\n \n+    def test_modelchoicefield_invalid_choice_error_message(self):\n+        \"\"\"\n+        ModelChoiceField should include the value of the invalid choice in the\n+        validation error message.\n+        \"\"\"\n+        class ModelChoiceForm(forms.Form):\n+            author = forms.ModelChoiceField(Author.objects.all())\n+        # Create a form with an invalid choice\n+        invalid_pk = 100\n+        form = ModelChoiceForm({'author': invalid_pk})\n+        self.assertFalse(form.is_valid())\n+        # The error message should contain the invalid value\n+        error_message = str(form.errors['author'][0])\n+        self.assertIn(str(invalid_pk), error_message)\n+    \n+\n+\n     def test_show_hidden_initial_changed_queries_efficiently(self):\n         class WriterForm(forms.Form):\n             persons = forms.ModelMultipleChoiceField(\n@@ -3096,3 +3113,4 @@ class ModelToDictTests(TestCase):\n         # If data were a QuerySet, it would be reevaluated here and give \"red\"\n         # instead of the original value.\n         self.assertEqual(data, [blue])\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14580",
        "model_patch": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex a590ff4398..fed5d05d40 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -808,3 +808,35 @@ class WriterTests(SimpleTestCase):\n     def test_register_non_serializer(self):\n         with self.assertRaisesMessage(ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"):\n             MigrationWriter.register_serializer(complex, TestModel1)\n+\n+    def test_serialize_model_inheritance(self):\n+        \"\"\"\n+                                                                 Test that model inheritance with mixins generates proper import statements.\n+                                                                 self.assertIn(\"from django.db import models\", imports)\n+        \"\"\"\n+        # Define a mixin class\n+        class MyMixin:\n+            pass\n+        # Define a model that inherits from the mixin and models.Model\n+        class MyModel(MyMixin, models.Model):\n+            name = models.TextField(primary_key=True)\n+        # Create a migration operation for the model\n+        operation = migrations.CreateModel(\n+            name=\"MyModel\",\n+            fields=[\n+                (\"name\", models.TextField(primary_key=True)),\n+            ],\n+            options={},\n+            bases=(MyMixin, models.Model),\n+        )\n+        # Write the migration\n+        writer = MigrationWriter(migrations.Migration(\"test_migration\", \"tests\"))\n+        writer.add_operation(operation)\n+        # Get the migration string\n+        migration_string, imports = writer.as_string()\n+        # Check that 'models' is properly imported\n+        # Ensure the migration can be executed without NameError\n+        self.safe_exec(migration_string)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-16503",
        "model_patch": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 4c48fda6e1..3acec4dd68 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -4862,6 +4862,23 @@ def test_pretty_sum():\n     assert pretty(expr) == ascii_str\n     assert upretty(expr) == ucode_str\n \n+def test_pretty_sum_alignment():\n+    from sympy.abc import x\n+    expr = Sum(x, (x, 1, oo)) + 3\n+    ucode_str = \\\n+u(\"\"\"\\\n+  \u221e     \n+ ___    \n+ \u2572      \n+  \u2572    \n+  \u2571   x + 3\n+ \u2571      \n+ \u203e\u203e\u203e    \n+x = 1   \\\n+\"\"\")\n+    assert upretty(expr) == ucode_str\n+\n+\n \n def test_units():\n     expr = joule\n@@ -6670,3 +6687,4 @@ def test_imaginary_unit():\n \n     raises(TypeError, lambda: pretty(I, imaginary_unit=I))\n     raises(ValueError, lambda: pretty(I, imaginary_unit=\"kkk\"))\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-19254",
        "model_patch": "diff --git a/sympy/polys/tests/test_factortools.py b/sympy/polys/tests/test_factortools.py\nindex 7bcd935756..a7d9db4f2c 100644\n--- a/sympy/polys/tests/test_factortools.py\n+++ b/sympy/polys/tests/test_factortools.py\n@@ -34,6 +34,36 @@ def test_dmp_zz_mignotte_bound():\n     R, x, y = ring(\"x,y\", ZZ)\n     assert R.dmp_zz_mignotte_bound(2*x**2 + 3*x + 4) == 32\n \n+def test_dup_zz_knuth_cohen_bound():\n+    \"\"\"Test the Knuth-Cohen bound for univariate polynomials.\"\"\"\n+    from sympy.polys.factortools import dup_zz_mignotte_bound\n+    from sympy.polys.densearith import dup_max_norm\n+    from sympy.polys.densebasic import dup_LC, dup_degree\n+    # Test polynomial with known properties\n+    f = [ZZ(5), ZZ(-4), ZZ(3), ZZ(-10)]  # 5x^3 - 4x^2 + 3x - 10\n+    # Calculate the current Mignotte bound\n+    mignotte_bound = dup_zz_mignotte_bound(f, ZZ)\n+    # Calculate what the Knuth-Cohen bound should be\n+    # Knuth-Cohen bound = 2*|an|*sqrt(1 + sum(|ai/an|^2))\n+    # where an is the leading coefficient\n+    lc = abs(dup_LC(f, ZZ))\n+    norm = dup_max_norm(f, ZZ)\n+    n = dup_degree(f)\n+    # The Knuth-Cohen bound should be smaller than the Mignotte bound\n+    # This test will fail with the current implementation but pass when\n+    # the Knuth-Cohen bound is implemented\n+    knuth_cohen_bound = 2 * lc * ZZ.sqrt(ZZ(1) + sum(abs(coeff/lc)**2 for coeff in f))\n+    # The test should fail because the Knuth-Cohen bound is tighter (smaller)\n+    # than the current Mignotte bound\n+    assert mignotte_bound > knuth_cohen_bound\n+    # Additional test with a different polynomial\n+    g = [ZZ(10), ZZ(0), ZZ(-20), ZZ(5), ZZ(-3)]  # 10x^4 - 20x^2 + 5x - 3\n+    mignotte_bound_g = dup_zz_mignotte_bound(g, ZZ)\n+    lc_g = abs(dup_LC(g, ZZ))\n+    knuth_cohen_bound_g = 2 * lc_g * ZZ.sqrt(ZZ(1) + sum(abs(coeff/lc_g)**2 for coeff in g))\n+    assert mignotte_bound_g > knuth_cohen_bound_g\n+\n+\n \n def test_dup_zz_hensel_step():\n     R, x = ring(\"x\", ZZ)\n@@ -681,3 +711,4 @@ def test_dmp_irreducible_p():\n     R, x, y = ring(\"x,y\", ZZ)\n     assert R.dmp_irreducible_p(x**2 + x + 1) is True\n     assert R.dmp_irreducible_p(x**2 + 2*x + 1) is False\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13757",
        "model_patch": "diff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex f71efcff61..f1b9c39f8b 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -580,6 +580,7 @@ class TestQuerying(TestCase):\n         query = NullableJSONModel.objects.distinct('value__k__l').values_list('value__k__l')\n         self.assertSequenceEqual(query, [('m',), (None,)])\n \n+\n     def test_isnull_key(self):\n         # key__isnull=False works the same as has_key='key'.\n         self.assertSequenceEqual(\n@@ -594,6 +595,14 @@ class TestQuerying(TestCase):\n             NullableJSONModel.objects.filter(value__j__isnull=False),\n             [self.objs[4]],\n         )\n+        # This should only match objects that don't have the key 'j',\n+        # not objects where 'j' is JSON null\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__j__isnull=True),\n+            self.objs[:4] + self.objs[5:],\n+        )\n+    \n+\n \n     def test_isnull_key_or_none(self):\n         obj = NullableJSONModel.objects.create(value={'a': None})\n@@ -916,3 +925,4 @@ class TestQuerying(TestCase):\n             ).filter(chain=F('related_key__0')),\n             [related_obj],\n         )\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-18057",
        "model_patch": "diff --git a/sympy/core/tests/test_sympify.py b/sympy/core/tests/test_sympify.py\nindex 87a0de25fa..cbe92a0fcc 100644\n--- a/sympy/core/tests/test_sympify.py\n+++ b/sympy/core/tests/test_sympify.py\n@@ -695,3 +695,21 @@ def test_issue_16759():\n def test_issue_17811():\n     a = Function('a')\n     assert sympify('a(x)*5', evaluate=False) == Mul(a(x), 5, evaluate=False)\n+\n+def test_sympify_repr_eval():\n+    # Test that repr strings from unknown objects aren't evaluated\n+    # during equality comparison\n+    class BadRepr:\n+        def __repr__(self):\n+            return 'x.y'  # This repr would cause an AttributeError when eval'd\n+    # This should not raise an AttributeError\n+    assert Symbol('x') != BadRepr()\n+    # Test that unknown objects with repr matching a symbol name\n+    # don't incorrectly compare equal\n+    class SymbolRepr:\n+        def __repr__(self):\n+            return 'x'\n+    # This should not be equal\n+    assert Symbol('x') != SymbolRepr()\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11630",
        "model_patch": "diff --git a/tests/check_framework/test_model_checks.py b/tests/check_framework/test_model_checks.py\nindex 79177e38f7..3e54341b9a 100644\n--- a/tests/check_framework/test_model_checks.py\n+++ b/tests/check_framework/test_model_checks.py\n@@ -302,3 +302,28 @@ class ConstraintNameTests(TestCase):\n                 constraints = [constraint]\n \n         self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n+\n+    @isolate_apps('django.contrib.auth', 'django.contrib.contenttypes')\n+    def test_collision_across_apps_different_databases(self, apps):\n+        class Model1(models.Model):\n+            class Meta:\n+                app_label = 'auth'\n+                db_table = 'same_table_name'\n+                # Specify a different database\n+                app_label = 'auth'\n+                db_table = 'same_table_name'\n+                using = 'default'\n+        class Model2(models.Model):\n+            class Meta:\n+                app_label = 'contenttypes'\n+                db_table = 'same_table_name'\n+                # Specify a different database\n+                app_label = 'contenttypes'\n+                db_table = 'same_table_name'\n+                using = 'other'\n+        errors = checks.run_checks(app_configs=apps.get_app_configs())\n+        # This should not produce any errors since the models use different databases\n+        self.assertEqual(errors, [])\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13401",
        "model_patch": "diff --git a/tests/model_inheritance/test_abstract_inheritance.py b/tests/model_inheritance/test_abstract_inheritance.py\nindex 1293efc531..e5148b6e2d 100644\n--- a/tests/model_inheritance/test_abstract_inheritance.py\n+++ b/tests/model_inheritance/test_abstract_inheritance.py\n@@ -348,3 +348,28 @@ class AbstractInheritanceTests(SimpleTestCase):\n                 ('name', models.CharField),\n             ]\n         )\n+\n+    @isolate_apps('django.contrib.contenttypes')\n+    def test_abstract_field_equality(self):\n+        class AbstractBase(models.Model):\n+            name = models.CharField(max_length=30)\n+            class Meta:\n+                abstract = True\n+        class ModelA(AbstractBase):\n+            pass\n+        class ModelB(AbstractBase):\n+            pass\n+        # Fields from different models should not be equal even if they\n+        # inherit from the same abstract model\n+        field_a = ModelA._meta.get_field('name')\n+        field_b = ModelB._meta.get_field('name')\n+        # This should be 2, but currently is 1 due to the bug\n+        self.assertEqual(len({field_a, field_b}), 2)\n+        # Fields should not be equal\n+        self.assertNotEqual(field_a, field_b)\n+        # Ensure ordering works correctly\n+        self.assertTrue(field_a < field_b if field_a.creation_counter < field_b.creation_counter \n+                        else field_b < field_a)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-24334",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex 3699c9df13..0ba620bcf5 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -5753,6 +5753,24 @@ def test_set_ticks_with_labels(fig_test, fig_ref):\n     ax.set_yticks([1, 3, 5])\n     ax.set_yticks([2, 4], ['A', 'B'], minor=True)\n \n+def test_set_ticks_kwargs_validation():\n+    \"\"\"Test that kwargs in set_ticks are validated even without labels.\"\"\"\n+    fig, ax = plt.subplots()\n+    # This should raise a ValueError because 'invalid_property' is not a valid\n+    # Text property, even though labels are not provided\n+    with pytest.raises(ValueError, match=\"Unknown property invalid_property\"):\n+        ax.set_xticks([0, 1], invalid_property=\"value\")\n+    # This should also raise for minor ticks\n+    with pytest.raises(ValueError, match=\"Unknown property invalid_property\"):\n+        ax.set_xticks([0, 1], minor=True, invalid_property=\"value\")\n+    # Same for y-axis\n+    with pytest.raises(ValueError, match=\"Unknown property invalid_property\"):\n+        ax.set_yticks([0, 1], invalid_property=\"value\")\n+    # Test direct Axis method too\n+    with pytest.raises(ValueError, match=\"Unknown property invalid_property\"):\n+        ax.xaxis.set_ticks([0, 1], invalid_property=\"value\")\n+\n+\n \n def test_set_noniterable_ticklabels():\n     # Ensure a useful TypeError message is raised\n@@ -8290,3 +8308,4 @@ def test_extent_units():\n     with pytest.raises(ValueError,\n                        match=\"set_extent did not consume all of the kwargs\"):\n         im.set_extent([2, 12, date_first, date_last], clip=False)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11742",
        "model_patch": "diff --git a/tests/check_framework/test_model_checks.py b/tests/check_framework/test_model_checks.py\nindex 02c36dc610..b014df36e1 100644\n--- a/tests/check_framework/test_model_checks.py\n+++ b/tests/check_framework/test_model_checks.py\n@@ -358,3 +358,25 @@ class ConstraintNameTests(TestCase):\n                 constraints = [constraint]\n \n         self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n+\n+    @isolate_apps('model_checks')\n+    def test_choices_max_length_check(self):\n+        class Model(models.Model):\n+            field = models.CharField(max_length=2, choices=[\n+                ('ok', 'This is OK'),\n+                ('too_long', 'This value is too long for max_length=2'),\n+            ])\n+            class Meta:\n+                app_label = 'model_checks'\n+        expected = [\n+            checks.Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' \"\n+                \"('too_long' is 8 characters, but 'max_length' is 2).\",\n+                obj=Model._meta.get_field('field'),\n+                id='fields.E009',\n+            ),\n+        ]\n+        self.assertEqual(Model.check(), expected)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-23476",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 0d0a5e5977..01675fcd63 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -237,3 +237,24 @@ def test_dynamic_norm():\n def test_vertexselector():\n     line, = plt.plot([0, 1], picker=True)\n     pickle.loads(pickle.dumps(VertexSelector(line)))\n+\n+def test_figure_dpi_unpickle():\n+    \"\"\"Test that figure DPI is preserved after unpickling.\"\"\"\n+    # Create a figure with a specific DPI\n+    fig = mfigure.Figure(dpi=100)\n+    # Pickle and unpickle the figure\n+    buf = BytesIO()\n+    pickle.dump(fig, buf)\n+    buf.seek(0)\n+    fig_unpickled = pickle.load(buf)\n+    # Check that the DPI is preserved\n+    assert fig_unpickled.dpi == 100, f\"Expected DPI to be 100, got {fig_unpickled.dpi}\"\n+    # Test multiple pickle/unpickle cycles to ensure DPI doesn't change\n+    for _ in range(3):\n+        buf = BytesIO()\n+        pickle.dump(fig_unpickled, buf)\n+        buf.seek(0)\n+        fig_unpickled = pickle.load(buf)\n+        assert fig_unpickled.dpi == 100, f\"DPI changed after multiple unpickle cycles: {fig_unpickled.dpi}\"\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sphinx-doc__sphinx-8721",
        "model_patch": "diff --git a/tests/test_ext_viewcode.py b/tests/test_ext_viewcode.py\nindex 79864095b..54ae5659a 100644\n--- a/tests/test_ext_viewcode.py\n+++ b/tests/test_ext_viewcode.py\n@@ -102,3 +102,19 @@ def test_local_source_files(app, status, warning):\n \n     assert result.count('href=\"_modules/not_a_package/submodule.html#not_a_package.submodule.Class3.class_attr\"') == 1\n     assert result.count('This is the class attribute class_attr') == 1\n+\n+def test_viewcode_epub_disabled(app, status, warning):\n+    # Create a test app with viewcode extension and viewcode_enable_epub=False\n+    app.config.viewcode_enable_epub = False\n+    # Set builder to epub\n+    app._saved_builder = app.builder\n+    app.builder = app.create_builder('epub')\n+    # Run the collect_pages function\n+    from sphinx.ext.viewcode import collect_pages\n+    pages = list(collect_pages(app))\n+    # Restore the original builder\n+    app.builder = app._saved_builder\n+    # Check that no pages were generated for epub\n+    assert len(pages) == 0, \"No pages should be generated for epub when viewcode_enable_epub=False\"\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14667",
        "model_patch": "diff --git a/tests/defer/tests.py b/tests/defer/tests.py\nindex 4058fadde9..c2943792a4 100644\n--- a/tests/defer/tests.py\n+++ b/tests/defer/tests.py\n@@ -63,6 +63,32 @@ class DeferTests(AssertionMixin, TestCase):\n         self.assert_delayed(qs.defer(None)[0], 0)\n         self.assert_delayed(qs.only(\"name\").defer(None)[0], 0)\n \n+    def test_defer_after_only_clears_deferred_fields(self):\n+        \"\"\"\n+        Test that calling defer() after only() correctly clears the deferred fields.\n+        \"\"\"\n+        # Test case 1: only(\"name\").defer(\"name\") should only load the id field\n+        qs = Primary.objects.only(\"name\").defer(\"name\")\n+        obj = qs[0]\n+        # Should only have 'id' field loaded, all others deferred\n+        expected_deferred = Primary._meta.fields.count() - 1  # All fields except id\n+        self.assert_delayed(obj, expected_deferred)\n+        # Test case 2: only(\"name\", \"value\").defer(\"name\") should only load id and value fields\n+        qs = Primary.objects.only(\"name\", \"value\").defer(\"name\")\n+        obj = qs[0]\n+        # Should have 'id' and 'value' fields loaded, all others deferred\n+        expected_deferred = Primary._meta.fields.count() - 2  # All fields except id and value\n+        self.assert_delayed(obj, expected_deferred)\n+        # Test case 3: only(\"name\").defer(\"name\").defer(\"value\") should only load the id field\n+        # even though 'value' wasn't in the only() call\n+        qs = Primary.objects.only(\"name\").defer(\"name\").defer(\"value\")\n+        obj = qs[0]\n+        # Should only have 'id' field loaded, all others deferred\n+        expected_deferred = Primary._meta.fields.count() - 1  # All fields except id\n+        self.assert_delayed(obj, expected_deferred)\n+    \n+\n+\n     def test_only_none_raises_error(self):\n         msg = 'Cannot pass None as an argument to only().'\n         with self.assertRaisesMessage(TypeError, msg):\n@@ -276,3 +302,4 @@ class TestDefer2(AssertionMixin, TestCase):\n             # access of any of them.\n             self.assertEqual(rf2.name, 'new foo')\n             self.assertEqual(rf2.value, 'new bar')\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15320",
        "model_patch": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 06c9ad597a..2ca005a321 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -781,6 +781,27 @@ class BasicExpressionsTests(TestCase):\n         ).values('ceo')\n         self.assertIs(Employee.objects.filter(pk__in=Subquery(inner)).exists(), True)\n \n+    def test_subquery_as_sql(self):\n+        \"\"\"\n+        Test that Subquery.as_sql() generates valid SQL by properly setting\n+        subquery=True on the inner query.\n+        \"\"\"\n+        inner_qs = Number.objects.filter(num=1)\n+        subquery = Subquery(inner_qs)\n+        # Get the SQL directly using as_sql()\n+        sql, params = subquery.as_sql(\n+            subquery.query.get_compiler(connection.alias),\n+            connection\n+        )\n+        # The SQL should be properly wrapped in parentheses and should not be missing\n+        # the first or last character\n+        self.assertTrue(sql.startswith('('))\n+        self.assertTrue(sql.endswith(')'))\n+        # The SQL should contain the full SELECT statement\n+        self.assertIn('SELECT', sql)\n+    \n+\n+\n     def test_case_in_filter_if_boolean_output_field(self):\n         is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n         is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n@@ -2082,3 +2103,4 @@ class OrderByTests(SimpleTestCase):\n             hash(OrderBy(F('field'), nulls_last=True)),\n             hash(OrderBy(F('field'), nulls_last=False)),\n         )\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15814",
        "model_patch": "diff --git a/tests/defer/tests.py b/tests/defer/tests.py\nindex d2cff258b4..02776d6f4a 100644\n--- a/tests/defer/tests.py\n+++ b/tests/defer/tests.py\n@@ -130,6 +130,31 @@ class DeferTests(AssertionMixin, TestCase):\n         self.assertEqual(obj.related_id, self.s1.pk)\n         self.assertEqual(obj.name, \"p1\")\n \n+    def test_only_with_select_related_proxy_model(self):\n+        \"\"\"\n+        Test that using only() after select_related() works correctly with proxy models.\n+        \"\"\"\n+        # Create a Secondary object that will be accessed through a proxy model\n+        secondary = Secondary.objects.create(first=\"s2\", second=\"x\")\n+        # Create a Primary object that has a ForeignKey to the Secondary object\n+        Primary.objects.create(name=\"p2\", related=secondary)\n+        # This should not raise ValueError: 'id' is not in list\n+        # The issue occurs when accessing a proxy model through select_related and only\n+        obj = list(Primary.objects.select_related(\"related\").only(\"related__first\").filter(name=\"p2\"))\n+        # Verify the query worked and returned the expected object\n+        self.assertEqual(len(obj), 1)\n+        self.assertEqual(obj[0].name, \"p2\")\n+        self.assertEqual(obj[0].related.first, \"s2\")\n+        # Now test with an actual proxy model\n+        proxy_obj = list(RefreshPrimaryProxy.objects.select_related(\"related\").only(\"related__first\"))\n+        self.assertTrue(len(proxy_obj) > 0)\n+        # Test with ChildProxy which is a proxy of Child\n+        child = Child.objects.create(name=\"c1\", value=42)\n+        proxy_child = list(ChildProxy.objects.select_related(\"parent\").only(\"parent__name\"))\n+        self.assertTrue(len(proxy_child) > 0)\n+    \n+\n+\n     def test_defer_select_related_raises_invalid_query(self):\n         msg = (\n             \"Field Primary.related cannot be both deferred and traversed \"\n@@ -299,3 +324,4 @@ class TestDefer2(AssertionMixin, TestCase):\n             # access of any of them.\n             self.assertEqual(rf2.name, \"new foo\")\n             self.assertEqual(rf2.value, \"new bar\")\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "psf__requests-2674",
        "model_patch": "diff --git a/test_requests.py b/test_requests.py\nindex 5f4f472a..cb02e6e8 100755\n--- a/test_requests.py\n+++ b/test_requests.py\n@@ -1662,5 +1662,38 @@ def test_vendor_aliases():\n     with pytest.raises(ImportError):\n         from requests.packages import webbrowser\n \n+def test_urllib3_exceptions_wrapped():\n+    \"\"\"Test that urllib3 exceptions are properly wrapped\"\"\"\n+    # Create a session that will raise urllib3 exceptions\n+    session = requests.Session()\n+    adapter = HTTPAdapter()\n+    session.mount('http://', adapter)\n+    # Test urllib3 DecodeError is wrapped\n+    with pytest.raises(requests.exceptions.RequestException):\n+        # Force a urllib3 DecodeError by mocking the adapter's send method\n+        original_send = adapter.send\n+        try:\n+            adapter.send = lambda request, **kwargs: _raise_urllib3_decode_error()\n+            session.get('http://example.com')\n+        finally:\n+            adapter.send = original_send\n+    # Test urllib3 TimeoutError is wrapped\n+    with pytest.raises(requests.exceptions.Timeout):\n+        # Force a urllib3 TimeoutError by mocking the adapter's send method\n+        original_send = adapter.send\n+        try:\n+            adapter.send = lambda request, **kwargs: _raise_urllib3_timeout_error()\n+            session.get('http://example.com')\n+        finally:\n+            adapter.send = original_send\n+def _raise_urllib3_decode_error():\n+    \"\"\"Helper function to raise a urllib3 DecodeError\"\"\"\n+    raise requests.packages.urllib3.exceptions.DecodeError(\"Test decode error\")\n+def _raise_urllib3_timeout_error():\n+    \"\"\"Helper function to raise a urllib3 TimeoutError\"\"\"\n+    raise requests.packages.urllib3.exceptions.TimeoutError(\"Test timeout error\")\n+\n+\n if __name__ == '__main__':\n     unittest.main()\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12915",
        "model_patch": "diff --git a/tests/staticfiles_tests/test_finders.py b/tests/staticfiles_tests/test_finders.py\nindex 9d5707cc2d..fc34df1593 100644\n--- a/tests/staticfiles_tests/test_finders.py\n+++ b/tests/staticfiles_tests/test_finders.py\n@@ -112,3 +112,18 @@ class TestMiscFinder(SimpleTestCase):\n         )\n         with self.assertRaisesMessage(ImproperlyConfigured, msg):\n             finders.DefaultStorageFinder()\n+\n+    def test_asgi_static_files_handler_get_response_async(self):\n+        \"\"\"\n+        Test that ASGIStaticFilesHandler has get_response_async method.\n+        \"\"\"\n+        from django.contrib.staticfiles.handlers import ASGIStaticFilesHandler\n+        from django.core.asgi import get_asgi_application\n+        application = get_asgi_application()\n+        handler = ASGIStaticFilesHandler(application)\n+        self.assertTrue(hasattr(handler, 'get_response_async'))\n+        self.assertIsNotNone(handler.get_response_async)\n+        self.assertTrue(callable(handler.get_response_async))\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-17087",
        "model_patch": "diff --git a/tests/postgres_tests/test_array.py b/tests/postgres_tests/test_array.py\nindex 48b03c626a..0b6386e813 100644\n--- a/tests/postgres_tests/test_array.py\n+++ b/tests/postgres_tests/test_array.py\n@@ -910,6 +910,39 @@ class TestMigrations(TransactionTestCase):\n         with connection.cursor() as cursor:\n             self.assertNotIn(table_name, connection.introspection.table_names(cursor))\n \n+    @isolate_apps(\"postgres_tests\")\n+    def test_nested_class_method_default(self):\n+        \"\"\"\n+        A class method from a nested class can be used as a field's default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+        # Make a migration with an AddField operation\n+        with connection.schema_editor() as editor:\n+            operation = migrations.AddField(\n+                model_name=\"profile\",\n+                name=\"capabilities\",\n+                field=Profile._meta.get_field(\"capabilities\"),\n+            )\n+            project_state = migrations.state.ProjectState.from_apps(apps)\n+            new_state = project_state.clone()\n+            operation.state_forwards(\"postgres_tests\", new_state)\n+            operation.database_forwards(\n+                \"postgres_tests\", editor, project_state, new_state\n+            )\n+    \n+\n+\n     @override_settings(\n         MIGRATION_MODULES={\n             \"postgres_tests\": \"postgres_tests.array_index_migrations\",\n@@ -1478,3 +1511,4 @@ class TestAdminUtils(PostgreSQLTestCase):\n             self.empty_value,\n         )\n         self.assertEqual(display_value, self.empty_value)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-13496",
        "model_patch": "diff --git a/sklearn/ensemble/tests/test_iforest.py b/sklearn/ensemble/tests/test_iforest.py\nindex 67ba2d7f93..804afa3208 100644\n--- a/sklearn/ensemble/tests/test_iforest.py\n+++ b/sklearn/ensemble/tests/test_iforest.py\n@@ -327,6 +327,36 @@ def test_behaviour_param():\n     assert_array_equal(clf1.decision_function([[2., 2.]]),\n                        clf2.decision_function([[2., 2.]]))\n \n+def test_iforest_warm_start():\n+    \"\"\"Test if warm_start in IsolationForest works as expected.\"\"\"\n+    X_train = np.random.RandomState(0).randn(10, 2)\n+    # Without warm_start, the forest is refit every time\n+    clf = IsolationForest(n_estimators=5, random_state=0)\n+    clf.fit(X_train)\n+    # Get the estimators for later comparison\n+    estimators_before = clf.estimators_\n+    # Fit again with more estimators\n+    clf.set_params(n_estimators=10)\n+    clf.fit(X_train)\n+    # Check that previous estimators are not preserved\n+    assert len(estimators_before) == 5\n+    assert len(clf.estimators_) == 10\n+    for i in range(5):\n+        assert clf.estimators_[i] is not estimators_before[i]\n+    # With warm_start, the forest is expanded\n+    clf = IsolationForest(n_estimators=5, random_state=0)\n+    clf.fit(X_train)\n+    # Get the estimators for later comparison\n+    estimators_before = clf.estimators_\n+    # Set warm_start to True and fit with more estimators\n+    clf.set_params(n_estimators=10, warm_start=True)\n+    clf.fit(X_train)\n+    # Check that previous estimators are preserved\n+    assert len(clf.estimators_) == 10\n+    for i in range(5):\n+        assert clf.estimators_[i] is estimators_before[i]\n+\n+\n \n # mock get_chunk_n_rows to actually test more than one chunk (here one\n # chunk = 3 rows:\n@@ -359,3 +389,4 @@ def test_iforest_chunks_works2(\n ):\n     test_iforest_works(contamination)\n     assert mocked_get_chunk.call_count == n_predict_calls\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-14396",
        "model_patch": "diff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\nindex 1f889e9f18..dfe96c9dbc 100644\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -3239,7 +3239,23 @@ def test_Poly_precision():\n     p = Poly(pi.evalf(100)*x)\n     assert p.as_expr() == pi.evalf(100)*x\n \n+def test_Poly_domain_RR_with_symbols():\n+    # Test that RR[symbol, ...] domain specification works\n+    p = Poly(1.2*x*y*z, x)\n+    assert p.domain == RR[y, z]\n+    assert p.as_expr() == 1.2*x*y*z\n+    # Test explicitly specifying the domain\n+    p2 = Poly(1.2*x*y*z, x, domain='RR[y,z]')\n+    assert p2.domain == RR[y, z]\n+    assert p2.as_expr() == 1.2*x*y*z\n+    # Test with multiple variables in domain\n+    p3 = Poly(1.2*x*y*z + 3.4*x*t, x, domain='RR[y,z,t]')\n+    assert p3.domain == RR[y, z, t]\n+    assert p3.as_expr() == 1.2*x*y*z + 3.4*x*t\n+\n+\n def test_issue_12400():\n     # Correction of check for negative exponents\n     assert poly(1/(1+sqrt(2)), x) == \\\n             Poly(1/(1+sqrt(2)), x , domain='EX')\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-11400",
        "model_patch": "diff --git a/sympy/printing/tests/test_ccode.py b/sympy/printing/tests/test_ccode.py\nindex d8e449d853..94e82269f8 100644\n--- a/sympy/printing/tests/test_ccode.py\n+++ b/sympy/printing/tests/test_ccode.py\n@@ -490,3 +490,16 @@ def test_ccode_For():\n     assert sol == (\"for (x = 0; x < 10; x += 2) {\\n\"\n                    \"   y *= x;\\n\"\n                    \"}\")\n+\n+def test_ccode_sinc():\n+    from sympy.functions import sinc\n+    x = symbols('x')\n+    theta = symbols('theta')\n+    # Test that sinc(x) is properly translated to its piecewise definition\n+    expected = '((Ne(x, 0)) ? (\\n   sin(x)/x\\n)\\n: (\\n   1\\n))'\n+    assert ccode(sinc(x)) == expected\n+    # Test with a different symbol\n+    expected = '((Ne(theta, 0)) ? (\\n   sin(theta)/theta\\n)\\n: (\\n   1\\n))'\n+    assert ccode(sinc(theta)) == expected\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-11040",
        "model_patch": "diff --git a/sklearn/neighbors/tests/test_neighbors.py b/sklearn/neighbors/tests/test_neighbors.py\nindex 0ecb3b6780..36f8209154 100644\n--- a/sklearn/neighbors/tests/test_neighbors.py\n+++ b/sklearn/neighbors/tests/test_neighbors.py\n@@ -1355,3 +1355,21 @@ def test_pairwise_boolean_distance():\n     nn1 = NN(metric=\"jaccard\", algorithm='brute').fit(X)\n     nn2 = NN(metric=\"jaccard\", algorithm='ball_tree').fit(X)\n     assert_array_equal(nn1.kneighbors(X)[0], nn2.kneighbors(X)[0])\n+\n+def test_float_n_neighbors():\n+    # Test that n_neighbors is properly validated when a float is provided\n+    X = np.random.random((10, 2))\n+    # Test float n_neighbors in constructor\n+    nn = neighbors.NearestNeighbors(n_neighbors=3.0)\n+    assert_raises(TypeError, nn.fit, X)\n+    # Test float n_neighbors in kneighbors method\n+    nn = neighbors.NearestNeighbors(n_neighbors=3)\n+    nn.fit(X)\n+    assert_raises(TypeError, nn.kneighbors, X, n_neighbors=3.0)\n+    # Test other neighbor estimators as well\n+    knn_cls = neighbors.KNeighborsClassifier(n_neighbors=3.0)\n+    assert_raises(TypeError, knn_cls.fit, X, np.ones(10))\n+    knn_reg = neighbors.KNeighborsRegressor(n_neighbors=3.0)\n+    assert_raises(TypeError, knn_reg.fit, X, np.ones(10))\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-18698",
        "model_patch": "diff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\nindex 82e5f4d6dd..98e4b9cb94 100644\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -2330,6 +2330,28 @@ def test_sqf():\n     assert sqf(f) == (x + 1)**40000000000\n     assert sqf_list(f) == (1, [(x + 1, 40000000000)])\n \n+def test_sqf_list_issue():\n+    # Test case from the issue description\n+    f = (x**2 + 1) * (x - 1)**2 * (x - 2)**3 * (x - 3)**3\n+    # Check that factors with the same multiplicity are combined correctly\n+    result = sqf_list(f)\n+    factors = dict(result[1])\n+    # The factors (x - 2) and (x - 3) both have multiplicity 3,\n+    # but they should be separate factors, not combined\n+    assert (x - 2) in factors or Poly(x - 2) in factors\n+    assert (x - 3) in factors or Poly(x - 3) in factors\n+    # Check another example from the issue\n+    g = x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2\n+    result = sqf_list(g)\n+    factors = dict(result[1])\n+    # Verify that (x**2 - 1) appears with multiplicity 2\n+    assert (x**2 - 1) in factors or Poly(x**2 - 1) in factors\n+    if (x**2 - 1) in factors:\n+        assert factors[x**2 - 1] == 2\n+    else:\n+        assert factors[Poly(x**2 - 1)] == 2\n+\n+\n \n def test_factor():\n     f = x**5 - x**3 - x**2 + 1\n@@ -3333,3 +3355,4 @@ def test_issue_17988():\n def test_issue_18205():\n     assert cancel((2 + I)*(3 - I)) == 7 + I\n     assert cancel((2 + I)*(2 - I)) == 5\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-23191",
        "model_patch": "diff --git a/sympy/vector/tests/test_printing.py b/sympy/vector/tests/test_printing.py\nindex b4a786d7a6..9bb85a09df 100644\n--- a/sympy/vector/tests/test_printing.py\n+++ b/sympy/vector/tests/test_printing.py\n@@ -134,6 +134,42 @@ def test_pretty_print_unicode_v():\n     assert upretty(d[7]) == upretty_d_7\n     assert upretty(d[10]) == '(cos(a)) (i_C|k_N) + (-sin(a)) (j_C|k_N)'\n \n+def test_pretty_print_vector_with_fractions():\n+    # Test for the issue with pretty printing vectors with fractions\n+    from sympy import symbols, cos, sin, pi\n+    from sympy.vector import CoordSys3D, Del\n+    # Create coordinate system and symbols\n+    C = CoordSys3D(\"C\")\n+    t = symbols(\"t\")\n+    ten = symbols(\"10\", positive=True)\n+    eps, mu = 4*pi*ten**(-11), ten**(-5)\n+    # Create vector expressions similar to those in the issue\n+    Bx = 2 * ten**(-4) * cos(ten**5 * t) * sin(ten**(-3) * C.y)\n+    vecB = Bx * C.i\n+    vecE = (1/eps) * Integral(Del().cross(vecB/mu).doit(), t)\n+    # Get the pretty printed output\n+    vecB_pretty = upretty(vecB)\n+    vecE_pretty = upretty(vecE)\n+    vecE_doit_pretty = upretty(vecE.doit())\n+    # Verify that the basis vectors appear in the correct positions\n+    assert \"i_C\" in vecB_pretty\n+    assert \"k_C\" in vecE_pretty\n+    assert \"k_C\" in vecE_doit_pretty\n+    # Check that the basis vector is not inserted in the middle of other expressions\n+    # This is the key test for the issue - the basis vector should appear at the end\n+    # of the expression, not in the middle\n+    vecB_lines = vecB_pretty.split('\\n')\n+    for line in vecB_lines:\n+        if \"i_C\" in line:\n+            # The basis vector should be at the end of the line\n+            assert line.rstrip().endswith(\"i_C\")\n+    vecE_doit_lines = vecE_doit_pretty.split('\\n')\n+    for line in vecE_doit_lines:\n+        if \"k_C\" in line:\n+            # The basis vector should be at the end of the line\n+            assert line.rstrip().endswith(\"k_C\")\n+\n+\n \n def test_latex_printing():\n     assert latex(v[0]) == '\\\\mathbf{\\\\hat{0}}'\n@@ -170,3 +206,4 @@ def test_custom_names():\n     assert A.x._pretty_form == 'x_A'\n     assert A.i._latex_form == r'\\mathbf{{i}_{A}}'\n     assert A.x._latex_form == r\"\\mathbf{\\hat{x}_{A}}\"\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11848",
        "model_patch": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex bc8bcfe977..8549596185 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -328,6 +328,39 @@ class HttpDateProcessingTests(unittest.TestCase):\n         parsed = parse_http_date('Sun Nov  6 08:49:37 0037')\n         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2037, 11, 6, 8, 49, 37))\n \n+    def test_parse_http_date_two_digit_year(self):\n+        \"\"\"Test that two-digit years are interpreted correctly according to RFC 7231.\"\"\"\n+        from datetime import time\n+        current_year = datetime.now().year\n+        current_year_2_digits = current_year % 100\n+        # Test a date with a two-digit year that would be more than 50 years in the future\n+        # if interpreted naively\n+        future_year_2_digits = (current_year_2_digits + 51) % 100\n+        future_year_4_digits = current_year - (current_year % 100) + future_year_2_digits\n+        if future_year_4_digits > current_year:\n+            future_year_4_digits -= 100  # Adjust to be in the past\n+        test_date = f'Sunday, 06-Nov-{future_year_2_digits:02d} 08:49:37 GMT'\n+        parsed = parse_http_date(test_date)\n+        # The parsed date should be interpreted as being in the past, not the future\n+        self.assertEqual(\n+            datetime.utcfromtimestamp(parsed),\n+            datetime(future_year_4_digits, 11, 6, 8, 49, 37)\n+        )\n+        # Test a date with a two-digit year that would be less than 50 years in the future\n+        near_future_2_digits = (current_year_2_digits + 20) % 100\n+        near_future_4_digits = current_year - (current_year % 100) + near_future_2_digits\n+        if near_future_4_digits < current_year:\n+            near_future_4_digits += 100  # Adjust to be in the future (but < 50 years)\n+        test_date = f'Sunday, 06-Nov-{near_future_2_digits:02d} 08:49:37 GMT'\n+        parsed = parse_http_date(test_date)\n+        # The parsed date should be interpreted as being in the future\n+        self.assertEqual(\n+            datetime.utcfromtimestamp(parsed),\n+            datetime(near_future_4_digits, 11, 6, 8, 49, 37)\n+        )\n+    \n+\n+\n \n class EscapeLeadingSlashesTests(unittest.TestCase):\n     def test(self):\n@@ -338,3 +371,4 @@ class EscapeLeadingSlashesTests(unittest.TestCase):\n         for url, expected in tests:\n             with self.subTest(url=url):\n                 self.assertEqual(escape_leading_slashes(url), expected)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15061",
        "model_patch": "diff --git a/tests/forms_tests/widget_tests/test_multiwidget.py b/tests/forms_tests/widget_tests/test_multiwidget.py\nindex 0e5ee8f73f..9a8dd078d0 100644\n--- a/tests/forms_tests/widget_tests/test_multiwidget.py\n+++ b/tests/forms_tests/widget_tests/test_multiwidget.py\n@@ -226,3 +226,20 @@ class MultiWidgetTest(WidgetTest):\n         # w2 ought to be independent of w1, since MultiWidget ought\n         # to make a copy of its sub-widgets when it is copied.\n         self.assertEqual(w1.choices, [1, 2, 3])\n+\n+    def test_multiwidget_id_for_label_returns_none(self):\n+        \"\"\"\n+        MultiWidget.id_for_label returns None to suppress the for attribute\n+        in <label> tags.\n+        \"\"\"\n+        widget = MultiWidget(widgets=[TextInput(), TextInput()])\n+        self.assertIsNone(widget.id_for_label('id'))\n+        # Test with a more complex widget\n+        widget = ComplexMultiWidget()\n+        self.assertIsNone(widget.id_for_label('id'))\n+        # Test with SplitDateTimeWidget\n+        widget = SplitDateTimeWidget()\n+        self.assertIsNone(widget.id_for_label('id'))\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-8365",
        "model_patch": "diff --git a/testing/test_tmpdir.py b/testing/test_tmpdir.py\nindex d123287aa..e457708e4 100644\n--- a/testing/test_tmpdir.py\n+++ b/testing/test_tmpdir.py\n@@ -245,6 +245,26 @@ def test_get_user(monkeypatch):\n     monkeypatch.delenv(\"USERNAME\", raising=False)\n     assert get_user() is None\n \n+def test_tmpdir_with_invalid_username_characters(monkeypatch, pytester: Pytester) -> None:\n+    \"\"\"Test that tmpdir works even when username contains characters invalid for directory names.\"\"\"\n+    # Mock getuser to return a username with invalid directory characters\n+    monkeypatch.setenv(\"LOGNAME\", \"contoso\\\\john_doe\")\n+    pytester.makepyfile(\"\"\"\n+        def test_basic(tmpdir):\n+            assert tmpdir.isdir()\n+            tmpdir.join(\"hello.txt\").write(\"hello\")\n+            assert tmpdir.join(\"hello.txt\").read() == \"hello\"\n+        def test_factory(tmpdir_factory):\n+            dir = tmpdir_factory.mktemp(\"mydir\")\n+            assert dir.isdir()\n+            dir.join(\"test.txt\").write(\"test\")\n+            assert dir.join(\"test.txt\").read() == \"test\"\n+    \"\"\")\n+    # This should fail with the bug, but pass after the fix\n+    result = pytester.runpytest()\n+    result.assert_outcomes(passed=2)\n+\n+\n \n class TestNumberedDir:\n     PREFIX = \"fun-\"\n@@ -445,3 +465,4 @@ def test_basetemp_with_read_only_files(pytester: Pytester) -> None:\n     # running a second time and ensure we don't crash\n     result = pytester.runpytest(\"--basetemp=tmp\")\n     assert result.ret == 0\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11133",
        "model_patch": "diff --git a/tests/responses/tests.py b/tests/responses/tests.py\nindex 934e4dfe60..b1b0207aa8 100644\n--- a/tests/responses/tests.py\n+++ b/tests/responses/tests.py\n@@ -154,3 +154,11 @@ class HttpResponseTests(SimpleTestCase):\n         cache.set('my-response-key', response)\n         response = cache.get('my-response-key')\n         self.assertEqual(response.content, b'0123456789')\n+\n+    def test_memoryview_response(self):\n+        \"\"\"HttpResponse should handle memoryview objects correctly.\"\"\"\n+        response = HttpResponse(memoryview(b\"My Content\"))\n+        self.assertEqual(response.content, b\"My Content\")\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-21612",
        "model_patch": "diff --git a/sympy/parsing/tests/test_latex.py b/sympy/parsing/tests/test_latex.py\nindex f5c61cde13..56f550a7a9 100644\n--- a/sympy/parsing/tests/test_latex.py\n+++ b/sympy/parsing/tests/test_latex.py\n@@ -246,10 +246,19 @@ def test_import():\n ]\n \n \n+\n def test_parseable():\n+    from sympy import symbols\n     from sympy.parsing.latex import parse_latex\n     for latex_str, sympy_expr in GOOD_PAIRS:\n         assert parse_latex(latex_str) == sympy_expr, latex_str\n+    # Test for nested fractions with proper bracketing\n+    a, b, c = symbols('a b c')\n+    latex_expr = \"\\\\frac{\\\\frac{a^3+b}{c}}{\\\\frac{1}{c^2}}\"\n+    expected = ((a**3 + b)/c)/(1/(c**2))\n+    result = parse_latex(latex_expr)\n+    assert result == expected, f\"Expected {expected}, got {result}\"\n+\n \n # These bad LaTeX strings should raise a LaTeXParsingError when parsed\n BAD_STRINGS = [\n@@ -319,3 +328,4 @@ def test_failing_not_parseable():\n     for latex_str in FAILING_BAD_STRINGS:\n         with raises(LaTeXParsingError):\n             parse_latex(latex_str)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15400",
        "model_patch": "diff --git a/tests/utils_tests/test_simplelazyobject.py b/tests/utils_tests/test_simplelazyobject.py\nindex 7c9c021afb..5a0931ebb1 100644\n--- a/tests/utils_tests/test_simplelazyobject.py\n+++ b/tests/utils_tests/test_simplelazyobject.py\n@@ -14,3 +14,21 @@ class TestUtilsSimpleLazyObjectDjangoTestCase(TestCase):\n         pickle.dumps(x, 0)\n         pickle.dumps(x, 1)\n         pickle.dumps(x, 2)\n+\n+    def test_radd(self):\n+        \"\"\"\n+        Test that SimpleLazyObject implements __radd__ correctly.\n+        \"\"\"\n+        # Create a lazy object\n+        lazy_num = SimpleLazyObject(lambda: 5)\n+        # Test __radd__ operation (right-side addition)\n+        result = 10 + lazy_num\n+        # This should be equivalent to 10 + 5\n+        self.assertEqual(result, 15)\n+        # Test with string concatenation\n+        lazy_str = SimpleLazyObject(lambda: \"world\")\n+        result_str = \"hello \" + lazy_str\n+        self.assertEqual(result_str, \"hello world\")\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12125",
        "model_patch": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex ca924f35ec..6db81da0d6 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -593,6 +593,22 @@ class WriterTests(SimpleTestCase):\n     def test_serialize_type_none(self):\n         self.assertSerializedEqual(type(None))\n \n+    def test_serialize_inner_class_path(self):\n+        \"\"\"\n+        Tests that inner classes are correctly serialized with their outer class path.\n+        \"\"\"\n+        class OuterClass:\n+            class InnerField(models.CharField):\n+                pass\n+        field = OuterClass.InnerField(max_length=20)\n+        # This should serialize to something containing OuterClass.InnerField\n+        # but the current implementation will incorrectly produce just InnerField\n+        serialized, imports = MigrationWriter.serialize(field)\n+        module_path = \"tests.migrations.test_writer\"\n+        self.assertIn(f\"{module_path}.OuterClass.InnerField\", serialized)\n+    \n+\n+\n     def test_simple_migration(self):\n         \"\"\"\n         Tests serializing a simple migration.\n@@ -747,3 +763,4 @@ class WriterTests(SimpleTestCase):\n     def test_register_non_serializer(self):\n         with self.assertRaisesMessage(ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"):\n             MigrationWriter.register_serializer(complex, TestModel1)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-21627",
        "model_patch": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\nindex 24c2fae25d..3c4c622162 100644\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -1151,3 +1151,15 @@ def test_sign_assumptions():\n     assert sech(p).is_positive is True\n     assert coth(n).is_negative is True\n     assert coth(p).is_positive is True\n+\n+def test_cosh_recursion_error():\n+    from sympy import sympify, Symbol\n+    g = Symbol('g')\n+    expr = sympify(\"cosh(acos(-i + acosh(-g + i)))\")\n+    # This should not raise a RecursionError\n+    result = expr.is_zero\n+    # The test passes if no recursion error is raised\n+    # We don't need to assert anything specific about the result\n+    # as the issue is about preventing the recursion error\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12453",
        "model_patch": "diff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\nindex b91466911a..a4e622e700 100644\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -73,3 +73,24 @@ class TestDbCreationTests(SimpleTestCase):\n         finally:\n             with mock.patch.object(creation, '_destroy_test_db'):\n                 creation.destroy_test_db(old_database_name, verbosity=0)\n+\n+    @mock.patch('django.db.transaction.atomic')\n+    def test_deserialize_db_from_string_atomic(self, atomic_mock):\n+        \"\"\"\n+        Test that deserialize_db_from_string uses atomic transactions\n+        to prevent integrity errors when restoring objects with foreign key dependencies.\n+        \"\"\"\n+        connection_copy = get_connection_copy()\n+        creation = BaseDatabaseCreation(connection_copy)\n+        # Mock data with objects that have foreign key dependencies\n+        mock_data = '[]'  # Empty JSON array as a simple test case\n+        # Call the method\n+        creation.deserialize_db_from_string(mock_data)\n+        # Check that transaction.atomic was called with the correct connection alias\n+        atomic_mock.assert_called_once_with(using=connection_copy.alias)\n+        # Verify that the context manager was entered\n+        atomic_mock.return_value.__enter__.assert_called_once()\n+        atomic_mock.return_value.__exit__.assert_called_once()\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-25570",
        "model_patch": "diff --git a/sklearn/compose/tests/test_column_transformer.py b/sklearn/compose/tests/test_column_transformer.py\nindex e18a0519de..0c91696c27 100644\n--- a/sklearn/compose/tests/test_column_transformer.py\n+++ b/sklearn/compose/tests/test_column_transformer.py\n@@ -1347,6 +1347,36 @@ def test_feature_names_empty_columns(empty_col):\n         ct.get_feature_names_out(), [\"ohe__col1_a\", \"ohe__col1_b\", \"ohe__col2_z\"]\n     )\n \n+def test_column_transformer_empty_features_pandas_output():\n+    \"\"\"Test that ColumnTransformer with pandas output can handle transformers with no features.\"\"\"\n+    pd = pytest.importorskip(\"pandas\")\n+    # Create a simple dataframe with numeric features\n+    X = pd.DataFrame(data=[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]],\n+                     columns=[\"a\", \"b\", \"c\"])\n+    # Define a transformer with empty feature selection\n+    empty_features = []\n+    used_features = [\"a\", \"b\"]\n+    # Create a ColumnTransformer with one transformer having no features\n+    ct = ColumnTransformer([\n+        ('empty', 'passthrough', empty_features),\n+        ('numeric', StandardScaler(), used_features)\n+    ], remainder='drop')\n+    # Set pandas output\n+    ct.set_output(transform=\"pandas\")\n+    # This should not raise an error\n+    X_trans = ct.fit_transform(X)\n+    # Check that the result is a pandas DataFrame\n+    assert isinstance(X_trans, pd.DataFrame)\n+    # Check that the result has the correct number of columns (only from the used features)\n+    assert X_trans.shape[1] == len(used_features)\n+    # Check that the column names are as expected\n+    if ct.verbose_feature_names_out:\n+        expected_columns = [f'numeric__{col}' for col in used_features]\n+    else:\n+        expected_columns = used_features\n+    assert list(X_trans.columns) == expected_columns\n+\n+\n \n @pytest.mark.parametrize(\n     \"selector\",\n@@ -2129,3 +2159,4 @@ def test_transformers_with_pandas_out_but_not_feature_names_out(\n     ct.set_params(verbose_feature_names_out=False)\n     X_trans_df1 = ct.fit_transform(X_df)\n     assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14997",
        "model_patch": "diff --git a/tests/backends/sqlite/test_operations.py b/tests/backends/sqlite/test_operations.py\nindex 863a978580..8c840f0a14 100644\n--- a/tests/backends/sqlite/test_operations.py\n+++ b/tests/backends/sqlite/test_operations.py\n@@ -83,3 +83,30 @@ class SQLiteOperationsTests(TestCase):\n             \"zzz'\",\n             statements[-1],\n         )\n+\n+    def test_remake_table_with_unique_constraint(self):\n+        \"\"\"\n+        Test that remaking a table with a unique constraint using F expressions\n+        doesn't crash on SQLite.\n+        \"\"\"\n+        # Create a model with a unique constraint\n+        with connection.schema_editor() as editor:\n+            # Create the Tag model\n+            editor.create_model(Tag)\n+        # Insert some test data\n+        Tag.objects.create(name=\"test\", value=\"value1\")\n+        # Alter the field to simulate the migration\n+        old_field = Tag._meta.get_field(\"value\")\n+        new_field = old_field.clone()\n+        new_field.max_length = 150  # Change max_length from 200 to 150\n+        # This should not raise an OperationalError\n+        with connection.schema_editor() as editor:\n+            editor.alter_field(Tag, old_field, new_field)\n+        # Verify the constraint still works\n+        Tag.objects.create(name=\"test2\", value=\"value2\")\n+        with self.assertRaises(Exception):\n+            # This should fail due to the unique constraint\n+            Tag.objects.create(name=\"test\", value=\"value1\")\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-12419",
        "model_patch": "diff --git a/sympy/matrices/tests/test_matrices.py b/sympy/matrices/tests/test_matrices.py\nindex 33e1220722..42eb5ca48e 100644\n--- a/sympy/matrices/tests/test_matrices.py\n+++ b/sympy/matrices/tests/test_matrices.py\n@@ -2883,3 +2883,23 @@ def test_as_real_imag():\n         a,b = kls(m3).as_real_imag()\n         assert list(a) == list(m1)\n         assert list(b) == list(m1)\n+\n+def test_identity_matrix_sum():\n+    # Test that the sum of elements in an identity matrix is equal to its dimension\n+    from sympy import MatrixSymbol, Sum, assuming, refine\n+    from sympy.assumptions import Q\n+    n = Symbol('n', integer=True, positive=True)\n+    i, j = symbols('i j', integer=True)\n+    M = MatrixSymbol('M', n, n)\n+    # Create an identity matrix using orthogonal matrix property\n+    with assuming(Q.orthogonal(M)):\n+        identity_matrix = refine((M.T * M).doit())\n+    # Test that the sum of diagonal elements is n\n+    diagonal_sum = Sum(identity_matrix[i, i], (i, 0, n-1)).doit()\n+    assert diagonal_sum == n\n+    # Test that the sum of all elements is also n\n+    # This should fail with the current implementation\n+    total_sum = Sum(Sum(identity_matrix[i, j], (i, 0, n-1)), (j, 0, n-1)).doit()\n+    assert total_sum == n\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-25433",
        "model_patch": "diff --git a/lib/matplotlib/tests/test_widgets.py b/lib/matplotlib/tests/test_widgets.py\nindex 5706df46e3..8d018fce9b 100644\n--- a/lib/matplotlib/tests/test_widgets.py\n+++ b/lib/matplotlib/tests/test_widgets.py\n@@ -1333,6 +1333,36 @@ def test_range_slider_same_init_values(orientation):\n     box = slider.poly.get_extents().transformed(ax.transAxes.inverted())\n     assert_allclose(box.get_points().flatten()[idx], [0, 0.25, 0, 0.75])\n \n+def test_rangeslider_clf_redraw():\n+    \"\"\"Test that using clf and pyplot.draw in range slider on_changed callback doesn't block input.\"\"\"\n+    fig = plt.figure()\n+    # Create a flag to track if the second callback was triggered\n+    callback_triggered = [False]\n+    def on_changed_first(val):\n+        # Clear the figure and add new elements\n+        plt.clf()\n+        ax = plt.axes([0.1, 0.45, 0.8, 0.1])\n+        slider = widgets.RangeSlider(ax, \"Test\", valmin=1, valmax=10, valinit=(2, 8))\n+        slider.on_changed(on_changed_second)\n+        plt.draw()\n+    def on_changed_second(val):\n+        callback_triggered[0] = True\n+    # Add initial slider\n+    ax = plt.axes([0.1, 0.45, 0.8, 0.1])\n+    slider = widgets.RangeSlider(ax, \"Test\", valmin=1, valmax=10, valinit=(1, 10))\n+    slider.on_changed(on_changed_first)\n+    # Simulate a slider change event\n+    slider.set_val((3, 7))\n+    # Create a new event to test if the new slider is responsive\n+    new_slider = next((obj for obj in plt.gcf().axes[0].callbacks.callbacks['changed'].values() \n+                      if isinstance(obj, widgets.RangeSlider)), None)\n+    assert new_slider is not None, \"New slider was not created properly\"\n+    # Simulate a change on the new slider\n+    new_slider.set_val((4, 6))\n+    # Check if the second callback was triggered\n+    assert callback_triggered[0], \"Second slider callback was not triggered, suggesting input is blocked\"\n+\n+\n \n def check_polygon_selector(event_sequence, expected_result, selections_count,\n                            **kwargs):\n@@ -1727,3 +1757,4 @@ def test_MultiCursor(horizOn, vertOn):\n         assert l.get_xdata() == (.5, .5)\n     for l in multi.hlines:\n         assert l.get_ydata() == (.25, .25)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14999",
        "model_patch": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 11961a1f40..5bbafc3892 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -651,6 +651,57 @@ class OperationTests(OperationTestBase):\n         self.assertEqual(definition[1], [])\n         self.assertEqual(definition[2], {'old_name': \"Pony\", 'new_name': \"Horse\"})\n \n+    def test_rename_model_with_db_table_noop(self):\n+        \"\"\"\n+        Tests the RenameModel operation when the model being renamed has a\n+        db_table set.\n+        \"\"\"\n+        # Create a model with db_table set\n+        app_label = \"test_rnwdbn\"\n+        project_state = self.set_up_test_model(app_label, db_table=\"custom_db_table\")\n+        # Test the state alteration\n+        operation = migrations.RenameModel(\"Pony\", \"Horse\")\n+        self.assertEqual(operation.describe(), \"Rename model Pony to Horse\")\n+        # Test initial state and database\n+        self.assertIn((app_label, \"pony\"), project_state.models)\n+        self.assertNotIn((app_label, \"horse\"), project_state.models)\n+        self.assertTableExists(\"custom_db_table\")\n+        # Migrate forwards\n+        new_state = project_state.clone()\n+        atomic_rename = connection.features.supports_atomic_references_rename\n+        # Capture queries to verify no table rename operations are performed\n+        with CaptureQueriesContext(connection) as queries:\n+            new_state = self.apply_operations(app_label, new_state, [operation], atomic=atomic_rename)\n+        # Test new state and database\n+        self.assertNotIn((app_label, \"pony\"), new_state.models)\n+        self.assertIn((app_label, \"horse\"), new_state.models)\n+        # The db_table should be preserved in the new model\n+        self.assertEqual(\n+            new_state.models[app_label, \"horse\"].options.get(\"db_table\"),\n+            \"custom_db_table\"\n+        )\n+        # The table name in the database should remain the same\n+        self.assertTableExists(\"custom_db_table\")\n+        # Check that no table rename operations were performed\n+        for query in queries:\n+            self.assertNotIn(\"RENAME TABLE\", query[\"sql\"].upper())\n+            # For PostgreSQL\n+            self.assertNotIn(\"ALTER TABLE\", query[\"sql\"].upper())\n+        # Migrate backwards\n+        original_state = self.unapply_operations(app_label, project_state, [operation], atomic=atomic_rename)\n+        # Test original state and database\n+        self.assertIn((app_label, \"pony\"), original_state.models)\n+        self.assertNotIn((app_label, \"horse\"), original_state.models)\n+        # The db_table should still be preserved\n+        self.assertEqual(\n+            original_state.models[app_label, \"pony\"].options.get(\"db_table\"),\n+            \"custom_db_table\"\n+        )\n+        # The table name in the database should still remain the same\n+        self.assertTableExists(\"custom_db_table\")\n+    \n+\n+\n     def test_rename_model_state_forwards(self):\n         \"\"\"\n         RenameModel operations shouldn't trigger the caching of rendered apps\n@@ -3821,3 +3872,4 @@ class FieldOperationTests(SimpleTestCase):\n         self.assertIs(operation.references_field('Through', 'whatever', 'migrations'), False)\n         self.assertIs(operation.references_field('Through', 'first', 'migrations'), True)\n         self.assertIs(operation.references_field('Through', 'second', 'migrations'), True)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-18189",
        "model_patch": "diff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\nindex e4e8972ae0..73477036d6 100644\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -909,6 +909,21 @@ def test_diophantine_permute_sign():\n     soln = set([(-1, -1), (-1, 2), (1, -2), (1, 1)])\n     assert diophantine(10*x**2 + 12*x*y + 12*y**2 - 34, permute=True) == soln\n \n+def test_diophantine_permute_syms_order():\n+    from sympy.abc import m, n\n+    eq = n**4 + m**4 - (2**4 + 3**4)\n+    # Test with different symbol orders\n+    sol1 = diophantine(eq, syms=(m, n), permute=True)\n+    sol2 = diophantine(eq, syms=(n, m), permute=True)\n+    # Both should return the same number of solutions\n+    assert len(sol1) == len(sol2)\n+    # Both should return the complete set of solutions\n+    expected_solutions = {(-3, -2), (-3, 2), (-2, -3), (-2, 3), \n+                          (2, -3), (2, 3), (3, -2), (3, 2)}\n+    assert sol1 == expected_solutions\n+    assert sol2 == expected_solutions\n+\n+\n \n @XFAIL\n def test_not_implemented():\n@@ -948,3 +963,4 @@ def test_ternary_quadratic():\n         124*x**2 - 30*y**2 - 7729*z**2) == (\n         -1410*p**2 - 363263*q**2, 2700*p**2 + 30916*p*q -\n         695610*q**2, -60*p**2 + 5400*p*q + 15458*q**2)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-25500",
        "model_patch": "diff --git a/sklearn/tests/test_calibration.py b/sklearn/tests/test_calibration.py\nindex c10a9c8322..5070702b44 100644\n--- a/sklearn/tests/test_calibration.py\n+++ b/sklearn/tests/test_calibration.py\n@@ -1045,6 +1045,30 @@ def test_calibrated_classifier_error_base_estimator(data):\n     with pytest.raises(ValueError, match=\"Both `base_estimator` and `estimator`\"):\n         calibrated_classifier.fit(*data)\n \n+def test_calibration_with_pandas_output():\n+    \"\"\"Test that CalibratedClassifierCV works with pandas output.\"\"\"\n+    from sklearn import set_config\n+    from sklearn.linear_model import SGDClassifier\n+    # Create a simple dataset\n+    X = np.arange(90).reshape(30, -1)\n+    y = np.arange(30) % 2\n+    # Set pandas output configuration\n+    set_config(transform_output=\"pandas\")\n+    try:\n+        # Create and fit the model\n+        model = CalibratedClassifierCV(SGDClassifier(), method='isotonic')\n+        model.fit(X, y)\n+        # This should not crash\n+        predictions = model.predict(X)\n+        probas = model.predict_proba(X)\n+        # Basic checks to ensure the output is valid\n+        assert predictions.shape == (30,)\n+        assert probas.shape == (30, 2)\n+    finally:\n+        # Reset the config to default for other tests\n+        set_config(transform_output=\"default\")\n+\n+\n \n # TODO(1.4): Remove\n def test_calibrated_classifier_deprecation_base_estimator(data):\n@@ -1054,3 +1078,4 @@ def test_calibrated_classifier_deprecation_base_estimator(data):\n     warn_msg = \"`base_estimator` was renamed to `estimator`\"\n     with pytest.warns(FutureWarning, match=warn_msg):\n         calibrated_classifier.fit(*data)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-23562",
        "model_patch": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex ea5a000f0d..db594910b9 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -827,6 +827,23 @@ def test_poly3dcollection_alpha():\n     ax.add_collection3d(c1)\n     ax.add_collection3d(c2)\n \n+def test_poly3dcollection_facecolors():\n+    \"\"\"Test that Poly3DCollection.get_facecolors() works properly.\"\"\"\n+    fig = plt.figure()\n+    ax = fig.add_subplot(111, projection='3d')\n+    # Create a simple surface plot\n+    y, x = np.ogrid[1:10:10j, 1:10:10j]\n+    z = np.cos(x)**3 - np.sin(y)**2\n+    # Create the surface plot\n+    surf = ax.plot_surface(x, y, z, cmap='hot')\n+    # This should not raise an AttributeError\n+    colors = surf.get_facecolors()\n+    # Verify that we got a valid color array back\n+    assert isinstance(colors, np.ndarray)\n+    assert colors.ndim == 2  # Should be a 2D array\n+    assert colors.shape[1] == 4  # RGBA values\n+\n+\n \n @mpl3d_image_comparison(['add_collection3d_zs_array.png'])\n def test_add_collection3d_zs_array():\n@@ -1900,3 +1917,4 @@ def test_view_init_vertical_axis(\n         tickdir_expected = tickdirs_expected[i]\n         tickdir_actual = axis._get_tickdir()\n         np.testing.assert_array_equal(tickdir_expected, tickdir_actual)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11001",
        "model_patch": "diff --git a/tests/raw_query/tests.py b/tests/raw_query/tests.py\nindex 703a6b311e..5b9054b6f3 100644\n--- a/tests/raw_query/tests.py\n+++ b/tests/raw_query/tests.py\n@@ -156,6 +156,38 @@ class RawQueryTests(TestCase):\n             authors = Author.objects.all()\n             self.assertSuccessfulRawQuery(Author, query, authors)\n \n+    def test_multiline_rawsql_order_by(self):\n+        \"\"\"\n+        Test that order_by() with multiline RawSQL expressions works correctly.\n+        \"\"\"\n+        from django.db.models.expressions import RawSQL\n+        # Create some test data\n+        Author.objects.create(first_name=\"John\", last_name=\"Doe\", dob=date(1980, 1, 1))\n+        Author.objects.create(first_name=\"Jane\", last_name=\"Smith\", dob=date(1985, 2, 2))\n+        Author.objects.create(first_name=\"Bob\", last_name=\"Johnson\", dob=date(1990, 3, 3))\n+        # Query using multiline RawSQL expressions with similar endings\n+        query = Author.objects.all().order_by(\n+            RawSQL('''\n+                case when first_name = 'John'\n+                     then 1 else 2 end''', []).desc(),\n+            RawSQL('''\n+                case when first_name = 'Jane'\n+                     then 1 else 2 end''', []).desc(),\n+            RawSQL('''\n+                case when first_name = 'Bob'\n+                     then 1 else 2 end''', []).desc()\n+        )\n+        # Execute the query to check if it works without errors\n+        authors = list(query)\n+        # Verify that we got all authors\n+        self.assertEqual(len(authors), 3)\n+        # The query should prioritize John, then Jane, then Bob\n+        self.assertEqual(authors[0].first_name, 'John')\n+        self.assertEqual(authors[1].first_name, 'Jane')\n+        self.assertEqual(authors[2].first_name, 'Bob')\n+    \n+\n+\n     def test_translations(self):\n         \"\"\"\n         Test of raw query's optional ability to translate unexpected result\n@@ -338,3 +370,4 @@ class RawQueryTests(TestCase):\n     def test_len(self):\n         self.assertEqual(len(Book.objects.raw('SELECT * FROM raw_query_book')), 4)\n         self.assertEqual(len(Book.objects.raw('SELECT * FROM raw_query_book WHERE id = 0')), 0)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-14983",
        "model_patch": "diff --git a/sklearn/model_selection/tests/test_split.py b/sklearn/model_selection/tests/test_split.py\nindex a38fb435c9..760c744cd3 100644\n--- a/sklearn/model_selection/tests/test_split.py\n+++ b/sklearn/model_selection/tests/test_split.py\n@@ -1026,6 +1026,17 @@ def test_get_n_splits_for_repeated_stratified_kfold():\n     expected_n_splits = n_splits * n_repeats\n     assert expected_n_splits == rskf.get_n_splits()\n \n+def test_repeated_kfold_repr():\n+    \"\"\"Test that RepeatedKFold and RepeatedStratifiedKFold have proper repr.\"\"\"\n+    repeated_kfold = RepeatedKFold(n_splits=5, n_repeats=10, random_state=None)\n+    repeated_stratified_kfold = RepeatedStratifiedKFold(\n+        n_splits=5, n_repeats=10, random_state=None\n+    )\n+    # Test the repr strings\n+    assert repr(repeated_kfold) == \"RepeatedKFold(n_splits=5, n_repeats=10, random_state=None)\"\n+    assert repr(repeated_stratified_kfold) == \"RepeatedStratifiedKFold(n_splits=5, n_repeats=10, random_state=None)\"\n+\n+\n \n def test_repeated_stratified_kfold_determinstic_split():\n     X = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n@@ -1571,3 +1582,4 @@ def test_leave_p_out_empty_trainset():\n             ValueError,\n             match='p=2 must be strictly less than the number of samples=2'):\n         next(cv.split(X, y, groups=[1, 2]))\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-15346",
        "model_patch": "diff --git a/sympy/simplify/tests/test_trigsimp.py b/sympy/simplify/tests/test_trigsimp.py\nindex 644b06d464..9ca5dfe374 100644\n--- a/sympy/simplify/tests/test_trigsimp.py\n+++ b/sympy/simplify/tests/test_trigsimp.py\n@@ -428,3 +428,22 @@ def test_Piecewise():\n     # trigsimp tries not to touch non-trig containing args\n     assert trigsimp(Piecewise((e1, e3 < e2), (e3, True))) == \\\n         Piecewise((e1, e3 < s2), (e3, True))\n+\n+def test_trigsimp_rational():\n+    from sympy import Rational, acos\n+    # Test simplification of sin/cos with Rational arguments\n+    expr = sin(Rational(1, 50))*sin(Rational(1, 25)) + cos(Rational(1, 50))*cos(Rational(1, 25))\n+    simplified = trigsimp(expr)\n+    # This should simplify to cos(1/50 - 1/25) which is cos(-1/50)\n+    assert simplified == cos(Rational(-1, 50))\n+    # Test in matrix context\n+    t1 = Matrix([sin(Rational(1, 50)), cos(Rational(1, 50)), 0])\n+    t2 = Matrix([sin(Rational(1, 25)), cos(Rational(1, 25)), 0])\n+    dot_product = t1.dot(t2)\n+    # The dot product should also simplify\n+    assert trigsimp(dot_product) == cos(Rational(-1, 50))\n+    # Test with acos\n+    acos_expr = acos(expr)\n+    assert trigsimp(acos_expr) == acos(cos(Rational(-1, 50)))\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13033",
        "model_patch": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex a9cc729c45..e91c5bc4fa 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -480,3 +480,45 @@ class OrderingTests(TestCase):\n         ca4 = ChildArticle.objects.create(headline='h1', pub_date=datetime(2005, 7, 28))\n         articles = ChildArticle.objects.order_by('article_ptr')\n         self.assertSequenceEqual(articles, [ca4, ca2, ca1, ca3])\n+\n+    def test_order_by_self_referential_fk_id(self):\n+        from django.db import models\n+        \"\"\"\n+        Ordering by a self-referential foreign key's ID field should not be\n+        affected by the model's default ordering.\n+        \"\"\"\n+        # Create a model with a self-referential foreign key\n+        class SelfRefModel(models.Model):\n+            class Meta:\n+                ordering = (\"-id\",)\n+            id = models.AutoField(primary_key=True)\n+            root = models.ForeignKey(\"self\", on_delete=models.CASCADE, null=True)\n+            value = models.IntegerField(null=True)\n+        class RelatedModel(models.Model):\n+            id = models.AutoField(primary_key=True)\n+            ref = models.ForeignKey(SelfRefModel, on_delete=models.CASCADE)\n+            value = models.IntegerField(null=True)\n+        # Create test data\n+        root1 = SelfRefModel.objects.create(value=1)\n+        root2 = SelfRefModel.objects.create(value=2)\n+        child1 = SelfRefModel.objects.create(root=root1, value=10)\n+        child2 = SelfRefModel.objects.create(root=root2, value=20)\n+        RelatedModel.objects.create(ref=child1, value=100)\n+        RelatedModel.objects.create(ref=child2, value=200)\n+        # Test ordering by root_id\n+        qs = RelatedModel.objects.filter(ref__value__in=[10, 20])\n+        qs = qs.order_by(\"ref__root_id\")\n+        # Get the SQL query\n+        sql = str(qs.query)\n+        # Verify that the query uses the direct column reference and ASC ordering\n+        self.assertIn(\"ORDER BY\", sql)\n+        self.assertNotIn(\"DESC\", sql.split(\"ORDER BY\")[1])\n+        # Verify that the query doesn't have an unnecessary join\n+        join_count = sql.count(\"JOIN\")\n+        self.assertEqual(join_count, 1, \"Query should only have one JOIN\")\n+        # Verify the results are ordered correctly\n+        results = list(qs.values_list('ref__root_id', flat=True))\n+        self.assertEqual(results, sorted(results))\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-24102",
        "model_patch": "diff --git a/sympy/parsing/tests/test_mathematica.py b/sympy/parsing/tests/test_mathematica.py\nindex f89b532ef1..cedc4dd8c0 100644\n--- a/sympy/parsing/tests/test_mathematica.py\n+++ b/sympy/parsing/tests/test_mathematica.py\n@@ -273,3 +273,15 @@ def test_parser_mathematica_exp_alt():\n     assert convert_chain3(full_form1) == sin(x*y)\n     assert convert_chain3(full_form2) == x*y + z\n     assert convert_chain3(full_form3) == sin(x*(y + z)*w**n)\n+\n+def test_parse_greek_characters():\n+    # Test that Greek characters can be parsed correctly\n+    assert parse_mathematica('\u03bb') == symbols('\u03bb')\n+    assert parse_mathematica('\u03b1 + \u03b2') == symbols('\u03b1') + symbols('\u03b2')\n+    assert parse_mathematica('\u03b3*\u03b4') == symbols('\u03b3') * symbols('\u03b4')\n+    assert parse_mathematica('Sin[\u03b8]') == sin(symbols('\u03b8'))\n+    # Test with a mix of Greek and Latin characters\n+    assert parse_mathematica('x + \u03bb') == x + symbols('\u03bb')\n+    assert parse_mathematica('\u03b5*y') == symbols('\u03b5') * y\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "matplotlib__matplotlib-26020",
        "model_patch": "diff --git a/lib/mpl_toolkits/axes_grid1/tests/test_axes_grid1.py b/lib/mpl_toolkits/axes_grid1/tests/test_axes_grid1.py\nindex d1554020cd..6f6b5d6e44 100644\n--- a/lib/mpl_toolkits/axes_grid1/tests/test_axes_grid1.py\n+++ b/lib/mpl_toolkits/axes_grid1/tests/test_axes_grid1.py\n@@ -591,6 +591,21 @@ def test_axes_class_tuple():\n     axes_class = (mpl_toolkits.axes_grid1.mpl_axes.Axes, {})\n     gr = AxesGrid(fig, 111, nrows_ncols=(1, 1), axes_class=axes_class)\n \n+def test_non_mpl_axes_class():\n+    \"\"\"Test that AxesGrid works with non-default axis classes like GeoAxes.\"\"\"\n+    # Skip test if cartopy is not installed\n+    pytest.importorskip(\"cartopy\")\n+    from cartopy.crs import PlateCarree\n+    from cartopy.mpl.geoaxes import GeoAxes\n+    fig = plt.figure()\n+    axes_class = (GeoAxes, dict(map_projection=PlateCarree()))\n+    # This should not raise TypeError: 'method' object is not subscriptable\n+    grid = AxesGrid(fig, 111, nrows_ncols=(1, 1), axes_class=axes_class)\n+    # Basic verification that the grid was created successfully\n+    assert len(grid) == 1\n+    assert isinstance(grid[0], GeoAxes)\n+\n+\n \n def test_grid_axes_lists():\n     \"\"\"Test Grid axes_all, axes_row and axes_column relationship.\"\"\"\n@@ -767,3 +782,4 @@ def test_anchored_locator_base_call():\n     axins.set(xticks=[], yticks=[])\n \n     axins.imshow(Z, extent=extent, origin=\"lower\")\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14672",
        "model_patch": "diff --git a/tests/model_fields/test_manytomanyfield.py b/tests/model_fields/test_manytomanyfield.py\nindex 0ddf57ceaf..50f99144c7 100644\n--- a/tests/model_fields/test_manytomanyfield.py\n+++ b/tests/model_fields/test_manytomanyfield.py\n@@ -87,6 +87,34 @@ class ManyToManyFieldTests(SimpleTestCase):\n                     db_table='custom_name',\n                 )\n \n+    @isolate_apps('model_fields')\n+    def test_through_fields_list_hashable(self):\n+        \"\"\"\n+        ManyToManyRel should make through_fields hashable when it's a list.\n+        This is particularly important for proxy models.\n+        \"\"\"\n+        class Parent(models.Model):\n+            name = models.CharField(max_length=256)\n+        class ProxyParent(Parent):\n+            class Meta:\n+                proxy = True\n+        class Child(models.Model):\n+            parent = models.ForeignKey(Parent, on_delete=models.CASCADE)\n+            many_to_many_field = models.ManyToManyField(\n+                to=Parent,\n+                through=\"ManyToManyModel\",\n+                through_fields=['child', 'parent'],\n+                related_name=\"something\"\n+            )\n+        class ManyToManyModel(models.Model):\n+            parent = models.ForeignKey(Parent, on_delete=models.CASCADE, related_name='+')\n+            child = models.ForeignKey(Child, on_delete=models.CASCADE, related_name='+')\n+            second_child = models.ForeignKey(Child, on_delete=models.CASCADE, null=True, default=None)\n+        # This should not raise TypeError: unhashable type: 'list'\n+        ProxyParent.check()\n+    \n+\n+\n \n class ManyToManyFieldDBTests(TestCase):\n \n@@ -99,3 +127,4 @@ class ManyToManyFieldDBTests(TestCase):\n         related_obj = ManyToMany.objects.create()\n         obj.m2m.add(related_obj)\n         self.assertEqual(obj._meta.get_field('m2m').value_from_object(obj), [related_obj])\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14016",
        "model_patch": "diff --git a/tests/queries/test_q.py b/tests/queries/test_q.py\nindex 9adff07ef2..5946234005 100644\n--- a/tests/queries/test_q.py\n+++ b/tests/queries/test_q.py\n@@ -103,3 +103,24 @@ class QTests(SimpleTestCase):\n         q = q1 & q2\n         path, args, kwargs = q.deconstruct()\n         self.assertEqual(Q(*args, **kwargs), q)\n+\n+    def test_combine_with_unpickleable(self):\n+        \"\"\"\n+        Test that Q objects containing non-pickleable types like dict_keys\n+        can be combined with the | operator without raising TypeError.\n+        \"\"\"\n+        # This should not raise TypeError: cannot pickle 'dict_keys' object\n+        empty_dict_keys = {}.keys()\n+        q1 = Q()\n+        q2 = Q(x__in=empty_dict_keys)\n+        combined = q1 | q2\n+        self.assertEqual(combined, Q(x__in=empty_dict_keys))\n+        # Test with non-empty dict_keys\n+        non_empty_dict_keys = {\"a\": 1, \"b\": 2}.keys()\n+        q3 = Q()\n+        q4 = Q(x__in=non_empty_dict_keys)\n+        combined = q3 | q4\n+        self.assertEqual(combined, Q(x__in=non_empty_dict_keys))\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12470",
        "model_patch": "diff --git a/tests/model_inheritance/tests.py b/tests/model_inheritance/tests.py\nindex 4252f3a301..4f06a4d04b 100644\n--- a/tests/model_inheritance/tests.py\n+++ b/tests/model_inheritance/tests.py\n@@ -98,6 +98,42 @@ class ModelInheritanceTests(TestCase):\n         )\n         self.assertEqual(Restaurant._meta.ordering, [\"-rating\"])\n \n+    def test_inherited_ordering_with_pk(self):\n+        \"\"\"\n+        Test that inherited models respect parent's Meta.ordering when it includes '-pk'.\n+        \"\"\"\n+        # Create a simple model hierarchy with ordering by -pk\n+        @isolate_apps('model_inheritance')\n+        def get_models():\n+            class Parent(models.Model):\n+                class Meta:\n+                    ordering = [\"-pk\"]\n+            class Child(Parent):\n+                pass\n+            return Parent, Child\n+        Parent, Child = get_models()\n+        # Create test data\n+        parent1 = Parent.objects.create()\n+        parent2 = Parent.objects.create()\n+        child1 = Child.objects.create()\n+        child2 = Child.objects.create()\n+        # Check that Parent objects are ordered by -pk (descending)\n+        with CaptureQueriesContext(connection) as queries:\n+            parents = list(Parent.objects.all())\n+            self.assertEqual(parents, [parent2, parent1])\n+        parent_sql = queries[0]['sql'].lower()\n+        self.assertIn('order by', parent_sql)\n+        self.assertIn('desc', parent_sql)\n+        # Check that Child objects are also ordered by -pk (descending)\n+        with CaptureQueriesContext(connection) as queries:\n+            children = list(Child.objects.all())\n+            self.assertEqual(children, [child2, child1])\n+        child_sql = queries[0]['sql'].lower()\n+        self.assertIn('order by', child_sql)\n+        self.assertIn('desc', child_sql)\n+    \n+\n+\n     def test_custompk_m2m(self):\n         b = Base.objects.create()\n         b.titles.add(Title.objects.create(title=\"foof\"))\n@@ -522,3 +558,4 @@ class InheritanceUniqueTests(TestCase):\n         msg = 'Grand parent with this First name and Last name already exists.'\n         with self.assertRaisesMessage(ValidationError, msg):\n             grand_child.validate_unique()\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pylint-dev__pylint-6506",
        "model_patch": "diff --git a/tests/config/test_argparse_config.py b/tests/config/test_argparse_config.py\nindex 3bad5e8fa..18492a470 100644\n--- a/tests/config/test_argparse_config.py\n+++ b/tests/config/test_argparse_config.py\n@@ -77,3 +77,18 @@ class TestArguments:\n         with pytest.raises(UnrecognizedArgumentAction):\n             # We test with None as that is 'unrecognized'\n             manager._add_parser_option(group, None)  # type: ignore[arg-type]\n+\n+    def test_unrecognized_option_no_traceback() -> None:\n+        \"\"\"Test that unrecognized options don't cause a traceback to be printed.\"\"\"\n+        with pytest.raises(SystemExit) as excinfo:\n+            Run([\"--unknown-option\"])\n+        # Check that the exit code is not 0 (indicating an error)\n+        assert excinfo.value.code != 0\n+        # Run with a short option that doesn't exist\n+        with pytest.raises(SystemExit) as excinfo:\n+            Run([\"-Q\"])\n+        # Check that the exit code is not 0 (indicating an error)\n+        assert excinfo.value.code != 0\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15902",
        "model_patch": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 96a2189d70..eb7a396e7e 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -1910,3 +1910,15 @@ class DeprecationTests(SimpleTestCase):\n             ChoiceFormSet = formset_factory(Choice)\n             formset = ChoiceFormSet()\n             str(formset)\n+\n+    def test_management_form_no_deprecation_warning(self):\n+        \"\"\"\n+        ManagementForm should not raise template deprecation warnings.\n+        \"\"\"\n+        with self.assertNoWarns(RemovedInDjango50Warning):\n+            formset = formset_factory(Choice)()\n+            management_form = formset.management_form\n+            str(management_form)  # Trigger rendering\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "mwaskom__seaborn-2848",
        "model_patch": "diff --git a/tests/test_axisgrid.py b/tests/test_axisgrid.py\nindex 40d591f1..28d13f55 100644\n--- a/tests/test_axisgrid.py\n+++ b/tests/test_axisgrid.py\n@@ -1388,6 +1388,32 @@ class TestPairGrid:\n         with pytest.raises(ValueError):\n             g = ag.pairplot(self.df, hue=\"a\", vars=vars, markers=markers[:-2])\n \n+    def test_pairplot_with_incomplete_hue_order(self):\n+        # Create a dataset with a categorical variable for hue\n+        iris = pd.DataFrame({\n+            \"x\": np.random.normal(size=150),\n+            \"y\": np.random.normal(size=150),\n+            \"species\": np.repeat([\"setosa\", \"versicolor\", \"virginica\"], 50)\n+        })\n+        # Test that pairplot works with a hue_order that doesn't include all hue values\n+        # This should plot only \"setosa\" and \"versicolor\", excluding \"virginica\"\n+        g = ag.pairplot(iris, hue=\"species\", hue_order=[\"setosa\", \"versicolor\"])\n+        # Verify that only the specified hue levels are in the legend\n+        legend_texts = [t.get_text() for t in g._legend.texts]\n+        assert set(legend_texts) == {\"setosa\", \"versicolor\"}\n+        assert \"virginica\" not in legend_texts\n+        # Verify that the plot contains only data for the specified hue levels\n+        for i, j in zip(*np.triu_indices_from(g.axes, 1)):\n+            ax = g.axes[i, j]\n+            # Get the data from the scatter plot\n+            for collection in ax.collections:\n+                if hasattr(collection, \"get_array\"):\n+                    hue_values = collection.get_array()\n+                    # Check that there are only two unique values (corresponding to the two hue levels)\n+                    assert len(np.unique(hue_values)) <= 2\n+    \n+\n+\n     def test_corner_despine(self):\n \n         g = ag.PairGrid(self.df, corner=True, despine=False)\n@@ -1789,3 +1815,4 @@ class TestJointPlot:\n         with pytest.warns(UserWarning):\n             g = ag.jointplot(data=long_df, x=\"x\", y=\"y\", marginal_kws=dict(rug=True))\n             assert g.ax_marg_x.patches\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11049",
        "model_patch": "diff --git a/tests/forms_tests/field_tests/test_durationfield.py b/tests/forms_tests/field_tests/test_durationfield.py\nindex 2c2e17acd3..0f3e242776 100644\n--- a/tests/forms_tests/field_tests/test_durationfield.py\n+++ b/tests/forms_tests/field_tests/test_durationfield.py\n@@ -57,3 +57,16 @@ class DurationFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n         self.assertEqual(field.prepare_value(td), duration_string(td))\n         self.assertEqual(field.prepare_value('arbitrary'), 'arbitrary')\n         self.assertIsNone(field.prepare_value(None))\n+\n+    def test_durationfield_error_message_format(self):\n+        \"\"\"\n+        The error message for invalid DurationField should correctly describe\n+        the expected format as \"[DD] [[HH:]MM:]ss[.uuuuuu]\" (seconds are mandatory,\n+        minutes are optional, and hours are optional if minutes are provided).\n+        \"\"\"\n+        field = DurationField()\n+        with self.assertRaisesMessage(ValidationError, \"[DD] [[HH:]MM:]ss[.uuuuuu]\"):\n+            field.clean(\"14:00\")  # This is interpreted as 14 minutes, but seconds are missing\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pallets__flask-4992",
        "model_patch": "diff --git a/tests/test_config.py b/tests/test_config.py\nindex 76c5d272..832f45e1 100644\n--- a/tests/test_config.py\n+++ b/tests/test_config.py\n@@ -36,6 +36,24 @@ def test_config_from_file():\n     app.config.from_file(os.path.join(current_dir, \"static\", \"config.json\"), json.load)\n     common_object_test(app)\n \n+def test_config_from_file_binary_mode():\n+    app = flask.Flask(__name__)\n+    current_dir = os.path.dirname(os.path.abspath(__file__))\n+    # Create a mock binary loader function\n+    def binary_loader(file_obj):\n+        # This function expects a file opened in binary mode\n+        if not hasattr(file_obj, 'mode') or 'b' not in file_obj.mode:\n+            raise TypeError(\"File must be opened in binary mode, e.g. use `open('file.ext', 'rb')`\")\n+        return {\"BINARY_LOADED\": True}\n+    # This should work with the new mode parameter\n+    app.config.from_file(\n+        os.path.join(current_dir, \"static\", \"config.json\"), \n+        binary_loader,\n+        mode=\"rb\"\n+    )\n+    assert app.config[\"BINARY_LOADED\"] is True\n+\n+\n \n def test_from_prefixed_env(monkeypatch):\n     monkeypatch.setenv(\"FLASK_STRING\", \"value\")\n@@ -247,3 +265,4 @@ def test_from_pyfile_weird_encoding(tmpdir, encoding):\n     app.config.from_pyfile(str(f))\n     value = app.config[\"TEST_VALUE\"]\n     assert value == \"f\u00f6\u00f6\"\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-14894",
        "model_patch": "diff --git a/sklearn/svm/tests/test_sparse.py b/sklearn/svm/tests/test_sparse.py\nindex 7cf6e8af2a..652b70a3c8 100644\n--- a/sklearn/svm/tests/test_sparse.py\n+++ b/sklearn/svm/tests/test_sparse.py\n@@ -326,6 +326,25 @@ def test_sparse_realdata():\n     assert_array_equal(clf.support_vectors_, sp_clf.support_vectors_.toarray())\n     assert_array_equal(clf.dual_coef_, sp_clf.dual_coef_.toarray())\n \n+def test_sparse_empty_support_vectors():\n+    \"\"\"Test SVR with empty support vectors in sparse case.\"\"\"\n+    # Create a simple dataset where SVR will have empty support vectors\n+    X = np.array([[0, 1, 0, 0],\n+                 [0, 0, 0, 1],\n+                 [0, 0, 1, 0],\n+                 [0, 0, 0, 1]])\n+    y = np.array([0.04, 0.04, 0.10, 0.16])\n+    # Create SVR model with parameters that will lead to empty support vectors\n+    model = svm.SVR(C=316.227766017, kernel='linear', max_iter=15000)\n+    # Fit with dense data (should work fine)\n+    model.fit(X, y)\n+    # Convert to sparse and fit (should not raise ZeroDivisionError)\n+    X_sparse = sparse.csr_matrix(X)\n+    model.fit(X_sparse, y)\n+    # Check that dual_coef_ is a sparse matrix\n+    assert sparse.issparse(model.dual_coef_)\n+\n+\n \n def test_sparse_svc_clone_with_callable_kernel():\n     # Test that the \"dense_fit\" is called even though we use sparse input\n@@ -360,3 +379,4 @@ def test_consistent_proba():\n     with ignore_warnings(category=ConvergenceWarning):\n         proba_2 = a.fit(X, Y).predict_proba(X)\n     assert_array_almost_equal(proba_1, proba_2)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-5413",
        "model_patch": "diff --git a/testing/python/raises.py b/testing/python/raises.py\nindex bfcb3dbb1..fa7d286f1 100644\n--- a/testing/python/raises.py\n+++ b/testing/python/raises.py\n@@ -263,3 +263,25 @@ class TestRaises:\n             with pytest.raises(CrappyClass()):\n                 pass\n         assert \"via __class__\" in excinfo.value.args[0]\n+\n+    def test_raises_str_representation(self):\n+        \"\"\"Test that str() on pytest.raises context matches normal exception str representation.\"\"\"\n+        # Create a multi-line error message\n+        error_message = \"A\\nB\\nC\"\n+        # Get the string representation from a normal try/except\n+        try:\n+            raise LookupError(error_message)\n+        except LookupError as normal_exc:\n+            normal_str = str(normal_exc)\n+        # Get the string representation from pytest.raises context\n+        with pytest.raises(LookupError) as exc_info:\n+            raise LookupError(error_message)\n+        # This will fail because currently str(exc_info) doesn't match str(normal_exc)\n+        # It should show the full multi-line error message, not just the first line\n+        assert str(exc_info.value) == normal_str\n+        # This assertion verifies the current behavior that will need to be fixed\n+        # Currently str(exc_info) only shows the first line with location info\n+        assert \"A\" in str(exc_info) and \"B\" not in str(exc_info)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13315",
        "model_patch": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex 9e900e35f4..42082c4c7d 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -2815,6 +2815,27 @@ class LimitChoicesToTests(TestCase):\n         f = StumpJokeWithCustomFieldForm()\n         self.assertEqual(f.fields['custom'].queryset, 42)\n \n+    def test_limit_choices_to_q_object_for_fk_rel(self):\n+        \"\"\"\n+        Test that using a Q object with limit_choices_to on a ForeignKey\n+        doesn't produce duplicate options in the form field.\n+        \"\"\"\n+        # Create a model form for StumpJoke\n+        form = StumpJokeForm()\n+        # Get the queryset from the form field\n+        queryset = form.fields['most_recently_fooled'].queryset\n+        # Count the number of items in the queryset\n+        count = queryset.count()\n+        # Count the number of distinct items in the queryset\n+        distinct_count = queryset.distinct().count()\n+        # The counts should be the same, meaning no duplicates\n+        self.assertEqual(count, distinct_count, \n+                         \"Form field queryset contains duplicate entries when using Q objects in limit_choices_to\")\n+        # Verify that the queryset contains the expected number of items\n+        self.assertEqual(count, 2, \"Expected exactly 2 items in the filtered queryset\")\n+    \n+\n+\n     def test_fields_for_model_applies_limit_choices_to(self):\n         fields = fields_for_model(StumpJoke, ['has_fooled_today'])\n         self.assertSequenceEqual(fields['has_fooled_today'].queryset, [self.threepwood])\n@@ -3029,3 +3050,4 @@ class ModelToDictTests(TestCase):\n         # If data were a QuerySet, it would be reevaluated here and give \"red\"\n         # instead of the original value.\n         self.assertEqual(data, [blue])\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-17630",
        "model_patch": "diff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex 1e1033affc..dfc0e19631 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -222,3 +222,22 @@ def test_block_collapse_type():\n     assert block_collapse(Transpose(bm1)).__class__ == BlockDiagMatrix\n     assert bc_transpose(Transpose(bm1)).__class__ == BlockDiagMatrix\n     assert bc_inverse(Inverse(bm1)).__class__ == BlockDiagMatrix\n+\n+def test_blockmatrix_with_zeromatrix():\n+    from sympy.matrices import ZeroMatrix\n+    # Test for issue where BlockMatrix with ZeroMatrix blocks fails when multiplied multiple times\n+    a = MatrixSymbol(\"a\", 2, 2)\n+    z = ZeroMatrix(2, 2)\n+    b = BlockMatrix([[a, z], [z, z]])\n+    # First multiplication works fine\n+    result1 = block_collapse(b * b)\n+    expected1 = BlockMatrix([[a**2, z], [z, z]])\n+    assert result1 == expected1\n+    # Second multiplication should work but currently fails\n+    result2 = block_collapse(b * b * b)\n+    expected2 = BlockMatrix([[a**3, z], [z, z]])\n+    assert result2 == expected2\n+    # Test direct block multiplication\n+    assert b._blockmul(b)._blockmul(b) == expected2\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-16281",
        "model_patch": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex cfaa65a7a2..5f11cb00c1 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -2105,6 +2105,46 @@ def test_pretty_product():\n     assert pretty(expr) == ascii_str\n     assert upretty(expr) == unicode_str\n \n+def test_product_pretty_improvement():\n+    n = symbols('n')\n+    expr = Product(1/n, (n, 1, oo))\n+    # The current output has an empty line at the bottom of the product symbol\n+    # and the product symbol is too wide. The improved version should not have\n+    # these issues.\n+    # Test unicode version\n+    unicode_str = upretty(expr)\n+    # Check that there's no empty line at the bottom of the product symbol\n+    # by ensuring there are no consecutive vertical bars with only spaces between\n+    lines = unicode_str.split('\\n')\n+    for i in range(len(lines) - 1):\n+        if '\u2502' in lines[i] and '\u2502' in lines[i+1]:\n+            # If both lines have vertical bars, check if the line between them is empty\n+            left_bar_idx = lines[i].index('\u2502')\n+            right_bar_idx = lines[i].rindex('\u2502')\n+            # The space between bars should contain something other than just spaces\n+            # in at least one of the lines\n+            assert not (lines[i][left_bar_idx+1:right_bar_idx].strip() == '' and \n+                       lines[i+1][left_bar_idx+1:right_bar_idx].strip() == '')\n+    # Test ASCII version\n+    ascii_str = pretty(expr)\n+    lines = ascii_str.split('\\n')\n+    for i in range(len(lines) - 1):\n+        if '|' in lines[i] and '|' in lines[i+1]:\n+            left_bar_idx = lines[i].index('|')\n+            right_bar_idx = lines[i].rindex('|')\n+            assert not (lines[i][left_bar_idx+1:right_bar_idx].strip() == '' and \n+                       lines[i+1][left_bar_idx+1:right_bar_idx].strip() == '')\n+    # Check that the width of the product symbol is reasonable\n+    # by ensuring the width between vertical bars is not excessive\n+    for line in unicode_str.split('\\n'):\n+        if '\u2502' in line:\n+            left_bar_idx = line.index('\u2502')\n+            right_bar_idx = line.rindex('\u2502')\n+            # The width between bars should be reasonable (not too wide)\n+            # Current implementation has width around 6, so we expect it to be less\n+            assert right_bar_idx - left_bar_idx <= 5\n+\n+\n \n def test_pretty_lambda():\n     # S.IdentityFunction is a special case\n@@ -6587,3 +6627,4 @@ def test_imaginary_unit():\n \n     raises(TypeError, lambda: pretty(I, imaginary_unit=I))\n     raises(ValueError, lambda: pretty(I, imaginary_unit=\"kkk\"))\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-5227",
        "model_patch": "diff --git a/testing/logging/test_formatter.py b/testing/logging/test_formatter.py\nindex abceaf857..9925d4650 100644\n--- a/testing/logging/test_formatter.py\n+++ b/testing/logging/test_formatter.py\n@@ -34,3 +34,23 @@ def test_coloredlogformatter():\n     formatter = ColoredLevelFormatter(tw, logfmt)\n     output = formatter.format(record)\n     assert output == (\"dummypath                   10 INFO     Test Message\")\n+\n+def test_default_log_format_includes_name():\n+    from _pytest.logging import DEFAULT_LOG_FORMAT\n+    # The test should verify that the default log format includes the %(name)s format specifier\n+    assert \"%(name)s\" in DEFAULT_LOG_FORMAT\n+    # Create a logger and a log record to test the format\n+    logger = logging.getLogger(\"test_module\")\n+    handler = logging.StreamHandler()\n+    formatter = logging.Formatter(DEFAULT_LOG_FORMAT)\n+    handler.setFormatter(formatter)\n+    stream = py.io.TextIO()\n+    handler.stream = stream\n+    logger.addHandler(handler)\n+    # Log a message\n+    logger.warning(\"test message\")\n+    log_output = stream.getvalue()\n+    # Verify that the module name appears in the log output\n+    assert \"test_module\" in log_output\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15781",
        "model_patch": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 222a1c5835..ce52e54429 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -411,6 +411,32 @@ class CommandTests(SimpleTestCase):\n         parser = BaseCommand().create_parser(\"prog_name\", \"subcommand\", epilog=epilog)\n         self.assertEqual(parser.epilog, epilog)\n \n+    def test_multiline_help_formatting(self):\n+        \"\"\"Test that multiline help text is properly formatted with line breaks preserved.\"\"\"\n+        class Command(BaseCommand):\n+            help = \"\"\"\n+            This is a multiline help text.\n+            It should preserve line breaks.\n+            Example usage:\n+                ./manage.py command arg1 arg2\n+            \"\"\"\n+            def add_arguments(self, parser):\n+                parser.add_argument('arg', help='An argument')\n+        out = StringIO()\n+        cmd = Command(stdout=out)\n+        cmd.print_help('django-admin.py', 'command')\n+        output = out.getvalue()\n+        # The help text should preserve line breaks\n+        self.assertIn(\"This is a multiline help text.\", output)\n+        self.assertIn(\"It should preserve line breaks.\", output)\n+        self.assertIn(\"Example usage:\", output)\n+        self.assertIn(\"    ./manage.py command arg1 arg2\", output)\n+        # The lines should appear on separate lines, not run together\n+        self.assertNotIn(\"This is a multiline help text.It should preserve line breaks.\", output)\n+        self.assertNotIn(\"It should preserve line breaks.Example usage:\", output)\n+    \n+\n+\n     def test_outputwrapper_flush(self):\n         out = StringIO()\n         with mock.patch.object(out, \"flush\") as mocked_flush:\n@@ -503,3 +529,4 @@ class UtilsTests(SimpleTestCase):\n     def test_normalize_path_patterns_truncates_wildcard_base(self):\n         expected = [os.path.normcase(p) for p in [\"foo/bar\", \"bar/*/\"]]\n         self.assertEqual(normalize_path_patterns([\"foo/bar/*\", \"bar/*/\"]), expected)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15498",
        "model_patch": "diff --git a/tests/middleware/tests.py b/tests/middleware/tests.py\nindex cb40b36321..1a729fcd22 100644\n--- a/tests/middleware/tests.py\n+++ b/tests/middleware/tests.py\n@@ -627,6 +627,25 @@ class ConditionalGetMiddlewareTest(SimpleTestCase):\n         resp = ConditionalGetMiddleware(get_response)(self.req)\n         self.assertEqual(resp.status_code, 400)\n \n+    def test_if_modified_since_empty_string(self):\n+        \"\"\"\n+        If-Modified-Since header with an empty string value should be ignored\n+        and the response should be processed normally.\n+        \"\"\"\n+        def get_response(req):\n+            return self.response\n+        request = HttpRequest()\n+        request.META = {\n+            'HTTP_IF_MODIFIED_SINCE': '',\n+        }\n+        middleware = ConditionalGetMiddleware(get_response)\n+        response = middleware(request)\n+        # The response should be processed normally, not returning a 304 Not Modified\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.content, self.response.content)\n+    \n+\n+\n     def test_not_modified_headers(self):\n         \"\"\"\n         The 304 Not Modified response should include only the headers required\n@@ -1031,3 +1050,4 @@ class ETagGZipMiddlewareTest(SimpleTestCase):\n         )\n         next_response = ConditionalGetMiddleware(get_response)(next_request)\n         self.assertEqual(next_response.status_code, 304)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-21055",
        "model_patch": "diff --git a/sympy/assumptions/tests/test_refine.py b/sympy/assumptions/tests/test_refine.py\nindex 505cd609e8..e311f4340c 100644\n--- a/sympy/assumptions/tests/test_refine.py\n+++ b/sympy/assumptions/tests/test_refine.py\n@@ -143,6 +143,20 @@ def test_complex():\n     assert refine(im((w + I*x) * (y + I*z)), Q.real(w) & Q.real(x) & Q.real(y)\n         & Q.real(z)) == w*z + x*y\n \n+def test_complex_arg_abs():\n+    from sympy.functions import arg\n+    a = Symbol('a', real=True)\n+    # Test refine(arg(a)) with positive assumption\n+    assert refine(arg(a), Q.positive(a)) == 0\n+    # Test refine(arg(a)) with negative assumption\n+    assert refine(arg(a), Q.negative(a)) == pi\n+    # Test refine(Abs(arg(a))) with real assumption\n+    assert refine(Abs(arg(a)), Q.real(a)) == Piecewise((0, Q.positive(a)), (pi, Q.negative(a)), (Abs(arg(a)), True))\n+    # Test refine with complex expressions\n+    expr = Piecewise((1/(a**2 + 1), 2*Abs(arg(a)) < pi), (S.NaN, True))\n+    assert refine(expr, Q.positive(a)) == 1/(a**2 + 1)\n+\n+\n \n def test_sign():\n     x = Symbol('x', real = True)\n@@ -208,3 +222,4 @@ def test_matrixelement():\n     assert refine(x[1, 0], Q.symmetric(x)) == x[0, 1]\n     assert refine(x[i, j], Q.symmetric(x)) == x[j, i]\n     assert refine(x[j, i], Q.symmetric(x)) == x[j, i]\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-13043",
        "model_patch": "diff --git a/sympy/integrals/tests/test_intpoly.py b/sympy/integrals/tests/test_intpoly.py\nindex 1e0cc29731..f453159733 100644\n--- a/sympy/integrals/tests/test_intpoly.py\n+++ b/sympy/integrals/tests/test_intpoly.py\n@@ -36,6 +36,24 @@ def test_decompose():\n     assert decompose(9 * x ** 2 + y + 4 * x + x ** 3 + y ** 2 * x + 3, True) == \\\n            [3, y, x**3, 4*x, 9*x**2, x*y**2]\n \n+def test_decompose_order_independence():\n+    # Test that decompose with separate=True returns a consistent result\n+    # regardless of the order of terms in the input expression\n+    expr1 = x**2 + y + x\n+    expr2 = x + y + x**2\n+    # The current implementation might return different orders\n+    result1 = decompose(expr1, separate=True)\n+    result2 = decompose(expr2, separate=True)\n+    # Test should pass if the results are the same when sorted\n+    assert sorted(result1, key=str) == sorted(result2, key=str)\n+    # Test with a more complex expression\n+    expr3 = x**3 + y**2 + x*y + 5\n+    expr4 = 5 + x*y + y**2 + x**3\n+    result3 = decompose(expr3, separate=True)\n+    result4 = decompose(expr4, separate=True)\n+    assert sorted(result3, key=str) == sorted(result4, key=str)\n+\n+\n \n def test_best_origin():\n     expr1 = y ** 2 * x ** 5 + y ** 5 * x ** 7 + 7 * x + x ** 12 + y ** 7 * x\n@@ -166,3 +184,4 @@ def test_polytopes_intersecting_sides():\n                    Point(4.203, 0.478))\n     assert polytope_integrate(fig6, x**2 + x*y + y**2) ==\\\n         S(88161333955921)/(3*10**12)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sphinx-doc__sphinx-8273",
        "model_patch": "diff --git a/tests/test_build_manpage.py b/tests/test_build_manpage.py\nindex c3c41a2ae..cc5659625 100644\n--- a/tests/test_build_manpage.py\n+++ b/tests/test_build_manpage.py\n@@ -60,9 +60,25 @@ def test_default_man_pages():\n                  [\"Wolfgang Sch\u00e4uble & G'Beckstein\"], 1)]\n     assert default_man_pages(config) == expected\n \n+def test_man_page_section_directories(app, status, warning):\n+    app.build()\n+    # Check that section directories are created\n+    section1_dir = app.outdir / 'man1'\n+    assert section1_dir.exists()\n+    assert section1_dir.is_dir()\n+    # Check that man pages are placed in the correct section directory\n+    man_page = section1_dir / 'sphinx.1'\n+    assert man_page.exists()\n+    assert man_page.is_file()\n+    # Ensure the man page is not in the root directory\n+    root_man_page = app.outdir / 'sphinx.1'\n+    assert not root_man_page.exists()\n+\n+\n \n @pytest.mark.sphinx('man', testroot='markup-rubric')\n def test_rubric(app, status, warning):\n     app.build()\n     content = (app.outdir / 'python.1').read_text()\n     assert 'This is a rubric\\n' in content\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14238",
        "model_patch": "diff --git a/tests/model_options/test_default_pk.py b/tests/model_options/test_default_pk.py\nindex b678848916..a76a539729 100644\n--- a/tests/model_options/test_default_pk.py\n+++ b/tests/model_options/test_default_pk.py\n@@ -99,3 +99,33 @@ class TestDefaultPK(SimpleTestCase):\n \n         m2m_pk = M2MModel._meta.get_field('m2m').remote_field.through._meta.pk\n         self.assertIsInstance(m2m_pk, models.SmallAutoField)\n+\n+    @isolate_apps('test_models')\n+    def test_custom_auto_field_subclass(self):\n+        \"\"\"\n+        A custom field that subclasses BigAutoField or SmallAutoField can be used\n+        as DEFAULT_AUTO_FIELD.\n+        \"\"\"\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+        # Test with BigAutoField subclass\n+        with override_settings(DEFAULT_AUTO_FIELD='test_models.MyBigAutoField'):\n+            class ModelWithBigAutoFieldSubclass(models.Model):\n+                pass\n+            self.assertIsInstance(\n+                ModelWithBigAutoFieldSubclass._meta.pk,\n+                MyBigAutoField,\n+            )\n+        # Test with SmallAutoField subclass\n+        with override_settings(DEFAULT_AUTO_FIELD='test_models.MySmallAutoField'):\n+            class ModelWithSmallAutoFieldSubclass(models.Model):\n+                pass\n+            self.assertIsInstance(\n+                ModelWithSmallAutoFieldSubclass._meta.pk,\n+                MySmallAutoField,\n+            )\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "psf__requests-1963",
        "model_patch": "diff --git a/test_requests.py b/test_requests.py\nindex 17de8491..3ee8db9f 100755\n--- a/test_requests.py\n+++ b/test_requests.py\n@@ -767,6 +767,65 @@ class RequestsTestCase(unittest.TestCase):\n         assert r.status_code == 200\n         assert r.url.lower() == url.lower()\n \n+    def test_redirect_303_followed_by_307(self):\n+        import MockAdapter\n+        \"\"\"Test that a 303 redirect followed by a 307 redirect maintains the correct method.\"\"\"\n+        with requests.Session() as s:\n+            # Create a mock adapter to simulate the redirect chain\n+            adapter = MockAdapter()\n+            s.mount('http://', adapter)\n+            # Set up the mock adapter to return a 303 followed by a 307\n+            adapter.register_uri(\n+                'POST', 'http://example.com/original',\n+                status_code=303,\n+                headers={'Location': 'http://example.com/redirect1'}\n+            )\n+            adapter.register_uri(\n+                'GET', 'http://example.com/redirect1',\n+                status_code=307,\n+                headers={'Location': 'http://example.com/redirect2'}\n+            )\n+            adapter.register_uri(\n+                'GET', 'http://example.com/redirect2',\n+                status_code=200,\n+                text='success'\n+            )\n+            # Make the initial POST request\n+            resp = s.post('http://example.com/original', allow_redirects=True)\n+            # Check that the final request was a GET (not a POST)\n+            self.assertEqual(resp.request.method, 'GET')\n+            # Verify the redirect history\n+            self.assertEqual(len(resp.history), 2)\n+            self.assertEqual(resp.history[0].status_code, 303)\n+            self.assertEqual(resp.history[1].status_code, 307)\n+            # Verify the request methods in the chain\n+            self.assertEqual(resp.history[0].request.method, 'POST')  # Original request\n+            self.assertEqual(resp.history[1].request.method, 'GET')   # After 303\n+            self.assertEqual(resp.request.method, 'GET')              # After 307\n+    class MockAdapter(HTTPAdapter):\n+        \"\"\"Mock adapter that returns predefined responses.\"\"\"\n+        def __init__(self):\n+            super(MockAdapter, self).__init__()\n+            self._routes = {}\n+        def register_uri(self, method, url, **kwargs):\n+            self._routes[(method, url)] = kwargs\n+        def send(self, request, **kwargs):\n+            key = (request.method, request.url)\n+            route = self._routes.get(key)\n+            if route is None:\n+                raise Exception(f\"No mock response registered for {key}\")\n+            response = requests.Response()\n+            response.request = request\n+            response.url = request.url\n+            response.status_code = route.get('status_code', 200)\n+            if 'headers' in route:\n+                response.headers.update(route['headers'])\n+            if 'text' in route:\n+                response._content = route['text'].encode('utf-8')\n+            return response\n+    \n+\n+\n     def test_transport_adapter_ordering(self):\n         s = requests.Session()\n         order = ['https://', 'http://']\n@@ -1189,3 +1248,4 @@ class TestTimeout:\n \n if __name__ == '__main__':\n     unittest.main()\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15213",
        "model_patch": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex dab5474ef4..abe4069727 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -2046,3 +2046,14 @@ class OrderByTests(SimpleTestCase):\n             hash(OrderBy(F('field'), nulls_last=True)),\n             hash(OrderBy(F('field'), nulls_last=False)),\n         )\n+\n+    def test_expression_wrapper_with_negated_empty_q(self):\n+        \"\"\"\n+        ExpressionWrapper with ~Q(pk__in=[]) should not crash.\n+        \"\"\"\n+        expr = ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        # This should not raise an exception\n+        expr.resolve_expression(None)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-8906",
        "model_patch": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 53bf953a8..688fd50ff 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1344,6 +1344,29 @@ def test_module_level_skip_error(pytester: Pytester) -> None:\n         [\"*Using pytest.skip outside of a test is not allowed*\"]\n     )\n \n+def test_module_level_skip_error_improved_message(pytester: Pytester) -> None:\n+    \"\"\"Test that the error message for module level skip suggests allow_module_level=True.\"\"\"\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+        if True:\n+            pytest.skip(\"skip this module\")\n+        def test_func():\n+            assert True\n+        \"\"\"\n+    )\n+    result = pytester.runpytest()\n+    result.stdout.fnmatch_lines(\n+        [\n+            \"*Using pytest.skip outside of a test is not allowed*\",\n+            \"*To skip a module use pytestmark = pytest.mark.{skip,skipif}*\",\n+            # The test will fail until the message is improved to mention allow_module_level\n+            \"*or pytest.skip(..., allow_module_level=True)*\",\n+        ]\n+    )\n+    assert result.ret != 0\n+\n+\n \n def test_module_level_skip_with_allow_module_level(pytester: Pytester) -> None:\n     \"\"\"Verify that using pytest.skip(allow_module_level=True) is allowed.\"\"\"\n@@ -1444,3 +1467,4 @@ def test_relpath_rootdir(pytester: Pytester) -> None:\n     result.stdout.fnmatch_lines(\n         [\"SKIPPED [[]1[]] tests/test_1.py:2: unconditional skip\"]\n     )\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-12454",
        "model_patch": "diff --git a/sympy/matrices/tests/test_matrices.py b/sympy/matrices/tests/test_matrices.py\nindex 03b1548fd9..6285d23e58 100644\n--- a/sympy/matrices/tests/test_matrices.py\n+++ b/sympy/matrices/tests/test_matrices.py\n@@ -1220,11 +1220,33 @@ def test_is_symbolic():\n     assert a.is_symbolic() is False\n \n \n+\n def test_is_upper():\n     a = Matrix([[1, 2, 3]])\n     assert a.is_upper is True\n     a = Matrix([[1], [2], [3]])\n     assert a.is_upper is False\n+    # Test for tall matrices (more rows than columns)\n+    # This should not raise an IndexError\n+    a = zeros(4, 2)\n+    assert a.is_upper is True\n+    # Additional test with non-zero elements\n+    a = Matrix([\n+        [1, 2],\n+        [0, 3],\n+        [0, 0],\n+        [0, 0]\n+    ])\n+    assert a.is_upper is True\n+    # Test with a non-upper tall matrix\n+    a = Matrix([\n+        [1, 2],\n+        [3, 4],\n+        [0, 0],\n+        [0, 0]\n+    ])\n+    assert a.is_upper is False\n+\n \n \n def test_is_lower():\n@@ -2883,3 +2905,4 @@ def test_as_real_imag():\n         a,b = kls(m3).as_real_imag()\n         assert list(a) == list(m1)\n         assert list(b) == list(m1)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-16792",
        "model_patch": "diff --git a/sympy/utilities/tests/test_autowrap.py b/sympy/utilities/tests/test_autowrap.py\nindex 47fe933dc1..7a2d704140 100644\n--- a/sympy/utilities/tests/test_autowrap.py\n+++ b/sympy/utilities/tests/test_autowrap.py\n@@ -274,6 +274,18 @@ def test_binary_function():\n     f = binary_function('f', x + y, backend='dummy')\n     assert f._imp_() == str(x + y)\n \n+def test_autowrap_array_arg_not_in_expr():\n+    from sympy.matrices.expressions import MatrixSymbol\n+    import numpy as np\n+    x = MatrixSymbol('x', 2, 1)\n+    expr = 1.0\n+    # This should work with cython backend even though x doesn't appear in expr\n+    f = autowrap(expr, args=(x,), backend='cython')\n+    # Test that the function correctly returns 1.0 when called with a numpy array\n+    result = f(np.array([[1.0], [2.0]]))\n+    assert result == 1.0\n+\n+\n \n def test_ufuncify_source():\n     x, y, z = symbols('x,y,z')\n@@ -467,3 +479,4 @@ def test_ufuncify_source_multioutput():\n }\n #endif\"\"\" % {'num': CodeWrapper._module_counter}\n     assert source == expected\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-18835",
        "model_patch": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex 030db33239..59f2feaea3 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -704,6 +704,18 @@ def test_uniq():\n     assert list(uniq([2, 3, 2, 4, [2], [1], [2], [3], [1]])) == \\\n         [2, 3, 4, [2], [1], [3]]\n \n+def test_uniq_modify_list():\n+    # Test that uniq raises an error if the input sequence is modified during iteration\n+    lst = list('THISTLE')\n+    # Create a generator that modifies the list while iterating\n+    def modify_during_iteration():\n+        for i in uniq(lst):\n+            lst.remove(i)\n+            yield i\n+    # This should raise a RuntimeError\n+    raises(RuntimeError, lambda: list(modify_during_iteration()))\n+\n+\n \n def test_kbins():\n     assert len(list(kbins('1123', 2, ordered=1))) == 24\n@@ -824,3 +836,4 @@ def test_ibin():\n     assert ibin(3, 3, str=True) == '011'\n     assert list(ibin(2, 'all')) == [(0, 0), (0, 1), (1, 0), (1, 1)]\n     assert list(ibin(2, 'all', str=True)) == ['00', '01', '10', '11']\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-13471",
        "model_patch": "diff --git a/sympy/utilities/tests/test_pickling.py b/sympy/utilities/tests/test_pickling.py\nindex a28503eb5f..8ff27c04c4 100644\n--- a/sympy/utilities/tests/test_pickling.py\n+++ b/sympy/utilities/tests/test_pickling.py\n@@ -120,6 +120,30 @@ def test_core_add():\n     for c in (Add, Add(x, 4)):\n         check(c)\n \n+def test_float_pickle_python2to3():\n+    \"\"\"Test that expressions with floats can be pickled from Python 2 to Python 3.\"\"\"\n+    x = Symbol(\"x\")\n+    expr = x + 1.0\n+    # This is a Python 2 pickle of the expression x + 1.0\n+    # The issue is with the 'L' suffix in the hex representation of integers\n+    # which was used in Python 2 but is not valid in Python 3\n+    python2_pickle = (b'\\x80\\x02csympy.core.add\\nAdd\\nq\\x00)\\x81q\\x01}q\\x02X\\x06\\x00\\x00\\x00_argsq\\x03'\n+                      b'csympy.core.containers\\nTuple\\nq\\x04)\\x81q\\x05}q\\x06h\\x03h\\x04)\\x81q\\x07}q\\x08h\\x03'\n+                      b'h\\x04)\\x81q\\t}q\\nh\\x03h\\x04)\\x81q\\x0b}q\\x0ch\\x03]q\\r(csympy.core.numbers\\nFloat\\nq\\x0e)'\n+                      b'\\x81q\\x0f}q\\x10(X\\x05\\x00\\x00\\x00_precq\\x11K\\x02X\\x05\\x00\\x00\\x00_mpfq\\x12]q\\x13(K\\x01K\\x01'\n+                      b'M\\x00\\x10K\\x00esb}q\\x14bcsympy.core.symbol\\nSymbol\\nq\\x15)\\x81q\\x16}q\\x17(X\\x04\\x00\\x00\\x00'\n+                      b'nameq\\x18X\\x01\\x00\\x00\\x00xq\\x19X\\t\\x00\\x00\\x00assumpsq\\x1aNu}q\\x1bbessb}q\\x1cbsb}q\\x1dbsb}q\\x1eb.')\n+    # Test that the pickle can be loaded\n+    loaded_expr = pickle.loads(python2_pickle)\n+    # Verify that the loaded expression is equivalent to the original\n+    assert loaded_expr == expr\n+    assert isinstance(loaded_expr, Add)\n+    assert isinstance(loaded_expr.args[0], Float)\n+    assert loaded_expr.args[0] == 1.0\n+    assert isinstance(loaded_expr.args[1], Symbol)\n+    assert loaded_expr.args[1].name == 'x'\n+\n+\n \n def test_core_mul():\n     x = Symbol(\"x\")\n@@ -666,3 +690,4 @@ def test_concrete():\n     x = Symbol(\"x\")\n     for c in (Product, Product(x, (x, 2, 4)), Sum, Sum(x, (x, 2, 4))):\n         check(c)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pylint-dev__pylint-7114",
        "model_patch": "diff --git a/tests/lint/unittest_expand_modules.py b/tests/lint/unittest_expand_modules.py\nindex 15f72d0c5..8cda85d9f 100644\n--- a/tests/lint/unittest_expand_modules.py\n+++ b/tests/lint/unittest_expand_modules.py\n@@ -155,3 +155,59 @@ class TestExpandModules(CheckerTestCase):\n         modules.sort(key=lambda d: d[\"name\"])\n         assert modules == expected\n         assert not errors\n+\n+    @pytest.mark.parametrize(\n+        \"files_or_modules,expected\",\n+        [\n+            (\n+                [\"a\"],\n+                [\n+                    {\n+                        \"path\": \"a/a.py\",\n+                        \"name\": \"a.a\",\n+                        \"isarg\": True,\n+                        \"basepath\": \"a/a.py\",\n+                        \"basename\": \"a.a\",\n+                    },\n+                    {\n+                        \"path\": \"a/b.py\",\n+                        \"name\": \"a.b\",\n+                        \"isarg\": False,\n+                        \"basepath\": \"a/a.py\",\n+                        \"basename\": \"a.a\",\n+                    },\n+                ],\n+            ),\n+        ],\n+    )\n+    def test_expand_modules_with_same_name_as_directory(self, files_or_modules, expected, tmp_path):\n+        \"\"\"Test expand_modules when a directory contains a module with the same name.\"\"\"\n+        # Create directory structure\n+        a_dir = tmp_path / \"a\"\n+        a_dir.mkdir()\n+        (a_dir / \"a.py\").touch()\n+        (a_dir / \"b.py\").touch()\n+        # Change to the temporary directory\n+        cwd = Path.cwd()\n+        try:\n+            import os\n+            os.chdir(tmp_path)\n+            ignore_list, ignore_list_re = [], []\n+            modules, errors = expand_modules(\n+                files_or_modules,\n+                ignore_list,\n+                ignore_list_re,\n+                self.linter.config.ignore_paths,\n+            )\n+            # Normalize paths for comparison\n+            for module in modules:\n+                module[\"path\"] = str(Path(module[\"path\"]).relative_to(tmp_path))\n+                module[\"basepath\"] = str(Path(module[\"basepath\"]).relative_to(tmp_path))\n+            modules.sort(key=lambda d: d[\"name\"])\n+            assert modules == expected\n+            assert not errors\n+        finally:\n+            os.chdir(cwd)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-5692",
        "model_patch": "diff --git a/testing/test_junitxml.py b/testing/test_junitxml.py\nindex 3196f0ebd..66c66533b 100644\n--- a/testing/test_junitxml.py\n+++ b/testing/test_junitxml.py\n@@ -1306,6 +1306,30 @@ def test_record_testsuite_property_type_checking(testdir, junit):\n         [\"*TypeError: name parameter needs to be a string, but int given\"]\n     )\n \n+def test_hostname_and_timestamp_properties(testdir):\n+    testdir.makepyfile(\n+        \"\"\"\n+        def test_func():\n+            assert True\n+        \"\"\"\n+    )\n+    result, dom = runandparse(testdir)\n+    assert result.ret == 0\n+    node = dom.find_first_by_tag(\"testsuite\")\n+    # These assertions should fail with the current implementation\n+    # but pass after the issue is fixed\n+    assert node.has_attr(\"hostname\")\n+    assert node.has_attr(\"timestamp\")\n+    # Verify the attributes have proper values\n+    import socket\n+    import re\n+    # Hostname should match the system's hostname\n+    assert node[\"hostname\"] == socket.gethostname()\n+    # Timestamp should be in ISO format: YYYY-MM-DDThh:mm:ss\n+    timestamp_pattern = r\"\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\"\n+    assert re.match(timestamp_pattern, node[\"timestamp\"]) is not None\n+\n+\n \n @pytest.mark.parametrize(\"suite_name\", [\"my_suite\", \"\"])\n def test_set_suite_name(testdir, suite_name):\n@@ -1376,3 +1400,4 @@ def test_logging_passing_tests_disabled_does_not_log_test_output(testdir):\n     node = dom.find_first_by_tag(\"testcase\")\n     assert len(node.find_by_tag(\"system-err\")) == 0\n     assert len(node.find_by_tag(\"system-out\")) == 0\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15202",
        "model_patch": "diff --git a/tests/forms_tests/field_tests/test_urlfield.py b/tests/forms_tests/field_tests/test_urlfield.py\nindex 152456f216..e6e84e1bb0 100644\n--- a/tests/forms_tests/field_tests/test_urlfield.py\n+++ b/tests/forms_tests/field_tests/test_urlfield.py\n@@ -107,6 +107,23 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n                 with self.assertRaisesMessage(ValidationError, msg):\n                     f.clean(value)\n \n+    def test_urlfield_clean_invalid_ipv6(self):\n+        \"\"\"Test that invalid IPv6 URLs raise ValidationError, not ValueError.\"\"\"\n+        f = URLField()\n+        invalid_ipv6_urls = [\n+            '////]@N.AN',\n+            'http://[:::1]',\n+            'http://[::zzz]',\n+            'http://[invalid-ipv6]',\n+        ]\n+        msg = \"Enter a valid URL.\"\n+        for value in invalid_ipv6_urls:\n+            with self.subTest(value=value):\n+                with self.assertRaisesMessage(ValidationError, msg):\n+                    f.clean(value)\n+    \n+\n+\n     def test_urlfield_clean_required(self):\n         f = URLField()\n         msg = \"'This field is required.'\"\n@@ -129,3 +146,4 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n         msg = \"__init__() got multiple values for keyword argument 'strip'\"\n         with self.assertRaisesMessage(TypeError, msg):\n             URLField(strip=False)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14017",
        "model_patch": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 08ea0a51d3..001c7f5ef3 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -816,6 +816,26 @@ class BasicExpressionsTests(TestCase):\n             [self.example_inc.ceo, self.max],\n         )\n \n+    def test_q_and_exists_commutative(self):\n+        \"\"\"\n+        Test that Q() & Exists() and Exists() & Q() are commutative operations.\n+        \"\"\"\n+        # Create a subquery for the Exists expression\n+        inner_qs = Company.objects.filter(\n+            num_employees__gt=OuterRef('num_employees')\n+        )\n+        # Test Exists() & Q() - this works as per the issue description\n+        expr1 = Exists(inner_qs) & Q(name__contains='Company')\n+        # Test Q() & Exists() - this raises TypeError as per the issue description\n+        expr2 = Q(name__contains='Company') & Exists(inner_qs)\n+        # Both expressions should be equivalent\n+        self.assertEqual(\n+            Company.objects.filter(expr1).count(),\n+            Company.objects.filter(expr2).count()\n+        )\n+    \n+\n+\n \n class IterableLookupInnerExpressionsTests(TestCase):\n     @classmethod\n@@ -1933,3 +1953,4 @@ class ExpressionWrapperTests(SimpleTestCase):\n         group_by_cols = expr.get_group_by_cols(alias=None)\n         self.assertEqual(group_by_cols, [expr.expression])\n         self.assertEqual(group_by_cols[0].output_field, expr.output_field)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-20442",
        "model_patch": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex fe8a84570c..8ef8b1f979 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -45,6 +45,19 @@ def test_convert_to():\n     assert q.convert_to(s) == q\n     assert speed_of_light.convert_to(m) == speed_of_light\n \n+def test_convert_to_orthogonal_units():\n+    from sympy.physics.units.definitions import joule, second\n+    from sympy.physics.units.definitions import J\n+    from sympy.physics.units import minute as mins\n+    # Test that convert_to preserves orthogonal units\n+    assert convert_to(joule*second, joule) == joule*second\n+    assert convert_to(J*s, joule) == J*s\n+    # Test that convert_to works correctly with compatible units\n+    assert convert_to(J*s, kg*m**2/s) == kg*m**2/s\n+    # Test that convert_to works with time units\n+    assert convert_to(J*s, mins) == J*s/60\n+\n+\n \n def test_Quantity_definition():\n     q = Quantity(\"s10\", abbrev=\"sabbr\")\n@@ -480,3 +493,4 @@ def test_deprecated_quantity_methods():\n         step.set_scale_factor(2*meter)\n         assert convert_to(step, centimeter) == 200*centimeter\n         assert convert_to(1000*step/second, kilometer/second) == 2*kilometer/second\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-14752",
        "model_patch": "diff --git a/tests/admin_views/test_autocomplete_view.py b/tests/admin_views/test_autocomplete_view.py\nindex aa978f7a83..c57695362a 100644\n--- a/tests/admin_views/test_autocomplete_view.py\n+++ b/tests/admin_views/test_autocomplete_view.py\n@@ -293,6 +293,26 @@ class AutocompleteJsonViewTests(AdminViewBasicTestCase):\n             'pagination': {'more': False},\n         })\n \n+    def test_serialize_result_override(self):\n+        \"\"\"Test that serialize_result method can be overridden to add extra fields.\"\"\"\n+        class CustomAutocompleteJsonView(AutocompleteJsonView):\n+            def serialize_result(self, obj, to_field_name):\n+                result = super().serialize_result(obj, to_field_name)\n+                result['extra_field'] = 'extra_value'\n+                return result\n+        q = Question.objects.create(question='Is this a question?')\n+        request = self.factory.get(self.url, {'term': 'is', **self.opts})\n+        request.user = self.superuser\n+        response = CustomAutocompleteJsonView.as_view(**self.as_view_args)(request)\n+        self.assertEqual(response.status_code, 200)\n+        data = json.loads(response.content.decode('utf-8'))\n+        self.assertEqual(data, {\n+            'results': [{'id': str(q.pk), 'text': q.question, 'extra_field': 'extra_value'}],\n+            'pagination': {'more': False},\n+        })\n+    \n+\n+\n \n @override_settings(ROOT_URLCONF='admin_views.urls')\n class SeleniumTests(AdminSeleniumTestCase):\n@@ -424,3 +444,4 @@ class SeleniumTests(AdminSeleniumTestCase):\n         rows = self.selenium.find_elements_by_css_selector('.dynamic-authorship_set')\n         self.assertEqual(len(rows), 4)\n         assertNoResults(rows[-1])\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-15996",
        "model_patch": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex bad8775d4e..ea73b79fe0 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -387,23 +387,34 @@ class WriterTests(SimpleTestCase):\n             \"default=migrations.test_writer.IntEnum['A'])\",\n         )\n \n+\n     def test_serialize_enum_flags(self):\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A,\n             (\n                 \"migrations.test_writer.IntFlagEnum['A']\",\n-                {\"import migrations.test_writer\"},\n+                  {\"import migrations.test_writer\"},\n+                  {\"import migrations.test_writer\"},\n+                  {\"import migrations.test_writer\"},\n             ),\n         )\n         self.assertSerializedResultEqual(\n             IntFlagEnum.B,\n             (\n                 \"migrations.test_writer.IntFlagEnum['B']\",\n-                {\"import migrations.test_writer\"},\n             ),\n         )\n+        # Test for combination of enum flags\n+        self.assertSerializedResultEqual(\n+            IntFlagEnum.A | IntFlagEnum.B,\n+            (\n+                \"migrations.test_writer.IntFlagEnum['A'] | migrations.test_writer.IntFlagEnum['B']\",\n+            ),\n+        )\n+        # Test with field using combined flags as default\n         field = models.IntegerField(\n-            default=IntFlagEnum.A, choices=[(m.value, m) for m in IntFlagEnum]\n+            default=IntFlagEnum.A | IntFlagEnum.B,\n+            choices=[(m.value, m) for m in IntFlagEnum]\n         )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -411,8 +422,14 @@ class WriterTests(SimpleTestCase):\n             \"models.IntegerField(choices=[\"\n             \"(1, migrations.test_writer.IntFlagEnum['A']), \"\n             \"(2, migrations.test_writer.IntFlagEnum['B'])], \"\n-            \"default=migrations.test_writer.IntFlagEnum['A'])\",\n+            \"default=migrations.test_writer.IntFlagEnum['A'] | migrations.test_writer.IntFlagEnum['B'])\",\n         )\n+        # Test with regex flags as mentioned in the issue\n+        field_with_regex = models.IntegerField(default=re.UNICODE | re.IGNORECASE)\n+        string = MigrationWriter.serialize(field_with_regex)[0]\n+        self.assertIn(\"re.UNICODE | re.IGNORECASE\", string)\n+    \n+\n \n     def test_serialize_choices(self):\n         class TextChoices(models.TextChoices):\n@@ -1016,3 +1033,4 @@ class WriterTests(SimpleTestCase):\n             ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"\n         ):\n             MigrationWriter.register_serializer(complex, TestModel1)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-14308",
        "model_patch": "diff --git a/sympy/vector/tests/test_printing.py b/sympy/vector/tests/test_printing.py\nindex 84f1c086d6..043b53f652 100644\n--- a/sympy/vector/tests/test_printing.py\n+++ b/sympy/vector/tests/test_printing.py\n@@ -141,6 +141,22 @@ def test_pretty_print_unicode():\n     assert upretty(d[7]) == upretty_d_7\n     assert upretty(d[10]) == u'(cos(a)) (C_i|N_k) + (-sin(a)) (C_j|N_k)'\n \n+def test_vector_pretty_print_multiplication():\n+    # Test for the issue where vectors break pretty printing with exponents\n+    e = CoordSys3D('e')\n+    from sympy.abc import x, y, t\n+    # Create the expression from the issue\n+    expr = (x/y)**t * e.j\n+    # The pretty printing should handle the expression correctly\n+    # without duplicating the basis vector\n+    pretty_expr = upretty(expr)\n+    # The basis vector should appear only once in the output\n+    assert pretty_expr.count('e_j') == 1\n+    # The expression should be properly formatted\n+    assert '\u239bx\u239e\u1d57' in pretty_expr\n+    assert '\u239dy\u23a0' in pretty_expr\n+\n+\n \n def test_latex_printing():\n     assert latex(v[0]) == '\\\\mathbf{\\\\hat{0}}'\n@@ -175,3 +191,4 @@ def test_custom_names():\n     assert A.x._pretty_form == 'A_x'\n     assert A.i._latex_form == r'\\mathbf{{i}_{A}}'\n     assert A.x._latex_form == r\"\\mathbf{\\hat{x}_{A}}\"\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-14817",
        "model_patch": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 9e8bfc5790..d90376ffdf 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -6121,6 +6121,24 @@ def test_MatrixSymbol_printing():\n     assert pretty(A - B) == \"-B + A\"\n     assert pretty(A*B*C - A*B - B*C) == \"-A*B -B*C + A*B*C\"\n \n+def test_MatAdd_with_special_chars():\n+    n = Symbol('n', integer=True)\n+    X = MatrixSymbol('X', n, n)\n+    Y = MatrixSymbol('Y*', n, n)\n+    # Test that MatAdd with a MatrixSymbol containing special characters can be pretty printed\n+    expr = X + Y\n+    # This should not raise an exception\n+    result = pretty(expr)\n+    # Verify the result contains both matrix symbols\n+    assert 'X' in result\n+    assert 'Y*' in result\n+    # Test with a negative coefficient\n+    expr2 = X - Y\n+    result2 = pretty(expr2)\n+    assert 'X' in result2\n+    assert 'Y*' in result2\n+\n+\n \n def test_degree_printing():\n     expr1 = 90*degree\n@@ -6145,3 +6163,4 @@ def test_vector_expr_pretty_printing():\n \n     assert upretty(Gradient(A.x+3*A.y)) == u(\"\u2207\u22c5(A_x + 3\u22c5A_y)\")\n     # TODO: add support for ASCII pretty.\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pallets__flask-4045",
        "model_patch": "diff --git a/tests/test_blueprints.py b/tests/test_blueprints.py\nindex b986ca02..ebe2d2dd 100644\n--- a/tests/test_blueprints.py\n+++ b/tests/test_blueprints.py\n@@ -899,3 +899,10 @@ def test_nested_blueprint(app, client):\n     assert client.get(\"/parent/no\").data == b\"Parent no\"\n     assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n     assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"\n+\n+def test_blueprint_name_with_dot_raises_error(app):\n+    with pytest.raises(ValueError) as excinfo:\n+        flask.Blueprint(\"name.with.dot\", __name__)\n+    assert \"Blueprint name 'name.with.dot' contains a dot\" in str(excinfo.value)\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-24909",
        "model_patch": "diff --git a/sympy/physics/units/tests/test_prefixes.py b/sympy/physics/units/tests/test_prefixes.py\nindex 8a7ae3a2c4..0080b34311 100644\n--- a/sympy/physics/units/tests/test_prefixes.py\n+++ b/sympy/physics/units/tests/test_prefixes.py\n@@ -83,3 +83,24 @@ def test_bases():\n def test_repr():\n     assert eval(repr(kilo)) == kilo\n     assert eval(repr(kibi)) == kibi\n+\n+def test_prefix_multiplication():\n+    from sympy.physics.units import W, V\n+    from sympy.physics.units import milli\n+    # Test that milli*W returns a scaled quantity, not 1\n+    result = milli*W\n+    assert result != 1\n+    assert isinstance(result, Mul)\n+    assert result.args[0] == milli.scale_factor\n+    assert result.args[1] == W\n+    # Test that W*milli also works correctly\n+    result_reversed = W*milli\n+    assert result_reversed == result\n+    # Test with another unit\n+    result_v = milli*V\n+    assert result_v != 1\n+    assert isinstance(result_v, Mul)\n+    assert result_v.args[0] == milli.scale_factor\n+    assert result_v.args[1] == V\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sphinx-doc__sphinx-8506",
        "model_patch": "diff --git a/tests/test_directive_other.py b/tests/test_directive_other.py\nindex 52e4a937c..efb96fc52 100644\n--- a/tests/test_directive_other.py\n+++ b/tests/test_directive_other.py\n@@ -156,3 +156,22 @@ def test_toctree_twice(app):\n     assert_node(doctree[0][0],\n                 entries=[(None, 'foo'), (None, 'foo')],\n                 includefiles=['foo', 'foo'])\n+\n+def test_option_with_nonstandard_syntax(app):\n+    \"\"\"Test that option directive accepts non-standard syntax.\"\"\"\n+    text = \"\"\"\n+    .. option:: [enable=]PATTERN\n+       Immediately enable events matching *PATTERN*\n+    \"\"\"\n+    doctree = restructuredtext.parse(text, app)\n+    # Check that the option directive was parsed correctly\n+    assert_node(doctree, [nodes.document, nodes.definition_list, nodes.definition_list_item, (nodes.term, nodes.definition)])\n+    # Check that the term contains the option with the correct text\n+    option_node = doctree[0][0][0][0]\n+    assert isinstance(option_node, addnodes.desc_name)\n+    assert option_node.astext() == '[enable=]PATTERN'\n+    # Check that the definition contains the description text\n+    definition = doctree[0][0][1]\n+    assert definition.astext().strip() == 'Immediately enable events matching PATTERN'\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-16816",
        "model_patch": "diff --git a/tests/modeladmin/test_checks.py b/tests/modeladmin/test_checks.py\nindex 85f2eda69e..d8b067610d 100644\n--- a/tests/modeladmin/test_checks.py\n+++ b/tests/modeladmin/test_checks.py\n@@ -554,6 +554,24 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E109\",\n         )\n \n+    def test_list_display_related_model_name(self):\n+        \"\"\"\n+        list_display with a related model name should raise an error.\n+        \"\"\"\n+        class ForeignKeyModel(Model):\n+            name = ForeignKey(ValidationTestModel, on_delete=CASCADE)\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = ['name']  # 'name' is a ForeignKey, not a field on ValidationTestModel\n+        self.assertIsInvalid(\n+            TestModelAdmin, ValidationTestModel,\n+            \"The value of 'list_display[0]' refers to 'name', which is not a \"\n+            \"callable, an attribute of 'TestModelAdmin', or an attribute or \"\n+            \"method on 'admin.ValidationTestModel'.\",\n+            id='admin.E108',\n+        )\n+    \n+\n+\n     def test_valid_case(self):\n         @admin.display\n         def a_callable(obj):\n@@ -1606,3 +1624,4 @@ class ActionsCheckTests(CheckTestCase):\n             actions = (action1, action2)\n \n         self.assertIsValid(BandAdmin, Band)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-13177",
        "model_patch": "diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex 06d65203fb..657d1bb75b 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1497,6 +1497,7 @@ def test_issue_5919():\n     assert (x/(y*(1 + y))).expand() == x/(y**2 + y)\n \n \n+\n def test_Mod():\n     assert Mod(x, 1).func is Mod\n     assert pi % pi == S.Zero\n@@ -1512,7 +1513,6 @@ def test_Mod():\n     assert Mod(nan, 1) == nan\n     assert Mod(1, nan) == nan\n     assert Mod(nan, nan) == nan\n-\n     # Float handling\n     point3 = Float(3.3) % 1\n     assert (x - 3.3) % 1 == Mod(1.*x + 1 - point3, 1)\n@@ -1528,7 +1528,6 @@ def test_Mod():\n     assert comp(e, .6) and e.is_Float\n     e = Mod(Rational(13, 10), Rational(7, 10))\n     assert comp(e, .6) and e.is_Rational\n-\n     # check that sign is right\n     r2 = sqrt(2)\n     r3 = sqrt(3)\n@@ -1539,7 +1538,6 @@ def test_Mod():\n         for _y in range(9):\n             reps = [(x, _x), (y, _y)]\n             assert Mod(3*x + y, 9).subs(reps) == (3*_x + _y) % 9\n-\n     # denesting\n     #   easy case\n     assert Mod(Mod(x, y), y) == Mod(x, y)\n@@ -1548,7 +1546,6 @@ def test_Mod():\n         for j in [-3, -2, 2, 3]:\n             for k in range(3):\n                 assert Mod(Mod(k, i), j) == (k % i) % j\n-\n     # known difference\n     assert Mod(5*sqrt(2), sqrt(5)) == 5*sqrt(2) - 3*sqrt(5)\n     p = symbols('p', positive=True)\n@@ -1557,25 +1554,21 @@ def test_Mod():\n     assert Mod(n - 3, n - 1) == -2\n     assert Mod(n - 2*p, n - p) == -p\n     assert Mod(p - 2*n, p - n) == -n\n-\n     # handling sums\n     assert (x + 3) % 1 == Mod(x, 1)\n     assert (x + 3.0) % 1 == Mod(1.*x, 1)\n     assert (x - S(33)/10) % 1 == Mod(x + S(7)/10, 1)\n-\n     a = Mod(.6*x + y, .3*y)\n     b = Mod(0.1*y + 0.6*x, 0.3*y)\n     # Test that a, b are equal, with 1e-14 accuracy in coefficients\n     eps = 1e-14\n     assert abs((a.args[0] - b.args[0]).subs({x: 1, y: 1})) < eps\n     assert abs((a.args[1] - b.args[1]).subs({x: 1, y: 1})) < eps\n-\n     assert (x + 1) % x == 1 % x\n     assert (x + y) % x == y % x\n     assert (x + y + 2) % x == (y + 2) % x\n     assert (a + 3*x + 1) % (2*x) == Mod(a + x + 1, 2*x)\n     assert (12*x + 18*y) % (3*x) == 3*Mod(6*y, x)\n-\n     # gcd extraction\n     assert (-3*x) % (-2*y) == -Mod(3*x, 2*y)\n     assert (.6*pi) % (.3*x*pi) == 0.3*pi*Mod(2, x)\n@@ -1593,19 +1586,31 @@ def test_Mod():\n     i = Symbol('i', integer=True)\n     assert (3*i*x) % (2*i*y) == i*Mod(3*x, 2*y)\n     assert Mod(4*i, 4) == 0\n-\n     # issue 8677\n     n = Symbol('n', integer=True, positive=True)\n     assert (factorial(n) % n).equals(0) is not False\n-\n     # symbolic with known parity\n     n = Symbol('n', even=True)\n     assert Mod(n, 2) == 0\n     n = Symbol('n', odd=True)\n     assert Mod(n, 2) == 1\n-\n     # issue 10963\n     assert (x**6000%400).args[1] == 400\n+    # Test for Mod(x**2, x) with non-integer x\n+    # This should fail with the current implementation\n+    # but pass after the fix\n+    x_float = Float(1.5)\n+    assert Mod(x_float**2, x_float) == Float(0.75)\n+    # Test with symbolic x\n+    x_sym = Symbol('x_sym')\n+    # For symbolic x, we can't determine if it's an integer\n+    # so Mod(x_sym**2, x_sym) should not simplify to 0\n+    assert Mod(x_sym**2, x_sym) != S.Zero\n+    # Test with integer x\n+    x_int = Symbol('x_int', integer=True)\n+    # For integer x, Mod(x_int**2, x_int) should be 0\n+    assert Mod(x_int**2, x_int) == S.Zero\n+\n \n \n def test_Mod_is_integer():\n@@ -1902,3 +1907,4 @@ def test_issue_8247_8354():\n def test_Add_is_zero():\n     x, y = symbols('x y', zero=True)\n     assert (x + y).is_zero\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "scikit-learn__scikit-learn-10949",
        "model_patch": "diff --git a/sklearn/utils/tests/test_validation.py b/sklearn/utils/tests/test_validation.py\nindex 00182fa0aa..5476947577 100644\n--- a/sklearn/utils/tests/test_validation.py\n+++ b/sklearn/utils/tests/test_validation.py\n@@ -425,6 +425,28 @@ def test_check_array_dtype_warning():\n     assert_false(X_checked is X_csc_float32)\n     assert_equal(X_checked.format, 'csr')\n \n+def test_check_array_dtype_warning_dataframe():\n+    import pandas as pd\n+    # Test that warn_on_dtype works with pandas DataFrame\n+    X_int_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n+    # Create a DataFrame with object dtype\n+    X_df_obj = pd.DataFrame(X_int_list, dtype=object)\n+    # Check that warning is raised when warn_on_dtype=True\n+    X_checked = assert_warns(DataConversionWarning, check_array, X_df_obj,\n+                             dtype=np.float64, warn_on_dtype=True)\n+    assert_equal(X_checked.dtype, np.float64)\n+    # Check that warning message includes estimator name\n+    X_checked = assert_warns_message(DataConversionWarning, 'TestEstimator',\n+                                     check_array, X_df_obj,\n+                                     dtype=np.float64, warn_on_dtype=True,\n+                                     estimator='TestEstimator')\n+    assert_equal(X_checked.dtype, np.float64)\n+    # No warning when warn_on_dtype=False\n+    X_checked = assert_no_warnings(check_array, X_df_obj,\n+                                   dtype=np.float64, warn_on_dtype=False)\n+    assert_equal(X_checked.dtype, np.float64)\n+\n+\n \n def test_check_array_accept_sparse_type_exception():\n     X = [[1, 2], [3, 4]]\n@@ -748,3 +770,4 @@ def test_check_array_memmap(copy):\n         X_checked = check_array(X_memmap, copy=copy)\n         assert np.may_share_memory(X_memmap, X_checked) == (not copy)\n         assert X_checked.flags['WRITEABLE'] == copy\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11019",
        "model_patch": "diff --git a/tests/forms_tests/tests/test_media.py b/tests/forms_tests/tests/test_media.py\nindex 8cb484a15e..cf2ba9921c 100644\n--- a/tests/forms_tests/tests/test_media.py\n+++ b/tests/forms_tests/tests/test_media.py\n@@ -571,3 +571,22 @@ class FormsMediaTestCase(SimpleTestCase):\n         # was never specified.\n         merged = widget3 + form1 + form2\n         self.assertEqual(merged._css, {'screen': ['a.css', 'b.css'], 'all': ['c.css']})\n+\n+    def test_merge_media_three_way_with_dependencies(self):\n+        \"\"\"\n+        Test that merging 3 or more media objects with dependencies\n+        doesn't throw unnecessary MediaOrderConflictWarnings.\n+        \"\"\"\n+        # Define media objects with dependencies\n+        color_picker = Media(js=['color-picker.js'])\n+        simple_text = Media(js=['text-editor.js'])\n+        fancy_text = Media(js=['text-editor.js', 'text-editor-extras.js', 'color-picker.js'])\n+        # Merge the media objects\n+        form_media = color_picker + simple_text + fancy_text\n+        # The correct order should have text-editor.js before text-editor-extras.js\n+        # and should include all files without duplicates\n+        expected_js = ['text-editor.js', 'text-editor-extras.js', 'color-picker.js']\n+        self.assertEqual(form_media._js, expected_js)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-24152",
        "model_patch": "diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py\nindex f1765640ea..5dba2ff903 100644\n--- a/sympy/physics/quantum/tests/test_tensorproduct.py\n+++ b/sympy/physics/quantum/tests/test_tensorproduct.py\n@@ -45,6 +45,25 @@ def test_tensor_product_expand():\n     assert TP(A + B, B + C).expand(tensorproduct=True) == \\\n         TP(A, B) + TP(A, C) + TP(B, B) + TP(B, C)\n \n+def test_tensor_product_expand_with_scalar_factors():\n+    from sympy.physics.quantum.operator import Operator\n+    U = Operator('U')\n+    V = Operator('V')\n+    # Test case from the issue description\n+    P = TensorProduct(2*U - V, U + V)\n+    expanded = P.expand(tensorproduct=True)\n+    # The correct expansion should be:\n+    # 2*U\u2297U + 2*U\u2297V - V\u2297U - V\u2297V\n+    expected = 2*TensorProduct(U, U) + 2*TensorProduct(U, V) - TensorProduct(V, U) - TensorProduct(V, V)\n+    assert expanded == expected\n+    # Additional test case with more complex scalar factors\n+    Q = TensorProduct(3*U + 2*V, 4*U - V)\n+    expanded_Q = Q.expand(tensorproduct=True)\n+    expected_Q = (3*4)*TensorProduct(U, U) + (3*(-1))*TensorProduct(U, V) + \\\n+                 (2*4)*TensorProduct(V, U) + (2*(-1))*TensorProduct(V, V)\n+    assert expanded_Q == expected_Q\n+\n+\n \n def test_tensor_product_commutator():\n     assert TP(Comm(A, B), C).doit().expand(tensorproduct=True) == \\\n@@ -118,3 +137,4 @@ def test_eval_trace():\n                         1.0*A*Dagger(C)*Tr(B*Dagger(D)) +\n                         1.0*C*Dagger(A)*Tr(D*Dagger(B)) +\n                         1.0*C*Dagger(C)*Tr(D*Dagger(D)))\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-18087",
        "model_patch": "diff --git a/sympy/simplify/tests/test_trigsimp.py b/sympy/simplify/tests/test_trigsimp.py\nindex bf15ee07a9..293fb33e42 100644\n--- a/sympy/simplify/tests/test_trigsimp.py\n+++ b/sympy/simplify/tests/test_trigsimp.py\n@@ -153,39 +153,33 @@ def test_issue_3210():\n         ]\n \n \n+\n def test_trigsimp_issues():\n     a, x, y = symbols('a x y')\n-\n     # issue 4625 - factor_terms works, too\n     assert trigsimp(sin(x)**3 + cos(x)**2*sin(x)) == sin(x)\n-\n     # issue 5948\n     assert trigsimp(diff(integrate(cos(x)/sin(x)**3, x), x)) == \\\n         cos(x)/sin(x)**3\n     assert trigsimp(diff(integrate(sin(x)/cos(x)**3, x), x)) == \\\n         sin(x)/cos(x)**3\n-\n     # check integer exponents\n     e = sin(x)**y/cos(x)**y\n     assert trigsimp(e) == e\n     assert trigsimp(e.subs(y, 2)) == tan(x)**2\n     assert trigsimp(e.subs(x, 1)) == tan(1)**y\n-\n     # check for multiple patterns\n     assert (cos(x)**2/sin(x)**2*cos(y)**2/sin(y)**2).trigsimp() == \\\n         1/tan(x)**2/tan(y)**2\n     assert trigsimp(cos(x)/sin(x)*cos(x+y)/sin(x+y)) == \\\n         1/(tan(x)*tan(x + y))\n-\n     eq = cos(2)*(cos(3) + 1)**2/(cos(3) - 1)**2\n     assert trigsimp(eq) == eq.factor()  # factor makes denom (-1 + cos(3))**2\n     assert trigsimp(cos(2)*(cos(3) + 1)**2*(cos(3) - 1)**2) == \\\n         cos(2)*sin(3)**4\n-\n     # issue 6789; this generates an expression that formerly caused\n     # trigsimp to hang\n     assert cot(x).equals(tan(x)) is False\n-\n     # nan or the unchanged expression is ok, but not sin(1)\n     z = cos(x)**2 + sin(x)**2 - 1\n     z1 = tan(x)**2 - 1/cot(x)**2\n@@ -195,8 +189,13 @@ def test_trigsimp_issues():\n     assert trigsimp(eq) is S.NaN\n     assert trigsimp(eq, recursive=True) is S.NaN\n     assert trigsimp(1).is_Integer\n-\n     assert trigsimp(-sin(x)**4 - 2*sin(x)**2*cos(x)**2 - cos(x)**4) == -1\n+    # Test for the issue where trigsimp incorrectly simplifies sqrt(sin(x)**2)\n+    # For complex x, sqrt(sin(x)**2) is not equal to sin(x)\n+    expr = cos(x) + sqrt(sin(x)**2)\n+    # The expression should remain unchanged for general complex x\n+    assert trigsimp(expr) == expr\n+\n \n \n def test_trigsimp_issue_2515():\n@@ -481,3 +480,4 @@ def test_trigsimp_old():\n     assert trigsimp(sin(x)/cos(x), old=True, method='groebner', hints=[tan]) == tan(x)\n \n     assert trigsimp(1-sin(sin(x)**2+cos(x)**2)**2, old=True, deep=True) == cos(1)**2\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "mwaskom__seaborn-3407",
        "model_patch": "diff --git a/tests/test_axisgrid.py b/tests/test_axisgrid.py\nindex ce8b0eaa..4b1ebf66 100644\n--- a/tests/test_axisgrid.py\n+++ b/tests/test_axisgrid.py\n@@ -1410,6 +1410,27 @@ class TestPairGrid:\n \n         assert_plots_equal(ax1, ax2, labels=False)\n \n+    def test_pairplot_multiindex(self):\n+        \"\"\"Test that pairplot works with MultiIndex DataFrame.\"\"\"\n+        # Create a MultiIndex DataFrame\n+        data = {\n+            (\"A\", \"1\"): np.random.rand(100),\n+            (\"A\", \"2\"): np.random.rand(100),\n+            (\"B\", \"1\"): np.random.rand(100),\n+            (\"B\", \"2\"): np.random.rand(100),\n+        }\n+        df = pd.DataFrame(data)\n+        # This should not raise a KeyError\n+        g = ag.pairplot(df)\n+        # Basic validation that the plot was created correctly\n+        assert isinstance(g, ag.PairGrid)\n+        assert len(g.diag_axes) == 4  # Should have 4 diagonal axes\n+        assert g.data is df  # The data should be preserved\n+        # Clean up\n+        plt.close(\"all\")\n+    \n+\n+\n     def test_pairplot_markers(self):\n \n         vars = [\"x\", \"y\", \"z\"]\n@@ -1843,3 +1864,4 @@ class TestJointPlot:\n         with pytest.warns(UserWarning):\n             g = ag.jointplot(data=long_df, x=\"x\", y=\"y\", ax=ax)\n         assert g.ax_joint.collections\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-13480",
        "model_patch": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\nindex dd9ebd72a2..8067ac8560 100644\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -882,6 +882,17 @@ def test_coth_rewrite():\n     assert coth(x).rewrite(cosh) == -I*cosh(x)/cosh(I*pi/2 - x)\n     assert coth(x).rewrite(tanh) == 1/tanh(x)\n \n+def test_coth_subs_issue():\n+    x = Symbol('x')\n+    e = coth(log(tan(x)))\n+    # Test substitution with values that were causing errors\n+    for val in [2, 3, 5, 6, 8, 9, 11, 12]:\n+        # This should not raise a NameError\n+        result = e.subs(x, val)\n+        # The result should be a valid expression\n+        assert result.is_finite is not None\n+\n+\n \n def test_csch_rewrite():\n     x = Symbol('x')\n@@ -935,3 +946,4 @@ def test_cosh_expansion():\n     assert cosh(2*x).expand(trig=True) == cosh(x)**2 + sinh(x)**2\n     assert cosh(3*x).expand(trig=True).expand() == \\\n         3*sinh(x)**2*cosh(x) + cosh(x)**3\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12747",
        "model_patch": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex d8424670c9..413e70bcf1 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -530,6 +530,31 @@ class DeletionTests(TestCase):\n         for k, v in existed_objs.items():\n             self.assertEqual(deleted_objs[k], v)\n \n+    def test_empty_queryset_delete_consistency(self):\n+        \"\"\"\n+        QuerySet.delete() should return consistent results when deleting\n+        empty querysets, regardless of whether the model has foreign keys.\n+        \"\"\"\n+        # Delete all existing Avatar objects (model without foreign keys)\n+        Avatar.objects.all().delete()\n+        # Ensure the queryset is empty\n+        self.assertEqual(Avatar.objects.count(), 0)\n+        # Delete an empty queryset and check the result format\n+        deleted, rows_count = Avatar.objects.all().delete()\n+        self.assertEqual(deleted, 0)\n+        self.assertEqual(rows_count, {Avatar._meta.label: 0})\n+        # Delete all existing HiddenUser objects (model with foreign keys)\n+        HiddenUser.objects.all().delete()\n+        # Ensure the queryset is empty\n+        self.assertEqual(HiddenUser.objects.count(), 0)\n+        # Delete an empty queryset and check the result format\n+        deleted, rows_count = HiddenUser.objects.all().delete()\n+        self.assertEqual(deleted, 0)\n+        # This will fail on the current implementation but should pass after the fix\n+        self.assertEqual(rows_count, {HiddenUser._meta.label: 0})\n+    \n+\n+\n     def test_model_delete_returns_num_rows(self):\n         \"\"\"\n         Model.delete() should return the number of deleted rows and a\n@@ -704,3 +729,4 @@ class FastDeleteTests(TestCase):\n         referer = Referrer.objects.create(origin=origin, unique_field=42)\n         with self.assertNumQueries(2):\n             referer.delete()\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-15345",
        "model_patch": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex dd636d0623..7bd37e1d7a 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -90,3 +90,15 @@ def test_Sum():\n                      (y, -oo, oo))) == \\\n         \"Hold[Sum[Exp[-x^2 - y^2], {x, -Infinity, Infinity}, \" \\\n         \"{y, -Infinity, Infinity}]]\"\n+\n+def test_Max_Min():\n+    from sympy.functions.elementary.miscellaneous import Max, Min\n+    x, y = symbols('x y')\n+    # Test Max function - should produce Max[x, 2] not Max(2, x)\n+    assert mcode(Max(x, 2)) == \"Max[x, 2]\"\n+    assert mcode(Max(x, y, 3)) == \"Max[x, y, 3]\"\n+    # Test Min function similarly\n+    assert mcode(Min(x, 2)) == \"Min[x, 2]\"\n+    assert mcode(Min(x, y, 3)) == \"Min[x, y, 3]\"\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-21379",
        "model_patch": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\nindex 8a3d81d158..d855f59012 100644\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -862,3 +862,31 @@ def test_issue_19558():\n \n     assert e.subs(x, oo) == AccumBounds(-oo, oo)\n     assert (sin(x) + cos(x)).subs(x, oo) == AccumBounds(-2, 2)\n+\n+def test_piecewise_subs_with_real_symbols():\n+    from sympy.core.cache import clear_cache\n+    from sympy.functions.elementary.hyperbolic import sinh\n+    from sympy.functions.elementary.hyperbolic import cosh\n+    from sympy.functions.elementary.hyperbolic import tanh\n+    # Clear cache to ensure consistent behavior\n+    clear_cache()\n+    # Test with non-real symbols - should work fine\n+    x1, y1, z1 = symbols('x1 y1 z1')\n+    expr1 = exp(sinh(Piecewise((x1, y1 > x1), (y1, True)) / z1))\n+    # This should work without error\n+    assert expr1.subs({1: 1.0}) is not None\n+    # Test with real symbols - was causing PolynomialError\n+    clear_cache()\n+    x2, y2, z2 = symbols('x2 y2 z2', real=True)\n+    expr2 = exp(sinh(Piecewise((x2, y2 > x2), (y2, True)) / z2))\n+    # This should work without error but was failing\n+    assert expr2.subs({1: 1.0}) is not None\n+    # Test with other hyperbolic functions\n+    clear_cache()\n+    expr3 = exp(cosh(Piecewise((x2, y2 > x2), (y2, True)) / z2))\n+    assert expr3.subs({1: 1.0}) is not None\n+    clear_cache()\n+    expr4 = exp(tanh(Piecewise((x2, y2 > x2), (y2, True)) / z2))\n+    assert expr4.subs({1: 1.0}) is not None\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "astropy__astropy-12907",
        "model_patch": "diff --git a/astropy/modeling/tests/test_separable.py b/astropy/modeling/tests/test_separable.py\nindex 8dfe5c8626..3a75790a41 100644\n--- a/astropy/modeling/tests/test_separable.py\n+++ b/astropy/modeling/tests/test_separable.py\n@@ -148,3 +148,33 @@ def test_custom_model_separable():\n \n     assert not model_c().separable\n     assert np.all(separability_matrix(model_c()) == [True, True])\n+\n+def test_nested_compound_model_separability():\n+    \"\"\"\n+    Test that separability_matrix correctly computes separability for nested CompoundModels.\n+    \"\"\"\n+    # Create a compound model\n+    cm = models.Linear1D(10) & models.Linear1D(5)\n+    # Test the separability matrix of the compound model\n+    expected_cm = np.array([[True, False], [False, True]])\n+    assert_allclose(separability_matrix(cm), expected_cm)\n+    # Test a more complex model\n+    complex_model = models.Pix2Sky_TAN() & models.Linear1D(10) & models.Linear1D(5)\n+    expected_complex = np.array([\n+        [True, True, False, False],\n+        [True, True, False, False],\n+        [False, False, True, False],\n+        [False, False, False, True]\n+    ])\n+    assert_allclose(separability_matrix(complex_model), expected_complex)\n+    # Test a nested compound model\n+    nested_model = models.Pix2Sky_TAN() & cm\n+    expected_nested = np.array([\n+        [True, True, False, False],\n+        [True, True, False, False],\n+        [False, False, True, False],\n+        [False, False, False, True]\n+    ])\n+    assert_allclose(separability_matrix(nested_model), expected_nested)\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-5495",
        "model_patch": "diff --git a/testing/test_assertion.py b/testing/test_assertion.py\nindex 0fcfd9f27..bdb6c3624 100644\n--- a/testing/test_assertion.py\n+++ b/testing/test_assertion.py\n@@ -1271,6 +1271,22 @@ def test_issue_1944(testdir):\n         not in result.stdout.str()\n     )\n \n+def test_assertrewrite_bytes_comparison_message(testdir):\n+    testdir.makepyfile(\"\"\"\n+        def test_bytes_comparison():\n+            assert b\"\" == b\"42\"\n+    \"\"\")\n+    result = testdir.runpytest()\n+    result.stdout.fnmatch_lines([\n+        \"E       AssertionError: assert b'' == b'42'\",\n+        \"E         Right contains more items, first extra item: b'4'\",  # Should show the byte character, not the ordinal\n+        \"E         Full diff:\",\n+        \"E         - b''\",\n+        \"E         + b'42'\",\n+        \"E         ?   ++\",\n+    ])\n+\n+\n \n def test_exit_from_assertrepr_compare(monkeypatch):\n     def raise_exit(obj):\n@@ -1280,3 +1296,4 @@ def test_exit_from_assertrepr_compare(monkeypatch):\n \n     with pytest.raises(outcomes.Exit, match=\"Quitting debugger\"):\n         callequal(1, 1)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-7168",
        "model_patch": "diff --git a/testing/io/test_saferepr.py b/testing/io/test_saferepr.py\nindex 06084202e..2bf895392 100644\n--- a/testing/io/test_saferepr.py\n+++ b/testing/io/test_saferepr.py\n@@ -149,8 +149,23 @@ def test_unicode():\n     reprval = \"'\u00a3\u20ac'\"\n     assert saferepr(val) == reprval\n \n+def test_saferepr_handles_exception_in_repr():\n+    \"\"\"Test that saferepr handles exceptions in __repr__ without causing INTERNALERROR.\"\"\"\n+    class SomeClass:\n+        def __getattribute__(self, attr):\n+            raise RuntimeError(\"Error in __getattribute__\")\n+        def __repr__(self):\n+            raise RuntimeError(\"Error in __repr__\")\n+    # This should not cause an INTERNALERROR, but instead return a string\n+    # representation indicating the exception\n+    result = saferepr(SomeClass())\n+    assert \"Error in __repr__\" in result\n+    assert \"<SomeClass object at\" in result\n+\n+\n \n def test_pformat_dispatch():\n     assert _pformat_dispatch(\"a\") == \"'a'\"\n     assert _pformat_dispatch(\"a\" * 10, width=5) == \"'aaaaaaaaaa'\"\n     assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pallets__flask-5063",
        "model_patch": "diff --git a/tests/test_cli.py b/tests/test_cli.py\nindex 0d9625b1..12806fad 100644\n--- a/tests/test_cli.py\n+++ b/tests/test_cli.py\n@@ -498,6 +498,43 @@ class TestRoutes:\n         assert result.exit_code == 0\n         assert \"No routes were registered.\" in result.output\n \n+    def test_routes_command_with_subdomains(app, runner):\n+        from flask.cli import cli\n+        \"\"\"Test that routes command shows subdomain information.\"\"\"\n+        admin_bp = Blueprint(\"admin_blueprint\", __name__)\n+        test_subdomain_bp = Blueprint(\"test_subdomain_blueprint\", __name__)\n+        @admin_bp.route(\"/home\")\n+        def home():\n+            return \"Admin Home\"\n+        @test_subdomain_bp.route(\"/home\")\n+        def home():\n+            return \"Test Subdomain Home\"\n+        app.config[\"SERVER_NAME\"] = \"test.local\"\n+        app.register_blueprint(admin_bp, subdomain=\"admin\")\n+        app.register_blueprint(test_subdomain_bp, subdomain=\"test\")\n+        result = runner.invoke(cli, [\"routes\"])\n+        assert result.exit_code == 0\n+        # Check that the output contains the domain column header\n+        assert \"Domain\" in result.output\n+        # Check that the output contains the specific subdomains\n+        assert \"admin.test.local\" in result.output\n+        assert \"test.test.local\" in result.output\n+        assert \"test.local\" in result.output\n+        # Check that the routes are correctly associated with their subdomains\n+        output_lines = result.output.splitlines()\n+        admin_line_index = next((i for i, line in enumerate(output_lines) \n+                                if \"admin_blueprint.home\" in line), None)\n+        test_subdomain_line_index = next((i for i, line in enumerate(output_lines) \n+                                        if \"test_subdomain_blueprint.home\" in line), None)\n+        assert admin_line_index is not None\n+        assert test_subdomain_line_index is not None\n+        admin_line = output_lines[admin_line_index]\n+        test_subdomain_line = output_lines[test_subdomain_line_index]\n+        assert \"admin.test.local\" in admin_line\n+        assert \"test.test.local\" in test_subdomain_line\n+    \n+\n+\n \n def dotenv_not_available():\n     try:\n@@ -676,3 +713,4 @@ def test_cli_empty(app):\n \n     result = app.test_cli_runner().invoke(args=[\"blue\", \"--help\"])\n     assert result.exit_code == 2, f\"Unexpected success:\\n\\n{result.output}\"\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-6116",
        "model_patch": "diff --git a/testing/test_parseopt.py b/testing/test_parseopt.py\nindex 915747378..6e31f1fb0 100644\n--- a/testing/test_parseopt.py\n+++ b/testing/test_parseopt.py\n@@ -289,6 +289,30 @@ class TestParser:\n         help = parser.optparser.format_help()\n         assert \"--preferences=value1 value2 value3\" in help\n \n+    def test_collect_only_shortcut(parser):\n+        \"\"\"Test that --collect-only has a single character shortcut.\"\"\"\n+        group = parser.getgroup(\"collect\")\n+        group.addoption(\"--test\", action=\"store_true\", help=\"temp option\")\n+        # Parse the help output to check for a short option for --collect-only\n+        parser._getparser()\n+        help_text = parser._getparser().format_help()\n+        # The test should check that there's a short option like -C or similar for --collect-only\n+        # This will fail until the feature is implemented\n+        assert \"--collect-only\" in help_text\n+        # Look for a pattern like \"-X, --collect-only\" where X is a single character\n+        import re\n+        collect_only_pattern = re.compile(r\"-([a-zA-Z]), --collect-only\")\n+        match = collect_only_pattern.search(help_text)\n+        assert match is not None, \"No single character shortcut found for --collect-only\"\n+        shortcut = match.group(1)\n+        assert len(shortcut) == 1, f\"Expected single character shortcut, got: {shortcut}\"\n+        # Verify the shortcut works by parsing args with it\n+        option = f\"-{shortcut}\"\n+        args = parser.parse_args([option])\n+        assert args.collectonly is True\n+    \n+\n+\n \n def test_argcomplete(testdir, monkeypatch):\n     if not distutils.spawn.find_executable(\"bash\"):\n@@ -332,3 +356,4 @@ def test_argcomplete(testdir, monkeypatch):\n     monkeypatch.setenv(\"COMP_POINT\", str(len(\"pytest \" + arg)))\n     result = testdir.run(\"bash\", str(script), arg)\n     result.stdout.fnmatch_lines([\"test_argcomplete\", \"test_argcomplete.d/\"])\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-15308",
        "model_patch": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 9f644f15ee..23f10622d8 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1394,6 +1394,18 @@ def test_Tr():\n     t = Tr(A*B)\n     assert latex(t) == r'\\mbox{Tr}\\left(A B\\right)'\n \n+def test_trace_latex_printing():\n+    n = Symbol('n')\n+    A = MatrixSymbol('A', n, n)\n+    # Test that trace of matrix power is printed correctly\n+    expr = Tr(A**2)\n+    assert latex(expr) == r'\\mbox{Tr}\\left(A^{2}\\right)'\n+    # Test with more complex matrix expression\n+    B = MatrixSymbol('B', n, n)\n+    expr2 = Tr(A*B)\n+    assert latex(expr2) == r'\\mbox{Tr}\\left(A B\\right)'\n+\n+\n \n def test_Adjoint():\n     from sympy.matrices import MatrixSymbol, Adjoint, Inverse, Transpose\n@@ -1866,3 +1878,4 @@ def test_latex_printer_tensor():\n \n     expr = TensorElement(K(i,j,-k,-l), {i:3})\n     assert latex(expr) == 'K{}^{i=3,j}{}_{kl}'\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "astropy__astropy-7746",
        "model_patch": "diff --git a/astropy/wcs/tests/test_wcs.py b/astropy/wcs/tests/test_wcs.py\nindex 85853e10e5..4087d8bb6d 100644\n--- a/astropy/wcs/tests/test_wcs.py\n+++ b/astropy/wcs/tests/test_wcs.py\n@@ -1093,3 +1093,31 @@ def test_keyedsip():\n     assert isinstance( w.sip, wcs.Sip )\n     assert w.sip.crpix[0] == 2048\n     assert w.sip.crpix[1] == 1026\n+\n+def test_empty_input_arrays():\n+    \"\"\"Test that WCS transformations handle empty arrays properly.\"\"\"\n+    # Create a simple WCS object\n+    w = wcs.WCS(naxis=2)\n+    w.wcs.crpix = [1, 1]\n+    w.wcs.cdelt = [1, 1]\n+    w.wcs.crval = [1, 1]\n+    # Test with empty lists\n+    empty_result = w.wcs_pix2world([], [], 0)\n+    assert len(empty_result) == 2\n+    assert len(empty_result[0]) == 0\n+    assert len(empty_result[1]) == 0\n+    # Test with empty numpy arrays\n+    empty_arrays = w.wcs_pix2world(np.array([]), np.array([]), 0)\n+    assert len(empty_arrays) == 2\n+    assert len(empty_arrays[0]) == 0\n+    assert len(empty_arrays[1]) == 0\n+    # Test with empty array in the Nx2 format\n+    empty_nx2 = w.wcs_pix2world(np.zeros((0, 2)), 0)\n+    assert empty_nx2.shape == (0, 2)\n+    # Also test the world2pix direction\n+    empty_world2pix = w.wcs_world2pix([], [], 0)\n+    assert len(empty_world2pix) == 2\n+    assert len(empty_world2pix[0]) == 0\n+    assert len(empty_world2pix[1]) == 0\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sphinx-doc__sphinx-8801",
        "model_patch": "diff --git a/tests/test_ext_autodoc_autoclass.py b/tests/test_ext_autodoc_autoclass.py\nindex 488b72263..f98093f4f 100644\n--- a/tests/test_ext_autodoc_autoclass.py\n+++ b/tests/test_ext_autodoc_autoclass.py\n@@ -105,6 +105,41 @@ def test_inherited_instance_variable(app):\n         '',\n     ]\n \n+def test_annotation_only_inherited_member(app):\n+    text = '''\n+    class Foo:\n+        \"\"\"docstring\"\"\"\n+        attr1: int  #: docstring\n+    class Bar(Foo):\n+        \"\"\"docstring\"\"\"\n+        attr2: str  #: docstring\n+    '''\n+    (app.srcdir / 'annotation_inheritance.py').write_text(text)\n+    options = {'members': True,\n+               'inherited-members': True}\n+    actual = do_autodoc(app, 'class', 'annotation_inheritance.Bar', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: annotation_inheritance',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: annotation_inheritance',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: annotation_inheritance',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n+\n \n def test_decorators(app):\n     actual = do_autodoc(app, 'class', 'target.decorator.Baz')\n@@ -191,3 +226,4 @@ def test_class_alias(app):\n         '',\n         '   alias of :class:`target.classes.Foo`',\n     ]\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-10914",
        "model_patch": "diff --git a/tests/file_uploads/tests.py b/tests/file_uploads/tests.py\nindex 2824b6eb42..41ee77aed6 100644\n--- a/tests/file_uploads/tests.py\n+++ b/tests/file_uploads/tests.py\n@@ -517,6 +517,28 @@ class FileUploadTests(TestCase):\n         # shouldn't differ.\n         self.assertEqual(os.path.basename(obj.testfile.path), 'MiXeD_cAsE.txt')\n \n+    def test_file_upload_permissions(self):\n+        \"\"\"\n+        Test that uploaded files have the correct permissions (0o644 by default).\n+        \"\"\"\n+        with open(__file__, 'rb') as fp:\n+            post_data = {\n+                'name': 'Ringo',\n+                'file_field': fp,\n+            }\n+            response = self.client.post('/upload/', post_data)\n+        self.assertEqual(response.status_code, 200)\n+        # Get the file path from the response\n+        file_path = response.context['file_path']\n+        # Check file exists\n+        self.assertTrue(os.path.exists(file_path))\n+        # Check file permissions\n+        file_permissions = os.stat(file_path).st_mode & 0o777\n+        self.assertEqual(file_permissions, 0o644, \n+                         f\"File permissions {file_permissions:o} don't match expected 644\")\n+    \n+\n+\n \n @override_settings(MEDIA_ROOT=MEDIA_ROOT)\n class DirectoryCreationTests(SimpleTestCase):\n@@ -615,3 +637,4 @@ class MultiParserTests(SimpleTestCase):\n         for raw_line, expected_title in test_data:\n             parsed = parse_header(raw_line)\n             self.assertEqual(parsed[1]['title'], expected_title)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13321",
        "model_patch": "diff --git a/tests/sessions_tests/tests.py b/tests/sessions_tests/tests.py\nindex e7615d0f11..5ce7d19978 100644\n--- a/tests/sessions_tests/tests.py\n+++ b/tests/sessions_tests/tests.py\n@@ -339,6 +339,18 @@ class SessionTestsMixin:\n         # The failed decode is logged.\n         self.assertIn('corrupted', cm.output[0])\n \n+    def test_decode_invalid_base64_padding(self):\n+        \"\"\"\n+        Test that decoding invalid base64 data doesn't crash the session.\n+        \"\"\"\n+        # Create a session with invalid base64 padding\n+        session_data = 'invalid-base64-data'  # Missing padding\n+        # Decode should not raise an exception but return an empty dict\n+        decoded_data = self.session.decode(session_data)\n+        self.assertEqual(decoded_data, {})\n+    \n+\n+\n     def test_actual_expiry(self):\n         # this doesn't work with JSONSerializer (serializing timedelta)\n         with override_settings(SESSION_SERIALIZER='django.contrib.sessions.serializers.PickleSerializer'):\n@@ -903,3 +915,4 @@ class CookieSessionTests(SessionTestsMixin, SimpleTestCase):\n     @unittest.skip(\"CookieSession is stored in the client and there is no way to query it.\")\n     def test_session_save_does_not_resurrect_session_logged_out_in_other_context(self):\n         pass\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pylint-dev__pylint-7993",
        "model_patch": "diff --git a/tests/reporters/unittest_reporting.py b/tests/reporters/unittest_reporting.py\nindex 37f3e5fd9..9ba6d829f 100644\n--- a/tests/reporters/unittest_reporting.py\n+++ b/tests/reporters/unittest_reporting.py\n@@ -385,3 +385,34 @@ def test_display_results_is_renamed() -> None:\n         # pylint: disable=no-member\n         reporter.display_results()  # type: ignore[attr-defined]\n     assert \"no attribute 'display_results'\" in str(exc)\n+\n+def test_custom_braces_in_template(linter) -> None:\n+    \"\"\"Test that custom braces in message template work correctly.\"\"\"\n+    linter.set_option(\"msg-template\", '{{ \"Category\": \"{category}\" }}')\n+    out = StringIO()\n+    linter.reporter.out = out\n+    # Create a dummy message\n+    msg = Message(\n+        msg_id=\"C0103\",\n+        symbol=\"invalid-name\",\n+        msg=\"Invalid name\",\n+        confidence=HIGH,\n+        location=MessageLocationTuple(\n+            abspath=\"path/to/file.py\",\n+            path=\"path/to/file.py\",\n+            module=\"file\",\n+            obj=\"\",\n+            line=1,\n+            column=0,\n+            end_line=None,\n+            end_column=None,\n+        ),\n+    )\n+    linter.reporter.handle_message(msg)\n+    output = out.getvalue().strip()\n+    # The output should contain the JSON-like format with \"Category\" as the key\n+    assert '\"Category\": \"convention\"' in output\n+    # Make sure the output is properly formatted with double braces\n+    assert output.startswith('{ \"Category\":')\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-11797",
        "model_patch": "diff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py\nindex 0f799c4bc3..2938ad391a 100644\n--- a/tests/aggregation/tests.py\n+++ b/tests/aggregation/tests.py\n@@ -1170,3 +1170,27 @@ class AggregateTestCase(TestCase):\n             Exists(long_books_qs),\n         ).annotate(total=Count('*'))\n         self.assertEqual(dict(has_long_books_breakdown), {True: 2, False: 3})\n+\n+    def test_filter_on_subquery_preserves_groupby(self):\n+        \"\"\"\n+        Filtering on a query result should preserve the GROUP BY of the internal query.\n+        \"\"\"\n+        # Create some test data\n+        Author.objects.create(name='Author 1', age=30)\n+        Author.objects.create(name='Author 2', age=30)\n+        Author.objects.create(name='Author 3', age=40)\n+        # Create a query with GROUP BY\n+        subquery = Author.objects.filter(age=30).values('age').annotate(m=Max('id')).values('m')\n+        # Check the SQL for the subquery - should group by age\n+        self.assertIn('GROUP BY', str(subquery.query))\n+        self.assertIn('\"aggregation_author\".\"age\"', str(subquery.query))\n+        # Apply a filter using the subquery\n+        filtered_query = Author.objects.filter(id__in=subquery[:1])\n+        # The GROUP BY in the subquery should still be by age, not by id\n+        subquery_sql = str(filtered_query.query)\n+        self.assertIn('GROUP BY', subquery_sql)\n+        self.assertIn('\"aggregation_author\".\"age\"', subquery_sql)\n+        self.assertNotIn('GROUP BY U0.\"id\"', subquery_sql)\n+    \n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12497",
        "model_patch": "diff --git a/tests/m2m_through/tests.py b/tests/m2m_through/tests.py\nindex dd40e9760c..4ef6fa0537 100644\n--- a/tests/m2m_through/tests.py\n+++ b/tests/m2m_through/tests.py\n@@ -484,6 +484,37 @@ class M2mThroughReferentialTests(TestCase):\n             attrgetter('name')\n         )\n \n+    def test_recursive_relationship_hint(self):\n+        \"\"\"\n+        Test that the hint for recursive relationships correctly suggests using\n+        ManyToManyField instead of ForeignKey.\n+        \"\"\"\n+        from django.core import checks\n+        from django.db import models\n+        class RecursiveModel(models.Model):\n+            pass\n+        class IntermediateModel(models.Model):\n+            first = models.ForeignKey(RecursiveModel, on_delete=models.CASCADE, related_name='first_set')\n+            second = models.ForeignKey(RecursiveModel, on_delete=models.CASCADE, related_name='second_set')\n+            third = models.ForeignKey(RecursiveModel, on_delete=models.CASCADE, related_name='third_set')\n+        class TestModel(models.Model):\n+            # Create a ManyToManyField without through_fields to trigger the error\n+            relationships = models.ManyToManyField('self', through=IntermediateModel)\n+        field = TestModel._meta.get_field('relationships')\n+        errors = field._check_relationship_model(from_model=TestModel)\n+        # Find the error with ID 'fields.E334' or 'fields.E335'\n+        relevant_errors = [e for e in errors if e.id in ('fields.E334', 'fields.E335')]\n+        # There should be at least one relevant error\n+        self.assertTrue(relevant_errors)\n+        for error in relevant_errors:\n+            # The hint should mention ManyToManyField, not ForeignKey\n+            self.assertIn('ManyToManyField', error.hint)\n+            self.assertNotIn('ForeignKey', error.hint)\n+            # The hint should not mention symmetrical=False as it's no longer required\n+            self.assertNotIn('symmetrical=False', error.hint)\n+    \n+\n+\n     def test_self_referential_symmetrical(self):\n         tony = PersonSelfRefM2M.objects.create(name='Tony')\n         chris = PersonSelfRefM2M.objects.create(name='Chris')\n@@ -573,3 +604,4 @@ class M2mThroughToFieldsTests(TestCase):\n             [choice[0] for choice in field.get_choices(include_blank=False)],\n             ['pea', 'potato', 'tomato']\n         )\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sphinx-doc__sphinx-8713",
        "model_patch": "diff --git a/tests/test_ext_napoleon_docstring.py b/tests/test_ext_napoleon_docstring.py\nindex ec5f90ac2..24d3912ac 100644\n--- a/tests/test_ext_napoleon_docstring.py\n+++ b/tests/test_ext_napoleon_docstring.py\n@@ -2453,6 +2453,30 @@ definition_after_normal_text : int\n         actual = str(NumpyDocstring(docstring, config))\n         self.assertEqual(expected, actual)\n \n+    def test_other_parameters_with_napoleon_use_param(self):\n+        \"\"\"Test that napoleon_use_param affects Other Parameters section.\"\"\"\n+        config = Config(napoleon_use_param=True)\n+        docstring = \"\"\"\n+        Parameters\n+        ----------\n+        x : int\n+            Description of x\n+        Other Parameters\n+        ----------------\n+        y : float\n+            Description of y\n+        \"\"\"\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+    :param x: Description of x\n+    :type x: int\n+    .. rubric:: Other Parameters\n+    :param y: Description of y\n+    :type y: float\"\"\"\n+        self.assertEqual(expected, actual)\n+    \n+\n+\n \n @contextmanager\n def warns(warning, match):\n@@ -2528,3 +2552,4 @@ Sample class with PEP 526 annotations and numpy docstring\n \"\"\"\n             print(actual)\n             assert expected == actual\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-23117",
        "model_patch": "diff --git a/sympy/tensor/array/tests/test_ndim_array.py b/sympy/tensor/array/tests/test_ndim_array.py\nindex f0732fd7c7..71dcd42b1b 100644\n--- a/sympy/tensor/array/tests/test_ndim_array.py\n+++ b/sympy/tensor/array/tests/test_ndim_array.py\n@@ -50,3 +50,21 @@ def test_issue_20222():\n     A = Array([[1, 2], [3, 4]])\n     B = Matrix([[1,2],[3,4]])\n     raises(TypeError, lambda: A - B)\n+\n+def test_empty_array():\n+    # Test that empty Array can be created\n+    a = Array([])\n+    assert a.shape == (0,)\n+    assert a.rank() == 1\n+    assert len(a) == 0\n+    # Test empty arrays with explicit shape\n+    b = Array([], shape=(0,))\n+    assert b.shape == (0,)\n+    # Test empty arrays with different dimensions\n+    c = Array([], shape=(0, 0))\n+    assert c.shape == (0, 0)\n+    # Test that Matrix([]) works for comparison\n+    m = Matrix([])\n+    assert m.shape == (0, 0)\n+\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "pytest-dev__pytest-7373",
        "model_patch": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex a6f1a9c09..0811e514e 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1195,3 +1195,31 @@ def test_relpath_rootdir(testdir):\n     result.stdout.fnmatch_lines(\n         [\"SKIPPED [[]1[]] tests/test_1.py:2: unconditional skip\"]\n     )\n+\n+\n+def test_skipif_caching_with_different_globals(testdir):\n+    testdir.makepyfile(\n+        test_module_1=\"\"\"\n+        import pytest\n+        import pytest\n+        skip = True\n+        @pytest.mark.skipif(\"skip\")\n+        def test_should_skip():\n+            assert False\n+        \"\"\",\n+        test_module_2=\"\"\"\n+        skip = False\n+        @pytest.mark.skipif(\"skip\")\n+        def test_should_not_skip():\n+            assert False\n+        \"\"\",\n+    )\n+    result = testdir.runpytest(\"test_module_1.py\", \"test_module_2.py\", \"-v\")\n+    result.stdout.fnmatch_lines(\n+        [\n+            \"*test_module_1.py::test_should_skip SKIPPED*\",\n+            \"*test_module_2.py::test_should_not_skip FAILED*\",\n+        ]\n+    )\n+    assert result.ret == 1\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-14024",
        "model_patch": "diff --git a/sympy/simplify/tests/test_simplify.py b/sympy/simplify/tests/test_simplify.py\nindex 6909894e6f..db43ea3667 100644\n--- a/sympy/simplify/tests/test_simplify.py\n+++ b/sympy/simplify/tests/test_simplify.py\n@@ -680,6 +680,35 @@ def test_issue_13474():\n     x = Symbol('x')\n     assert simplify(x + csch(sinc(1))) == x + csch(sinc(1))\n \n+def test_simplify_negative_power():\n+    # Test with symbolic positive integer\n+    a = Symbol('a', integer=True, positive=True)\n+    e = (-a)**x * a**(-x)\n+    f = simplify(e)\n+    assert f == (-1)**x\n+    # Test with concrete positive integer\n+    a = S(2)\n+    e = (-a)**x * a**(-x)\n+    f = simplify(e)\n+    assert f == (-1)**x\n+    # Test numerical evaluation consistency\n+    a = Symbol('a', integer=True, positive=True)\n+    e = (-a)**x * a**(-x)\n+    f = simplify(e)\n+    t = -S(10)/3\n+    n1 = e.subs(x, t).evalf()\n+    n2 = f.subs(x, t).evalf()\n+    assert n1 == n2\n+    # Test with concrete value\n+    a = S(2)\n+    e = (-a)**x * a**(-x)\n+    f = simplify(e)\n+    t = -S(10)/3\n+    n1 = e.subs(x, t).evalf()\n+    n2 = f.subs(x, t).evalf()\n+    assert n1 == n2\n+\n+\n \n def test_simplify_function_inverse():\n     x, y = symbols('x, y')\n@@ -705,3 +734,4 @@ def test_clear_coefficients():\n     assert clear_coefficients(S.Infinity, x) == (S.Infinity, x)\n     assert clear_coefficients(-S.Pi, x) == (S.Pi, -x)\n     assert clear_coefficients(2 - S.Pi/3, x) == (pi, -3*x + 6)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-20212",
        "model_patch": "diff --git a/sympy/core/tests/test_power.py b/sympy/core/tests/test_power.py\nindex 413fbd4532..3e1003d901 100644\n--- a/sympy/core/tests/test_power.py\n+++ b/sympy/core/tests/test_power.py\n@@ -254,6 +254,7 @@ def test_power_rewrite_exp():\n                     (sin, cos, tan, sec, csc, sinh, cosh, tanh))\n \n \n+\n def test_zero():\n     x = Symbol('x')\n     y = Symbol('y')\n@@ -265,6 +266,8 @@ def test_zero():\n     assert 0**(x - 2) != S.Infinity**(2 - x)\n     assert 0**(2*x*y) == 0**(x*y)\n     assert 0**(-2*x*y) == S.ComplexInfinity**(x*y)\n+    assert 0**-oo == S.ComplexInfinity\n+\n \n \n def test_pow_as_base_exp():\n@@ -579,3 +582,4 @@ def _(a, b):\n     assert power(a, b) == NewPow(a, b)\n     assert power(b, a) == NewPow(b, a)\n     assert power(b, b) == NewPow(b, b)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-13448",
        "model_patch": "diff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\nindex 01215a9a5b..c822ee0edb 100644\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -78,6 +78,28 @@ class TestDbCreationTests(SimpleTestCase):\n             with mock.patch.object(creation, '_destroy_test_db'):\n                 creation.destroy_test_db(old_database_name, verbosity=0)\n \n+    @mock.patch.object(BaseDatabaseCreation, 'serialize_db_to_string')\n+    @mock.patch.object(BaseDatabaseCreation, '_create_test_db')\n+    @mock.patch.object(BaseDatabaseCreation, 'ensure_connection')\n+    def test_serialize_db_with_migrate_false(self, mocked_ensure_connection, mocked_create_test_db, mocked_serialize):\n+        # Create a copy of the connection settings to avoid modifying the real one\n+        connection_settings = copy.deepcopy(connection.settings_dict)\n+        # Set MIGRATE to False in the TEST settings\n+        connection_settings['TEST'] = {'MIGRATE': False}\n+        # Create a database creation instance with our modified settings\n+        creation = BaseDatabaseCreation(connection)\n+        creation.connection.settings_dict = connection_settings\n+        # Call create_test_db which should call serialize_db_to_string even when MIGRATE is False\n+        creation.create_test_db(verbosity=0)\n+        # Verify serialize_db_to_string was called\n+        mocked_serialize.assert_called_once()\n+        # Verify _create_test_db was called\n+        mocked_create_test_db.assert_called_once()\n+        # Verify ensure_connection was called\n+        mocked_ensure_connection.assert_called_once()\n+    \n+\n+\n \n class TestDeserializeDbFromString(TransactionTestCase):\n     available_apps = ['backends']\n@@ -148,3 +170,4 @@ class TestDeserializeDbFromString(TransactionTestCase):\n         obj_b = CircularB.objects.get()\n         self.assertEqual(obj_a.obj, obj_b)\n         self.assertEqual(obj_b.obj, obj_a)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "django__django-12708",
        "model_patch": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 55c20213b0..d6948f2e08 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -1759,6 +1759,42 @@ class OperationTests(OperationTestBase):\n         operation = migrations.AlterIndexTogether(\"Pony\", None)\n         self.assertEqual(operation.describe(), \"Alter index_together for Pony (0 constraint(s))\")\n \n+    def test_alter_index_together_with_unique_together(self):\n+        \"\"\"\n+        Tests altering index_together when the same fields are in unique_together.\n+        \"\"\"\n+        # Create the table with both unique_together and index_together\n+        operation1 = migrations.CreateModel(\n+            \"Pony\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"pink\", models.IntegerField()),\n+                (\"weight\", models.IntegerField()),\n+            ],\n+            options={\n+                \"unique_together\": {(\"pink\", \"weight\")},\n+                \"index_together\": {(\"pink\", \"weight\")},\n+            },\n+        )\n+        operation2 = migrations.AlterIndexTogether(\n+            \"Pony\",\n+            set(),\n+        )\n+        # Add the model and then alter the index_together\n+        self.apply_operations(\"test_alititwut\", [operation1, operation2])\n+        # Make sure the index was removed\n+        self.assertIndexNotExists(\"test_alititwut_pony\", [\"pink\", \"weight\"])\n+        # But the unique constraint still exists\n+        with connection.cursor() as cursor:\n+            constraints = connection.introspection.get_constraints(cursor, \"test_alititwut_pony\")\n+        unique_constraints = [\n+            name for name, details in constraints.items()\n+            if details['unique'] and details['columns'] == ['pink', 'weight']\n+        ]\n+        self.assertEqual(len(unique_constraints), 1, \"Unique constraint should still exist\")\n+    \n+\n+\n     @skipUnlessDBFeature('supports_table_check_constraints')\n     def test_add_constraint(self):\n         project_state = self.set_up_test_model(\"test_addconstraint\")\n@@ -3023,3 +3059,4 @@ class FieldOperationTests(SimpleTestCase):\n         self.assertIs(operation.references_field('Through', 'whatever', 'migrations'), False)\n         self.assertIs(operation.references_field('Through', 'first', 'migrations'), True)\n         self.assertIs(operation.references_field('Through', 'second', 'migrations'), True)\n+\n",
        "model_name_or_path": "claude_lite_planner"
    },
    {
        "instance_id": "sympy__sympy-19487",
        "model_patch": "diff --git a/sympy/functions/elementary/tests/test_complexes.py b/sympy/functions/elementary/tests/test_complexes.py\nindex adb6cf0d83..8f1b3ad548 100644\n--- a/sympy/functions/elementary/tests/test_complexes.py\n+++ b/sympy/functions/elementary/tests/test_complexes.py\n@@ -316,6 +316,29 @@ def test_sign():\n     d = p - q\n     assert sign(d).func is sign or sign(d) == 0\n \n+def test_sign_rewrite_abs():\n+    x = Symbol('x')\n+    assert sign(x).rewrite(Abs) == x/Abs(x)\n+    # Test with different types of symbols\n+    p = Symbol('p', positive=True)\n+    n = Symbol('n', negative=True)\n+    z = Symbol('z', zero=True)\n+    r = Symbol('r', real=True)\n+    c = Symbol('c', complex=True)\n+    assert sign(p).rewrite(Abs) == p/Abs(p)\n+    assert sign(n).rewrite(Abs) == n/Abs(n)\n+    assert sign(z).rewrite(Abs) == 0\n+    assert sign(r).rewrite(Abs) == r/Abs(r)\n+    assert sign(c).rewrite(Abs) == c/Abs(c)\n+    # Test with expressions\n+    assert sign(2*x).rewrite(Abs) == 2*x/Abs(2*x)\n+    assert sign(I*x).rewrite(Abs) == I*x/Abs(I*x)\n+    # Test with numeric values\n+    assert sign(S(5)).rewrite(Abs) == 1\n+    assert sign(S(-5)).rewrite(Abs) == -1\n+    assert sign(S(0)).rewrite(Abs) == 0\n+\n+\n \n def test_as_real_imag():\n     n = pi**1000\n@@ -967,3 +990,4 @@ def test_issue_15893():\n     x = Symbol('x', real=True)\n     eq = Derivative(Abs(f(x)), f(x))\n     assert eq.doit() == sign(f(x))\n+\n",
        "model_name_or_path": "claude_lite_planner"
    }
]