{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3069", "model_patch": "diff --git a/seaborn/categorical.py b/seaborn/categorical.py\nindex ec4f4c2..6fb259b 100644\n--- a/seaborn/categorical.py\n+++ b/seaborn/categorical.py\n@@ -39,8 +39,8 @@ __all__ = [\n ]\n \n \n-# Subclassing _RelationalPlotter for the legend machinery,\n-# but probably should move that more centrally\n+from seaborn._core.scales import Nominal\n+\n class _CategoricalPlotterNew(_RelationalPlotter):\n \n     semantics = \"x\", \"y\", \"hue\", \"units\"\n@@ -149,7 +149,7 @@ class _CategoricalPlotterNew(_RelationalPlotter):\n             if isinstance(palette, dict):\n                 palette = {str(k): v for k, v in palette.items()}\n \n-        else:\n+        elif axis == \"y\" or isinstance(self.var_types[axis], Nominal):\n             self._redundant_hue = False\n \n         # Previously, categorical plots had a trick where color= could seed the palette.\n@@ -179,7 +179,14 @@ class _CategoricalPlotterNew(_RelationalPlotter):\n             hue_order = self.var_levels.get(self.cat_axis)\n         return hue_order\n \n-    @property\n+    def _adjust_nominal_axis(self, ax, axis):\n+        \"\"\"Set ticks and limits for a nominal variable and ensure no grid is shown.\"\"\"\n+        if axis == \"x\" or isinstance(self.var_types[axis], Nominal):\n+            ax.xaxis.grid(False)\n+            ax.set_xlim(-.5, len(ax.get_xticks()) - .5, auto=None)\n+        elif axis == \"y\" or isinstance(self.var_types[axis], Nominal):\n+            ax.yaxis.grid(False)\n+            ax.set_ylim(len(ax.get_yticks()) - .5, -.5, auto=None)\n     def cat_axis(self):\n         return {\"v\": \"x\", \"h\": \"y\"}[self.orient]\n \n@@ -194,6 +201,10 @@ class _CategoricalPlotterNew(_RelationalPlotter):\n \n     def _adjust_cat_axis(self, ax, axis):\n         \"\"\"Set ticks and limits for a categorical variable.\"\"\"\n+\n+        if isinstance(self.var_types[axis], Nominal):\n+            self._adjust_nominal_axis(ax, axis)\n+        \"\"\"Set ticks and limits for a categorical variable.\"\"\"\n         # Note: in theory, this could happen in _attach for all categorical axes\n         # But two reasons not to do that:\n         # - If it happens before plotting, autoscaling messes up the plot limits\n@@ -215,21 +226,28 @@ class _CategoricalPlotterNew(_RelationalPlotter):\n         # the state from previous categorical calls (see GH2516 for context)\n         n = len(getattr(ax, f\"get_{axis}ticks\")())\n \n-        if axis == \"x\":\n+        if axis == \"x\" or isinstance(self.var_types[axis], Nominal):\n             ax.xaxis.grid(False)\n-            ax.set_xlim(-.5, n - .5, auto=None)\n-        else:\n+            ax.set_xlim(-.5, n - .5, auto=None)  # Extend scale to +/- 0.5\n+        elif axis == \"y\" or isinstance(self.var_types[axis], Nominal):\n             ax.yaxis.grid(False)\n             # Note limits that correspond to previously-inverted y axis\n             ax.set_ylim(n - .5, -.5, auto=None)\n \n-    @property\n+    def _adjust_nominal_axis(self, ax, axis):\n+        \"\"\"Set ticks and limits for a nominal variable and ensure no grid is shown.\"\"\"\n+        if axis == \"x\" or isinstance(self.var_types[axis], Nominal):\n+            ax.xaxis.grid(False)\n+            ax.set_xlim(-.5, len(ax.get_xticks()) - .5, auto=None)\n+        elif axis == \"y\" or isinstance(self.var_types[axis], Nominal):\n+            ax.yaxis.grid(False)\n+            ax.set_ylim(len(ax.get_yticks()) - .5, -.5, auto=None)\n     def _native_width(self):\n         \"\"\"Return unit of width separating categories on native numeric scale.\"\"\"\n         unique_values = np.unique(self.comp_data[self.cat_axis])\n         if len(unique_values) > 1:\n             native_width = np.nanmin(np.diff(unique_values))\n-        else:\n+        elif axis == \"y\" or isinstance(self.var_types[axis], Nominal):\n             native_width = 1\n         return native_width\n \n@@ -266,7 +284,7 @@ class _CategoricalPlotterNew(_RelationalPlotter):\n \n         if jitter is True:\n             jlim = 0.1\n-        else:\n+        elif axis == \"y\" or isinstance(self.var_types[axis], Nominal):\n             jlim = float(jitter)\n         if \"hue\" in self.variables and dodge:\n             jlim /= len(self._hue_map.levels)\n@@ -309,7 +327,7 @@ class _CategoricalPlotterNew(_RelationalPlotter):\n         # Finalize the axes details\n         if self.legend == \"auto\":\n             show_legend = not self._redundant_hue and self.input_format != \"wide\"\n-        else:\n+        elif axis == \"y\" or isinstance(self.var_types[axis], Nominal):\n             show_legend = bool(self.legend)\n \n         if show_legend:\n@@ -401,7 +419,7 @@ class _CategoricalPlotterNew(_RelationalPlotter):\n         # Finalize the axes details\n         if self.legend == \"auto\":\n             show_legend = not self._redundant_hue and self.input_format != \"wide\"\n-        else:\n+        elif axis == \"y\" or isinstance(self.var_types[axis], Nominal):\n             show_legend = bool(self.legend)\n \n         if show_legend:\n", "occurrence": 1, "normalized_patch": "diff --git a/seaborn/categorical.py b/seaborn/categorical.py\nindex 7d6d43d..27de98e 100644\n--- a/seaborn/categorical.py\n+++ b/seaborn/categorical.py\n@@ -23,6 +23,7 @@ from seaborn._statistics import EstimateAggregator\n from seaborn.palettes import color_palette, husl_palette, light_palette, dark_palette\n from seaborn.axisgrid import FacetGrid, _facet_docs\n __all__ = ['catplot', 'stripplot', 'swarmplot', 'boxplot', 'violinplot', 'boxenplot', 'pointplot', 'barplot', 'countplot']\n+from seaborn._core.scales import Nominal\n class _CategoricalPlotterNew(_RelationalPlotter):\n     semantics = ('x', 'y', 'hue', 'units')\n     wide_structure = {'x': '@columns', 'y': '@values', 'hue': '@columns'}\n@@ -64,7 +65,7 @@ class _CategoricalPlotterNew(_RelationalPlotter):\n             hue_order = self.var_levels[self.cat_axis]\n             if isinstance(palette, dict):\n                 palette = {str(k): v for k, v in palette.items()}\n-        else:\n+        elif axis == 'y' or isinstance(self.var_types[axis], Nominal):\n             self._redundant_hue = False\n         if 'hue' in self.variables and palette is None and (color is not None):\n             if not isinstance(color, str):\n@@ -83,7 +84,13 @@ class _CategoricalPlotterNew(_RelationalPlotter):\n             self.var_types['hue'] = self.var_types.get(self.cat_axis)\n             hue_order = self.var_levels.get(self.cat_axis)\n         return hue_order\n-    @property\n+    def _adjust_nominal_axis(self, ax, axis):\n+        if axis == 'x' or isinstance(self.var_types[axis], Nominal):\n+            ax.xaxis.grid(False)\n+            ax.set_xlim(-0.5, len(ax.get_xticks()) - 0.5, auto=None)\n+        elif axis == 'y' or isinstance(self.var_types[axis], Nominal):\n+            ax.yaxis.grid(False)\n+            ax.set_ylim(len(ax.get_yticks()) - 0.5, -0.5, auto=None)\n     def cat_axis(self):\n         return {'v': 'x', 'h': 'y'}[self.orient]\n     def _get_gray(self, colors):\n@@ -94,23 +101,32 @@ class _CategoricalPlotterNew(_RelationalPlotter):\n         lum = min(light_vals) * 0.6\n         return (lum, lum, lum)\n     def _adjust_cat_axis(self, ax, axis):\n+        if isinstance(self.var_types[axis], Nominal):\n+            self._adjust_nominal_axis(ax, axis)\n+        'Set ticks and limits for a categorical variable.'\n         if self.var_types[axis] != 'categorical':\n             return\n         if self.plot_data[axis].empty:\n             return\n         n = len(getattr(ax, f'get_{axis}ticks')())\n-        if axis == 'x':\n+        if axis == 'x' or isinstance(self.var_types[axis], Nominal):\n             ax.xaxis.grid(False)\n             ax.set_xlim(-0.5, n - 0.5, auto=None)\n-        else:\n+        elif axis == 'y' or isinstance(self.var_types[axis], Nominal):\n             ax.yaxis.grid(False)\n             ax.set_ylim(n - 0.5, -0.5, auto=None)\n-    @property\n+    def _adjust_nominal_axis(self, ax, axis):\n+        if axis == 'x' or isinstance(self.var_types[axis], Nominal):\n+            ax.xaxis.grid(False)\n+            ax.set_xlim(-0.5, len(ax.get_xticks()) - 0.5, auto=None)\n+        elif axis == 'y' or isinstance(self.var_types[axis], Nominal):\n+            ax.yaxis.grid(False)\n+            ax.set_ylim(len(ax.get_yticks()) - 0.5, -0.5, auto=None)\n     def _native_width(self):\n         unique_values = np.unique(self.comp_data[self.cat_axis])\n         if len(unique_values) > 1:\n             native_width = np.nanmin(np.diff(unique_values))\n-        else:\n+        elif axis == 'y' or isinstance(self.var_types[axis], Nominal):\n             native_width = 1\n         return native_width\n     def _nested_offsets(self, width, dodge):\n@@ -129,7 +145,7 @@ class _CategoricalPlotterNew(_RelationalPlotter):\n         offsets = self._nested_offsets(width, dodge)\n         if jitter is True:\n             jlim = 0.1\n-        else:\n+        elif axis == 'y' or isinstance(self.var_types[axis], Nominal):\n             jlim = float(jitter)\n         if 'hue' in self.variables and dodge:\n             jlim /= len(self._hue_map.levels)\n@@ -159,7 +175,7 @@ class _CategoricalPlotterNew(_RelationalPlotter):\n                 points.set_edgecolors(edgecolor)\n         if self.legend == 'auto':\n             show_legend = not self._redundant_hue and self.input_format != 'wide'\n-        else:\n+        elif axis == 'y' or isinstance(self.var_types[axis], Nominal):\n             show_legend = bool(self.legend)\n         if show_legend:\n             self.add_legend_data(ax)\n@@ -213,7 +229,7 @@ class _CategoricalPlotterNew(_RelationalPlotter):\n         _draw_figure(ax.figure)\n         if self.legend == 'auto':\n             show_legend = not self._redundant_hue and self.input_format != 'wide'\n-        else:\n+        elif axis == 'y' or isinstance(self.var_types[axis], Nominal):\n             show_legend = bool(self.legend)\n         if show_legend:\n             self.add_legend_data(ax)\n", "normalized_occurrence": 1}
