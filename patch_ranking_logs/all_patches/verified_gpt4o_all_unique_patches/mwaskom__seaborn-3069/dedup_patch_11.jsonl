{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3069", "model_patch": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 1e10d58..d475925 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -133,6 +133,87 @@ class Scale:\n \n         return Identity()\n \n+@dataclass\n+class Nominal(Scale):\n+    \"\"\"\n+    A categorical scale without relative importance / magnitude.\n+    \"\"\"\n+    # Categorical (convert to strings), un-sortable\n+\n+    values: tuple | str | list | dict | None = None\n+    order: list | None = None\n+\n+    _priority: ClassVar[int] = 3\n+\n+    def _setup(\n+        self, data: Series, prop: Property, axis: Axis | None = None,\n+    ) -> Scale:\n+\n+        new = copy(self)\n+        if new._tick_params is None:\n+            new = new.tick()\n+        if new._label_params is None:\n+            new = new.label()\n+\n+        # TODO flexibility over format() which isn't great for numbers / dates\n+        stringify = np.vectorize(format)\n+\n+        units_seed = categorical_order(data, new.order)\n+\n+        class CatScale(mpl.scale.LinearScale):\n+            name = None  # To work around mpl<3.4 compat issues\n+\n+            def set_default_locators_and_formatters(self, axis):\n+                ...\n+\n+        mpl_scale = CatScale(data.name)\n+        if axis is None:\n+            axis = PseudoAxis(mpl_scale)\n+            axis.set_view_interval(-0.5, len(units_seed) - 0.5)  # Adjust margins\n+\n+        new._matplotlib_scale = mpl_scale\n+\n+        # Update units\n+        axis.update_units(stringify(np.array(units_seed)))\n+\n+        def convert_units(x):\n+            keep = np.array([x_ in units_seed for x_ in x], bool)\n+            out = np.full(len(x), np.nan)\n+            out[keep] = axis.convert_units(stringify(x[keep]))\n+            return out\n+\n+        new._pipeline = [\n+            convert_units,\n+            prop.get_mapping(new, data),\n+        ]\n+\n+        def spacer(x):\n+            return 1\n+\n+        new._spacer = spacer\n+\n+        if prop.legend:\n+            new._legend = units_seed, list(stringify(units_seed))\n+\n+        return new\n+\n+    def _adjust_cat_axis(self, ax, axis):\n+        \"\"\"Set ticks and limits for a categorical variable.\"\"\"\n+        if self.var_types[axis] != \"categorical\":\n+            return\n+\n+        if self.plot_data[axis].empty:\n+            return\n+\n+        n = len(getattr(ax, f\"get_{axis}ticks\")())\n+\n+        if axis == \"x\":\n+            ax.xaxis.grid(False)\n+            ax.set_xlim(-.5, n - .5, auto=None)\n+        else:\n+            ax.yaxis.grid(False)\n+            ax.set_ylim(n - .5, -.5, auto=None)\n+\n \n @dataclass\n class Nominal(Scale):\n", "occurrence": 1, "normalized_patch": "--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n+class Nominal(Scale):\n+    values: tuple | str | list | dict | None = None\n+    order: list | None = None\n+    _priority: ClassVar[int] = 3\n+    def _setup(self, data: Series, prop: Property, axis: Axis | None=None) -> Scale:\n+        new = copy(self)\n+        if new._tick_params is None:\n+            new = new.tick()\n+        if new._label_params is None:\n+            new = new.label()\n+        stringify = np.vectorize(format)\n+        units_seed = categorical_order(data, new.order)\n+        class CatScale(mpl.scale.LinearScale):\n+            name = None\n+            def set_default_locators_and_formatters(self, axis):\n+                ...\n+        mpl_scale = CatScale(data.name)\n+        if axis is None:\n+            axis = PseudoAxis(mpl_scale)\n+            axis.set_view_interval(-0.5, len(units_seed) - 0.5)\n+        new._matplotlib_scale = mpl_scale\n+        axis.update_units(stringify(np.array(units_seed)))\n+        def convert_units(x):\n+            keep = np.array([x_ in units_seed for x_ in x], bool)\n+            out = np.full(len(x), np.nan)\n+            out[keep] = axis.convert_units(stringify(x[keep]))\n+            return out\n+        new._pipeline = [convert_units, prop.get_mapping(new, data)]\n+        def spacer(x):\n+            return 1\n+        new._spacer = spacer\n+        if prop.legend:\n+            new._legend = (units_seed, list(stringify(units_seed)))\n+        return new\n+    def _adjust_cat_axis(self, ax, axis):\n+        if self.var_types[axis] != 'categorical':\n+            return\n+        if self.plot_data[axis].empty:\n+            return\n+        n = len(getattr(ax, f'get_{axis}ticks')())\n+        if axis == 'x':\n+            ax.xaxis.grid(False)\n+            ax.set_xlim(-0.5, n - 0.5, auto=None)\n+        else:\n+            ax.yaxis.grid(False)\n+            ax.set_ylim(n - 0.5, -0.5, auto=None)\n+@dataclass", "normalized_occurrence": 1}
