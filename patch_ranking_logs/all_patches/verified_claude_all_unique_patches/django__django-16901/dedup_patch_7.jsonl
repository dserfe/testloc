{"model_name_or_path": "agentless_claude", "instance_id": "django__django-16901", "model_patch": "diff --git a/django/db/backends/base/operations.py b/django/db/backends/base/operations.py\nindex 5801e03..f263d1b 100644\n--- a/django/db/backends/base/operations.py\n+++ b/django/db/backends/base/operations.py\n@@ -668,6 +668,18 @@ class BaseDatabaseOperations:\n         can vary between backends (e.g., Oracle with %% and &) and between\n         subexpression types (e.g., date expressions).\n         \"\"\"\n+        if connector == '^':\n+            # For databases without native XOR, implement using combination of\n+            # AND, OR, and NOT to maintain correct \"odd number true\" semantics\n+            if len(sub_expressions) == 2:\n+                # a XOR b = (a OR b) AND NOT (a AND b)\n+                return \"({0} OR {1}) AND NOT ({0} AND {1})\".format(*sub_expressions)\n+            else:\n+                # For multiple XORs, chain them to preserve proper XOR semantics\n+                result = sub_expressions[0]\n+                for expr in sub_expressions[1:]:\n+                    result = \"({0} OR {1}) AND NOT ({0} AND {1})\".format(result, expr)\n+                return result\n         conn = \" %s \" % connector\n         return conn.join(sub_expressions)\n \n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/backends/base/operations.py b/django/db/backends/base/operations.py\nindex ba948a6..25d3d1a 100644\n--- a/django/db/backends/base/operations.py\n+++ b/django/db/backends/base/operations.py\n@@ -215,6 +215,14 @@ class BaseDatabaseOperations:\n     def conditional_expression_supported_in_where_clause(self, expression):\n         return True\n     def combine_expression(self, connector, sub_expressions):\n+        if connector == '^':\n+            if len(sub_expressions) == 2:\n+                return '({0} OR {1}) AND NOT ({0} AND {1})'.format(*sub_expressions)\n+            else:\n+                result = sub_expressions[0]\n+                for expr in sub_expressions[1:]:\n+                    result = '({0} OR {1}) AND NOT ({0} AND {1})'.format(result, expr)\n+                return result\n         conn = ' %s ' % connector\n         return conn.join(sub_expressions)\n     def combine_duration_expression(self, connector, sub_expressions):\n", "normalized_occurrence": 1}
