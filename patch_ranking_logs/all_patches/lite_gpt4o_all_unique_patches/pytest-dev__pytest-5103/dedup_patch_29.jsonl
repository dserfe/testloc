{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-5103", "model_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 4810cdd..e408339 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -968,6 +968,8 @@ warn_explicit(\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        if isinstance(call.func, ast.Name) and call.func.id in ('all', 'any'):\n+            return self.visit_all_any_call(call)\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,7 +999,27 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n-    def visit_Call_legacy(self, call):\n+    def visit_all_any_call(self, call):\n+        \"\"\"\n+        Special handling for `all` and `any` calls.\n+        \"\"\"\n+        new_func, func_expl = self.visit(call.func)\n+        assert len(call.args) == 1, \"Expected one argument for all/any call\"\n+        arg = call.args[0]\n+        if not isinstance(arg, (ast.GeneratorExp, ast.ListComp)):\n+            # If not a generator or list comprehension, handle normally\n+            return self.generic_visit(call)\n+        \n+        temp_var = self.variable()\n+        loop_var = self.variable()\n+        self.statements.append(ast.Assign([ast.Name(temp_var, ast.Store())], ast.ListComp(\n+            elt=arg.elt,\n+            generators=arg.generators\n+        )))\n+        self.statements.append(ast.Assign([ast.Name(loop_var, ast.Store())], self.helper(\"_is_\" + call.func.id, ast.Name(temp_var, ast.Load()))))\n+        res_var = self.assign(ast.Call(new_func, [ast.Name(loop_var, ast.Load())], []))\n+        expl = \"{}({})\\n{{{} = {}}}\".format(func_expl, self.explanation_param(self.display(ast.Name(loop_var, ast.Load()))), temp_var, self.explanation_param(self.display(ast.Name(temp_var, ast.Load()))))\n+        return res_var, expl\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n@@ -1045,7 +1067,32 @@ warn_explicit(\n         expl = pat % (res_expl, res_expl, value_expl, attr.attr)\n         return res, expl\n \n-    def visit_Compare(self, comp):\n+    def visit_all_any_call(self, call):\n+        \"\"\"\n+        Special handling for `all` and `any` calls.\n+        \"\"\"\n+        new_func, func_expl = self.visit(call.func)\n+        assert len(call.args) == 1, \"Expected one argument for all/any call\"\n+        arg = call.args[0]\n+        if not isinstance(arg, (ast.GeneratorExp, ast.ListComp)):\n+            # If not a generator or list comprehension, handle normally\n+            return self.generic_visit(call)\n+        \n+        temp_var = self.variable()\n+        loop_var = self.variable()\n+        self.statements.append(ast.Assign([ast.Name(temp_var, ast.Store())], ast.ListComp(\n+            elt=arg.elt,\n+            generators=arg.generators\n+        )))\n+        self.statements.append(ast.Assign([ast.Name(loop_var, ast.Store())], self.helper(\"_is_\" + call.func.id, ast.Name(temp_var, ast.Load()))))\n+        res_var = self.assign(ast.Call(new_func, [ast.Name(loop_var, ast.Load())], []))\n+        expl = \"{}({})\\n{{{} = {}}}\".format(func_expl, self.explanation_param(self.display(ast.Name(loop_var, ast.Load()))), temp_var, self.explanation_param(self.display(ast.Name(temp_var, ast.Load()))))\n+        return res_var, expl\n+        \"\"\"\n+        visit `ast.Call nodes on 3.4 and below`\n+        \"\"\"\n+        if isinstance(call.func, ast.Name) and call.func.id in ('all', 'any'):\n+            return self.visit_all_any_call(call)\n         self.push_format_context()\n         left_res, left_expl = self.visit(comp.left)\n         if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n@@ -1081,4 +1128,4 @@ warn_explicit(\n             res = ast.BoolOp(ast.And(), load_names)\n         else:\n             res = load_names[0]\n-        return res, self.explanation_param(self.pop_format_context(expl_call))\n+        return res, self.explanation_param(self.pop_format_context(expl_call))\n", "occurrence": 1, "normalized_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2ada5b2..b7c9e93 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -544,6 +544,8 @@ class AssertionRewriter(ast.NodeVisitor):\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return (res, explanation)\n     def visit_Call_35(self, call):\n+        if isinstance(call.func, ast.Name) and call.func.id in ('all', 'any'):\n+            return self.visit_all_any_call(call)\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -569,7 +571,19 @@ class AssertionRewriter(ast.NodeVisitor):\n         res, expl = self.visit(starred.value)\n         new_starred = ast.Starred(res, starred.ctx)\n         return (new_starred, '*' + expl)\n-    def visit_Call_legacy(self, call):\n+    def visit_all_any_call(self, call):\n+        new_func, func_expl = self.visit(call.func)\n+        assert len(call.args) == 1, 'Expected one argument for all/any call'\n+        arg = call.args[0]\n+        if not isinstance(arg, (ast.GeneratorExp, ast.ListComp)):\n+            return self.generic_visit(call)\n+        temp_var = self.variable()\n+        loop_var = self.variable()\n+        self.statements.append(ast.Assign([ast.Name(temp_var, ast.Store())], ast.ListComp(elt=arg.elt, generators=arg.generators)))\n+        self.statements.append(ast.Assign([ast.Name(loop_var, ast.Store())], self.helper('_is_' + call.func.id, ast.Name(temp_var, ast.Load()))))\n+        res_var = self.assign(ast.Call(new_func, [ast.Name(loop_var, ast.Load())], []))\n+        expl = '{}({})\\n{{{} = {}}}'.format(func_expl, self.explanation_param(self.display(ast.Name(loop_var, ast.Load()))), temp_var, self.explanation_param(self.display(ast.Name(temp_var, ast.Load()))))\n+        return (res_var, expl)\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -608,7 +622,21 @@ class AssertionRewriter(ast.NodeVisitor):\n         pat = '%s\\n{%s = %s.%s\\n}'\n         expl = pat % (res_expl, res_expl, value_expl, attr.attr)\n         return (res, expl)\n-    def visit_Compare(self, comp):\n+    def visit_all_any_call(self, call):\n+        new_func, func_expl = self.visit(call.func)\n+        assert len(call.args) == 1, 'Expected one argument for all/any call'\n+        arg = call.args[0]\n+        if not isinstance(arg, (ast.GeneratorExp, ast.ListComp)):\n+            return self.generic_visit(call)\n+        temp_var = self.variable()\n+        loop_var = self.variable()\n+        self.statements.append(ast.Assign([ast.Name(temp_var, ast.Store())], ast.ListComp(elt=arg.elt, generators=arg.generators)))\n+        self.statements.append(ast.Assign([ast.Name(loop_var, ast.Store())], self.helper('_is_' + call.func.id, ast.Name(temp_var, ast.Load()))))\n+        res_var = self.assign(ast.Call(new_func, [ast.Name(loop_var, ast.Load())], []))\n+        expl = '{}({})\\n{{{} = {}}}'.format(func_expl, self.explanation_param(self.display(ast.Name(loop_var, ast.Load()))), temp_var, self.explanation_param(self.display(ast.Name(temp_var, ast.Load()))))\n+        return (res_var, expl)\n+        if isinstance(call.func, ast.Name) and call.func.id in ('all', 'any'):\n+            return self.visit_all_any_call(call)\n         self.push_format_context()\n         left_res, left_expl = self.visit(comp.left)\n         if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n", "normalized_occurrence": 1}
