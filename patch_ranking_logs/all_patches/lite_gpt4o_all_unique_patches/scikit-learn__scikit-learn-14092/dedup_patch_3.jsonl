{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-14092", "model_patch": "diff --git a/sklearn/neighbors/nca.py b/sklearn/neighbors/nca.py\nindex ff50abb..84f5f60 100644\n--- a/sklearn/neighbors/nca.py\n+++ b/sklearn/neighbors/nca.py\n@@ -299,7 +299,7 @@ class NeighborhoodComponentsAnalysis(BaseEstimator, TransformerMixin):\n \n         # Check the preferred dimensionality of the projected space\n         if self.n_components is not None:\n-            check_scalar(self.n_components, 'n_components', int, 1)\n+            check_scalar(self.n_components, 'n_components', (int, np.integer), 1)\n \n             if self.n_components > X.shape[1]:\n                 raise ValueError('The preferred dimensionality of the '\n@@ -318,9 +318,9 @@ class NeighborhoodComponentsAnalysis(BaseEstimator, TransformerMixin):\n                                  .format(X.shape[1],\n                                          self.components_.shape[1]))\n \n-        check_scalar(self.max_iter, 'max_iter', int, 1)\n-        check_scalar(self.tol, 'tol', float, 0.)\n-        check_scalar(self.verbose, 'verbose', int, 0)\n+        check_scalar(self.max_iter, 'max_iter', (int, np.integer), 1)\n+        check_scalar(self.tol, 'tol', (float, np.floating), 0.)\n+        check_scalar(self.verbose, 'verbose', (int, np.integer), 0)\n \n         if self.callback is not None:\n             if not callable(self.callback):\n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/neighbors/nca.py b/sklearn/neighbors/nca.py\nindex e4f1eb1..917f20c 100644\n--- a/sklearn/neighbors/nca.py\n+++ b/sklearn/neighbors/nca.py\n@@ -50,16 +50,16 @@ class NeighborhoodComponentsAnalysis(BaseEstimator, TransformerMixin):\n         check_classification_targets(y)\n         y = LabelEncoder().fit_transform(y)\n         if self.n_components is not None:\n-            check_scalar(self.n_components, 'n_components', int, 1)\n+            check_scalar(self.n_components, 'n_components', (int, np.integer), 1)\n             if self.n_components > X.shape[1]:\n                 raise ValueError('The preferred dimensionality of the projected space `n_components` ({}) cannot be greater than the given data dimensionality ({})!'.format(self.n_components, X.shape[1]))\n         check_scalar(self.warm_start, 'warm_start', bool)\n         if self.warm_start and hasattr(self, 'components_'):\n             if self.components_.shape[1] != X.shape[1]:\n                 raise ValueError('The new inputs dimensionality ({}) does not match the input dimensionality of the previously learned transformation ({}).'.format(X.shape[1], self.components_.shape[1]))\n-        check_scalar(self.max_iter, 'max_iter', int, 1)\n-        check_scalar(self.tol, 'tol', float, 0.0)\n-        check_scalar(self.verbose, 'verbose', int, 0)\n+        check_scalar(self.max_iter, 'max_iter', (int, np.integer), 1)\n+        check_scalar(self.tol, 'tol', (float, np.floating), 0.0)\n+        check_scalar(self.verbose, 'verbose', (int, np.integer), 0)\n         if self.callback is not None:\n             if not callable(self.callback):\n                 raise ValueError('`callback` is not callable.')\n", "normalized_occurrence": 1}
