{"model_name_or_path": "agentless_claude", "instance_id": "django__django-13660", "model_patch": "diff --git a/django/core/management/commands/shell.py b/django/core/management/commands/shell.py\nindex 34fafcb..415602e 100644\n--- a/django/core/management/commands/shell.py\n+++ b/django/core/management/commands/shell.py\n@@ -82,15 +82,18 @@ class Command(BaseCommand):\n         code.interact(local=imported_objects)\n \n     def handle(self, **options):\n+        # Set up a dictionary of imported objects for exec commands\n+        imported_objects = {}\n+\n         # Execute the command and exit.\n         if options['command']:\n-            exec(options['command'])\n+            exec(options['command'], imported_objects)\n             return\n \n         # Execute stdin if it has anything to read and exit.\n         # Not supported on Windows due to select.select() limitations.\n         if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n-            exec(sys.stdin.read())\n+            exec(sys.stdin.read(), imported_objects)\n             return\n \n         available_shells = [options['interface']] if options['interface'] else self.shells\n@@ -100,4 +103,4 @@ class Command(BaseCommand):\n                 return getattr(self, shell)(options)\n             except ImportError:\n                 pass\n-        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n+        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n", "normalized_patch": "diff --git a/django/core/management/commands/shell.py b/django/core/management/commands/shell.py\nindex f25e76c..45773ec 100644\n--- a/django/core/management/commands/shell.py\n+++ b/django/core/management/commands/shell.py\n@@ -47,11 +47,12 @@ class Command(BaseCommand):\n                     traceback.print_exc()\n         code.interact(local=imported_objects)\n     def handle(self, **options):\n+        imported_objects = {}\n         if options['command']:\n-            exec(options['command'])\n+            exec(options['command'], imported_objects)\n             return\n         if sys.platform != 'win32' and (not sys.stdin.isatty()) and select.select([sys.stdin], [], [], 0)[0]:\n-            exec(sys.stdin.read())\n+            exec(sys.stdin.read(), imported_objects)\n             return\n         available_shells = [options['interface']] if options['interface'] else self.shells\n         for shell in available_shells:\n", "normalized_occurrence": 1}
