{"model_name_or_path": "agentless", "instance_id": "django__django-11885", "model_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex da91f5e..fdde993 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -222,19 +222,16 @@ class Collector:\n                 if field.remote_field.on_delete == DO_NOTHING:\n                     continue\n                 batches = self.get_del_batches(new_objs, field)\n+                related_fast_deletes = {}\n                 for batch in batches:\n                     sub_objs = self.related_objects(related, batch)\n                     if self.can_fast_delete(sub_objs, from_field=field):\n-                        self.fast_deletes.append(sub_objs)\n+                        if related not in related_fast_deletes:\n+                            related_fast_deletes[related] = sub_objs\n+                        else:\n+                            related_fast_deletes[related] |= sub_objs\n                     else:\n                         related_model = related.related_model\n-                        # Non-referenced fields can be deferred if no signal\n-                        # receivers are connected for the related model as\n-                        # they'll never be exposed to the user. Skip field\n-                        # deferring when some relationships are select_related\n-                        # as interactions between both features are hard to\n-                        # get right. This should only happen in the rare\n-                        # cases where .related_objects is overridden anyway.\n                         if not (sub_objs.query.select_related or self._has_signal_listeners(related_model)):\n                             referenced_fields = set(chain.from_iterable(\n                                 (rf.attname for rf in rel.field.foreign_related_fields)\n@@ -243,11 +240,12 @@ class Collector:\n                             sub_objs = sub_objs.only(*tuple(referenced_fields))\n                         if sub_objs:\n                             field.remote_field.on_delete(self, field, sub_objs, self.using)\n-            for field in model._meta.private_fields:\n-                if hasattr(field, 'bulk_related_objects'):\n-                    # It's something like generic foreign key.\n-                    sub_objs = field.bulk_related_objects(new_objs, self.using)\n-                    self.collect(sub_objs, source=model, nullable=True)\n+                for sub_objs in related_fast_deletes.values():\n+                    self.fast_deletes.append(sub_objs)\n+                for field in model._meta.private_fields:\n+                    if hasattr(field, 'bulk_related_objects'):\n+                        sub_objs = field.bulk_related_objects(new_objs, self.using)\n+                        self.collect(sub_objs, source=model, nullable=True)\n \n     def related_objects(self, related, objs):\n         \"\"\"\n@@ -310,9 +308,17 @@ class Collector:\n                     )\n \n             # fast deletes\n+            fast_deletes_by_model = {}\n             for qs in self.fast_deletes:\n+                model = qs.model\n+                if model not in fast_deletes_by_model:\n+                    fast_deletes_by_model[model] = qs\n+                else:\n+                    fast_deletes_by_model[model] |= qs\n+\n+            for model, qs in fast_deletes_by_model.items():\n                 count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+                deleted_counter[model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 97cb878..5260f88 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -102,10 +102,14 @@ class Collector:\n                 if field.remote_field.on_delete == DO_NOTHING:\n                     continue\n                 batches = self.get_del_batches(new_objs, field)\n+                related_fast_deletes = {}\n                 for batch in batches:\n                     sub_objs = self.related_objects(related, batch)\n                     if self.can_fast_delete(sub_objs, from_field=field):\n-                        self.fast_deletes.append(sub_objs)\n+                        if related not in related_fast_deletes:\n+                            related_fast_deletes[related] = sub_objs\n+                        else:\n+                            related_fast_deletes[related] |= sub_objs\n                     else:\n                         related_model = related.related_model\n                         if not (sub_objs.query.select_related or self._has_signal_listeners(related_model)):\n@@ -113,10 +117,12 @@ class Collector:\n                             sub_objs = sub_objs.only(*tuple(referenced_fields))\n                         if sub_objs:\n                             field.remote_field.on_delete(self, field, sub_objs, self.using)\n-            for field in model._meta.private_fields:\n-                if hasattr(field, 'bulk_related_objects'):\n-                    sub_objs = field.bulk_related_objects(new_objs, self.using)\n-                    self.collect(sub_objs, source=model, nullable=True)\n+                for sub_objs in related_fast_deletes.values():\n+                    self.fast_deletes.append(sub_objs)\n+                for field in model._meta.private_fields:\n+                    if hasattr(field, 'bulk_related_objects'):\n+                        sub_objs = field.bulk_related_objects(new_objs, self.using)\n+                        self.collect(sub_objs, source=model, nullable=True)\n     def related_objects(self, related, objs):\n         return related.related_model._base_manager.using(self.using).filter(**{'%s__in' % related.field.name: objs})\n     def instances_with_model(self):\n@@ -156,9 +162,16 @@ class Collector:\n             for model, obj in self.instances_with_model():\n                 if not model._meta.auto_created:\n                     signals.pre_delete.send(sender=model, instance=obj, using=self.using)\n+            fast_deletes_by_model = {}\n             for qs in self.fast_deletes:\n+                model = qs.model\n+                if model not in fast_deletes_by_model:\n+                    fast_deletes_by_model[model] = qs\n+                else:\n+                    fast_deletes_by_model[model] |= qs\n+            for model, qs in fast_deletes_by_model.items():\n                 count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+                deleted_counter[model._meta.label] += count\n             for model, instances_for_fieldvalues in self.field_updates.items():\n                 for (field, value), instances in instances_for_fieldvalues.items():\n                     query = sql.UpdateQuery(model)\n", "normalized_occurrence": 1}
