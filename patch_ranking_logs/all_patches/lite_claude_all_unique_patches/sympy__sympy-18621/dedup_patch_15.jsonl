{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-18621", "model_patch": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex cc9a4f7..d3159b5 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -343,6 +343,32 @@ class BlockDiagMatrix(BlockMatrix):\n         else:\n             return BlockMatrix._blockadd(self, other)\n \n+    def _entry(self, i, j):\n+        # Special handling for single-matrix case\n+        if len(self.args) == 1:\n+            return self.args[0][i, j]\n+        \n+        # Find the diagonal block containing position (i, j)\n+        row_block = 0\n+        row_offset = 0\n+        for k, size in enumerate(self.rowblocksizes):\n+            if i < row_offset + size:\n+                row_block = k\n+                break\n+            row_offset += size\n+\n+        col_block = 0\n+        col_offset = 0\n+        for k, size in enumerate(self.colblocksizes):\n+            if j < col_offset + size:\n+                col_block = k\n+                break\n+            col_offset += size\n+\n+        if row_block == col_block:\n+            return self.args[row_block][i - row_offset, j - col_offset]\n+        return S.Zero\n+\n \n def block_collapse(expr):\n     \"\"\"Evaluates a block matrix expression\n", "occurrence": 1, "normalized_patch": "--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n+    def _entry(self, i, j):\n+        if len(self.args) == 1:\n+            return self.args[0][i, j]\n+        row_block = 0\n+        row_offset = 0\n+        for k, size in enumerate(self.rowblocksizes):\n+            if i < row_offset + size:\n+                row_block = k\n+                break\n+            row_offset += size\n+        col_block = 0\n+        col_offset = 0\n+        for k, size in enumerate(self.colblocksizes):\n+            if j < col_offset + size:\n+                col_block = k\n+                break\n+            col_offset += size\n+        if row_block == col_block:\n+            return self.args[row_block][i - row_offset, j - col_offset]\n+        return S.Zero", "normalized_occurrence": 1}
