{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13146", "model_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex e24efd1..2fe2319 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -693,6 +693,16 @@ def evalf_pow(v, prec, options):\n         # Positive square root\n         return mpf_sqrt(xre, prec), None, prec, None\n \n+    # Convert float exponents to rationals when possible\n+    if exp.is_Float:\n+        from sympy import nsimplify\n+        rational_exp = nsimplify(exp, rational=True)\n+        if rational_exp.is_Rational:\n+            if rational_exp.is_Integer:\n+                return evalf_pow(v.func(base, rational_exp), prec, options)\n+            if rational_exp.q == 2:  # Handle half integer powers\n+                return evalf_pow(v.func(base, rational_exp), prec, options)\n+\n     # We first evaluate the exponent to find its magnitude\n     # This determines the working precision that must be used\n     prec += 10\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex 54c5b3f..77ce5e9 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -390,6 +390,14 @@ def evalf_pow(v, prec, options):\n         if mpf_lt(xre, fzero):\n             return (None, mpf_sqrt(mpf_neg(xre), prec), None, prec)\n         return (mpf_sqrt(xre, prec), None, prec, None)\n+    if exp.is_Float:\n+        from sympy import nsimplify\n+        rational_exp = nsimplify(exp, rational=True)\n+        if rational_exp.is_Rational:\n+            if rational_exp.is_Integer:\n+                return evalf_pow(v.func(base, rational_exp), prec, options)\n+            if rational_exp.q == 2:\n+                return evalf_pow(v.func(base, rational_exp), prec, options)\n     prec += 10\n     yre, yim, _, _ = evalf(exp, prec, options)\n     if not (yre or yim):\n", "normalized_occurrence": 1}
