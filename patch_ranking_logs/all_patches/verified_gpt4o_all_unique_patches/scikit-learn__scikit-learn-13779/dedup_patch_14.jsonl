{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13779", "model_patch": "diff --git a/sklearn/ensemble/voting.py b/sklearn/ensemble/voting.py\nindex 858d868..b1a001f 100644\n--- a/sklearn/ensemble/voting.py\n+++ b/sklearn/ensemble/voting.py\n@@ -29,10 +29,12 @@ from ..utils import Bunch\n \n def _parallel_fit_estimator(estimator, X, y, sample_weight=None):\n     \"\"\"Private function used to fit an estimator within a job.\"\"\"\n-    if sample_weight is not None:\n-        estimator.fit(X, y, sample_weight=sample_weight)\n-    else:\n-        estimator.fit(X, y)\n+    if estimator is not None:\n+        if sample_weight is not None:\n+            estimator.fit(X, y, sample_weight=sample_weight)\n+        else:\n+            estimator.fit(X, y)\n+    return estimator\n     return estimator\n \n \n@@ -78,7 +80,7 @@ class _BaseVoting(_BaseComposition, TransformerMixin):\n \n         if sample_weight is not None:\n             for name, step in self.estimators:\n-                if not has_fit_parameter(step, 'sample_weight'):\n+                if step is not None and not has_fit_parameter(step, 'sample_weight'):\n                     raise ValueError('Underlying estimator \\'%s\\' does not'\n                                      ' support sample weights.' % name)\n \n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/ensemble/voting.py b/sklearn/ensemble/voting.py\nindex c17361f..275c51d 100644\n--- a/sklearn/ensemble/voting.py\n+++ b/sklearn/ensemble/voting.py\n@@ -10,10 +10,12 @@ from ..utils.validation import has_fit_parameter, check_is_fitted\n from ..utils.metaestimators import _BaseComposition\n from ..utils import Bunch\n def _parallel_fit_estimator(estimator, X, y, sample_weight=None):\n-    if sample_weight is not None:\n-        estimator.fit(X, y, sample_weight=sample_weight)\n-    else:\n-        estimator.fit(X, y)\n+    if estimator is not None:\n+        if sample_weight is not None:\n+            estimator.fit(X, y, sample_weight=sample_weight)\n+        else:\n+            estimator.fit(X, y)\n+    return estimator\n     return estimator\n class _BaseVoting(_BaseComposition, TransformerMixin):\n     _required_parameters = ['estimators']\n@@ -35,7 +37,7 @@ class _BaseVoting(_BaseComposition, TransformerMixin):\n             raise ValueError('Number of `estimators` and weights must be equal; got %d weights, %d estimators' % (len(self.weights), len(self.estimators)))\n         if sample_weight is not None:\n             for name, step in self.estimators:\n-                if not has_fit_parameter(step, 'sample_weight'):\n+                if step is not None and (not has_fit_parameter(step, 'sample_weight')):\n                     raise ValueError(\"Underlying estimator '%s' does not support sample weights.\" % name)\n         names, clfs = zip(*self.estimators)\n         self._validate_names(names)\n", "normalized_occurrence": 1}
