{"model_name_or_path": "agentless_claude", "instance_id": "django__django-15732", "model_patch": "diff --git a/django/db/backends/postgresql/schema.py b/django/db/backends/postgresql/schema.py\nindex fdd1271..4129e11 100644\n--- a/django/db/backends/postgresql/schema.py\n+++ b/django/db/backends/postgresql/schema.py\n@@ -1,3 +1,4 @@\n+\n import psycopg2\n \n from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n@@ -13,6 +14,32 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n         \"; SET CONSTRAINTS ALL IMMEDIATE\"\n     )\n+    \n+    def _find_unique_constraint_name(self, table_name, columns):\n+        \"\"\"Find the specific unique constraint name for a set of columns.\"\"\"\n+        constraints = self.connection.introspection.get_constraints(\n+            self.connection.cursor(), table_name\n+        )\n+        for constraint_name, constraint_info in constraints.items():\n+            if (\n+                constraint_info[\"unique\"] \n+                and constraint_info[\"columns\"] == list(columns)\n+                and not constraint_info[\"primary_key\"]\n+            ):\n+                return constraint_name\n+        return None\n+\n+    def _delete_unique_constraint(self, model, fields):\n+        \"\"\"Delete a specific unique constraint without affecting other unique constraints.\"\"\"\n+        table_name = model._meta.db_table\n+        columns = [field.column for field in fields]\n+        constraint_name = self._find_unique_constraint_name(table_name, columns)\n+        if constraint_name:\n+            sql = \"ALTER TABLE %s DROP CONSTRAINT %s\" % (\n+                self.quote_name(table_name),\n+                self.quote_name(constraint_name),\n+            )\n+            self.execute(sql)\n \n     sql_delete_sequence = \"DROP SEQUENCE IF EXISTS %(sequence)s CASCADE\"\n \n@@ -252,6 +279,28 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n     def remove_index(self, model, index, concurrently=False):\n         self.execute(index.remove_sql(model, self, concurrently=concurrently))\n+        \n+    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        \"\"\"\n+        Deal with a model changing its unique_together. The input unique_togethers\n+        must be doubly-nested sets/frozensets of field names.\n+        \"\"\"\n+        old_unique_together = {frozenset(fields) for fields in old_unique_together}\n+        new_unique_together = {frozenset(fields) for fields in new_unique_together}\n+        \n+        # Remove unique constraints to be dropped\n+        for fields in old_unique_together - new_unique_together:\n+            fields_obj = [model._meta.get_field(field) for field in fields]\n+            # Use custom deletion that preserves other unique constraints\n+            self._delete_unique_constraint(model, fields_obj)\n+            \n+        # Add new unique constraints\n+        for fields in new_unique_together - old_unique_together:\n+            fields_obj = [model._meta.get_field(field) for field in fields]\n+            columns = [field.column for field in fields_obj]\n+            sql = self._create_unique_sql(model, columns)\n+            if sql:\n+                self.execute(sql)\n \n     def _delete_index_sql(self, model, name, sql=None, concurrently=False):\n         sql = (\n@@ -296,4 +345,4 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             condition=condition,\n             include=include,\n             expressions=expressions,\n-        )\n+        )\n", "occurrence": 1, "normalized_patch": "--- a/django/db/backends/postgresql/schema.py\n+++ b/django/db/backends/postgresql/schema.py\n+    def _find_unique_constraint_name(self, table_name, columns):\n+        constraints = self.connection.introspection.get_constraints(self.connection.cursor(), table_name)\n+        for constraint_name, constraint_info in constraints.items():\n+            if constraint_info['unique'] and constraint_info['columns'] == list(columns) and (not constraint_info['primary_key']):\n+                return constraint_name\n+        return None\n+    def _delete_unique_constraint(self, model, fields):\n+        table_name = model._meta.db_table\n+        columns = [field.column for field in fields]\n+        constraint_name = self._find_unique_constraint_name(table_name, columns)\n+        if constraint_name:\n+            sql = 'ALTER TABLE %s DROP CONSTRAINT %s' % (self.quote_name(table_name), self.quote_name(constraint_name))\n+            self.execute(sql)\n+    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        old_unique_together = {frozenset(fields) for fields in old_unique_together}\n+        new_unique_together = {frozenset(fields) for fields in new_unique_together}\n+        for fields in old_unique_together - new_unique_together:\n+            fields_obj = [model._meta.get_field(field) for field in fields]\n+            self._delete_unique_constraint(model, fields_obj)\n+        for fields in new_unique_together - old_unique_together:\n+            fields_obj = [model._meta.get_field(field) for field in fields]\n+            columns = [field.column for field in fields_obj]\n+            sql = self._create_unique_sql(model, columns)\n+            if sql:\n+                self.execute(sql)", "normalized_occurrence": 1}
