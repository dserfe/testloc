{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-18621", "model_patch": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex cc9a4f7..13e74c0 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -343,6 +343,31 @@ class BlockDiagMatrix(BlockMatrix):\n         else:\n             return BlockMatrix._blockadd(self, other)\n \n+    def _entry(self, i, j, **kwargs):\n+        # Handle the case of a single matrix\n+        if len(self.args) == 1:\n+            return self.args[0][i, j]\n+        \n+        # For multiple matrices, find the appropriate block\n+        rowsizes = self.rowblocksizes\n+        colsizes = self.colblocksizes\n+        \n+        row_block = 0\n+        row_offset = 0\n+        while i >= row_offset + rowsizes[row_block]:\n+            row_offset += rowsizes[row_block]\n+            row_block += 1\n+            \n+        col_block = 0\n+        col_offset = 0\n+        while j >= col_offset + colsizes[col_block]:\n+            col_offset += colsizes[col_block]\n+            col_block += 1\n+            \n+        if row_block == col_block:\n+            return self.args[row_block][i - row_offset, j - col_offset]\n+        return S.Zero\n+\n \n def block_collapse(expr):\n     \"\"\"Evaluates a block matrix expression\n", "occurrence": 1, "normalized_patch": "--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n+    def _entry(self, i, j, **kwargs):\n+        if len(self.args) == 1:\n+            return self.args[0][i, j]\n+        rowsizes = self.rowblocksizes\n+        colsizes = self.colblocksizes\n+        row_block = 0\n+        row_offset = 0\n+        while i >= row_offset + rowsizes[row_block]:\n+            row_offset += rowsizes[row_block]\n+            row_block += 1\n+        col_block = 0\n+        col_offset = 0\n+        while j >= col_offset + colsizes[col_block]:\n+            col_offset += colsizes[col_block]\n+            col_block += 1\n+        if row_block == col_block:\n+            return self.args[row_block][i - row_offset, j - col_offset]\n+        return S.Zero", "normalized_occurrence": 1}
