{"model_name_or_path": "agentless_claude", "instance_id": "scikit-learn__scikit-learn-25973", "model_patch": "diff --git a/sklearn/feature_selection/_sequential.py b/sklearn/feature_selection/_sequential.py\nindex 2854ca5..2b97437 100644\n--- a/sklearn/feature_selection/_sequential.py\n+++ b/sklearn/feature_selection/_sequential.py\n@@ -305,11 +305,13 @@ class SequentialFeatureSelector(SelectorMixin, MetaEstimatorMixin, BaseEstimator\n             if self.direction == \"backward\":\n                 candidate_mask = ~candidate_mask\n             X_new = X[:, candidate_mask]\n+            # Convert cv to list if it's an iterator to allow multiple passes\n+            cv = list(self.cv) if hasattr(self.cv, '__iter__') and not isinstance(self.cv, (list, tuple)) else self.cv\n             scores[feature_idx] = cross_val_score(\n                 estimator,\n                 X_new,\n                 y,\n-                cv=self.cv,\n+                cv=cv,\n                 scoring=self.scoring,\n                 n_jobs=self.n_jobs,\n             ).mean()\n@@ -323,4 +325,4 @@ class SequentialFeatureSelector(SelectorMixin, MetaEstimatorMixin, BaseEstimator\n     def _more_tags(self):\n         return {\n             \"allow_nan\": _safe_tags(self.estimator, key=\"allow_nan\"),\n-        }\n+        }\ndiff --git a/sklearn/model_selection/_validation.py b/sklearn/model_selection/_validation.py\nindex 295d6b7..fe3abde 100644\n--- a/sklearn/model_selection/_validation.py\n+++ b/sklearn/model_selection/_validation.py\n@@ -1943,9 +1943,12 @@ def _aggregate_score_dicts(scores):\n     {'a': array([1, 2, 3, 10]),\n      'b': array([10, 2, 3, 10])}\n     \"\"\"\n+    if not scores:\n+        return {}\n+    \n     return {\n         key: np.asarray([score[key] for score in scores])\n         if isinstance(scores[0][key], numbers.Number)\n         else [score[key] for score in scores]\n         for key in scores[0]\n-    }\n+    }\n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/model_selection/_validation.py b/sklearn/model_selection/_validation.py\nindex c8c3425..c9f3742 100644\n--- a/sklearn/model_selection/_validation.py\n+++ b/sklearn/model_selection/_validation.py\n@@ -422,4 +422,6 @@ def validation_curve(estimator, X, y, *, param_name, param_range, groups=None, c\n     test_scores = results['test_scores'].reshape(-1, n_params).T\n     return (train_scores, test_scores)\n def _aggregate_score_dicts(scores):\n+    if not scores:\n+        return {}\n     return {key: np.asarray([score[key] for score in scores]) if isinstance(scores[0][key], numbers.Number) else [score[key] for score in scores] for key in scores[0]}\n\\ No newline at end of file\ndiff --git a/sklearn/feature_selection/_sequential.py b/sklearn/feature_selection/_sequential.py\nindex f5583ad..15e3d36 100644\n--- a/sklearn/feature_selection/_sequential.py\n+++ b/sklearn/feature_selection/_sequential.py\n@@ -69,7 +69,8 @@ class SequentialFeatureSelector(SelectorMixin, MetaEstimatorMixin, BaseEstimator\n             if self.direction == 'backward':\n                 candidate_mask = ~candidate_mask\n             X_new = X[:, candidate_mask]\n-            scores[feature_idx] = cross_val_score(estimator, X_new, y, cv=self.cv, scoring=self.scoring, n_jobs=self.n_jobs).mean()\n+            cv = list(self.cv) if hasattr(self.cv, '__iter__') and (not isinstance(self.cv, (list, tuple))) else self.cv\n+            scores[feature_idx] = cross_val_score(estimator, X_new, y, cv=cv, scoring=self.scoring, n_jobs=self.n_jobs).mean()\n         new_feature_idx = max(scores, key=lambda feature_idx: scores[feature_idx])\n         return (new_feature_idx, scores[new_feature_idx])\n     def _get_support_mask(self):\n", "normalized_occurrence": 1}
