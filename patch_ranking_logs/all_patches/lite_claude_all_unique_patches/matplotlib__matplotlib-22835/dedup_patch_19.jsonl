{"model_name_or_path": "agentless_claude", "instance_id": "matplotlib__matplotlib-22835", "model_patch": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 1878dd6..2056eac 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1903,13 +1903,39 @@ class BoundaryNorm(Normalize):\n \n     def inverse(self, value):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Compute an approximate inverse of the normalization.\n+\n+        Parameters\n+        ----------\n+        value : array-like\n+            Array of normalized values between 0 and 1.\n+\n+        Returns\n+        -------\n+        result : array-like\n+            Array of values approximately corresponding to the normalized input.\n+            For values between boundaries, returns the middle value of the\n+            corresponding bin.\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        # Convert normalized values to indices\n+        n = self._n_regions\n+        x = np.asanyarray(value)\n+        \n+        # Scale to number of regions and get bin indices\n+        indices = np.clip((x * n).astype(int), 0, n - 1)\n+        \n+        # For each index, return the middle value of the corresponding bin\n+        result = np.zeros_like(x, dtype=float)\n+        for i in range(n):\n+            mask = indices == i\n+            if np.any(mask):\n+                start_idx = max(0, i - self._offset)\n+                result[mask] = (self.boundaries[start_idx] + \n+                              self.boundaries[start_idx + 1]) / 2\n+                \n+        if np.ndim(value) == 0:\n+            result = float(result)  # Convert 0-d array to scalar\n+        return result\n \n \n class NoNorm(Normalize):\n", "occurrence": 1, "normalized_patch": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex b4a7c6b..d9ab1de 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1631,13 +1631,32 @@ class BoundaryNorm(Normalize):\n \n     def inverse(self, value):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Compute an approximate inverse of the normalization.\n+\n+        Parameters\n+        ----------\n+        value : array-like\n+            Array of normalized values between 0 and 1.\n+\n+        Returns\n+        -------\n+        result : array-like\n+            Array of values approximately corresponding to the normalized input.\n+            For values between boundaries, returns the middle value of the\n+            corresponding bin.\n         \"\"\"\n-        raise ValueError('BoundaryNorm is not invertible')\n+        n = self._n_regions\n+        x = np.asanyarray(value)\n+        indices = np.clip((x * n).astype(int), 0, n - 1)\n+        result = np.zeros_like(x, dtype=float)\n+        for i in range(n):\n+            mask = indices == i\n+            if np.any(mask):\n+                start_idx = max(0, i - self._offset)\n+                result[mask] = (self.boundaries[start_idx] + self.boundaries[start_idx + 1]) / 2\n+        if np.ndim(value) == 0:\n+            result = float(result)\n+        return result\n \n class NoNorm(Normalize):\n     \"\"\"\n", "normalized_occurrence": 1}
