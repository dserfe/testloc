{"model_name_or_path": "agentless_claude", "instance_id": "matplotlib__matplotlib-26208", "model_patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex f9613d3..7b00a98 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -2313,6 +2313,9 @@ class _AxesBase(martist.Artist):\n     def _update_line_limits(self, line):\n         \"\"\"\n         Figures out the data limit of the given line, updating self.dataLim.\n+\n+        For twinned axes, ensures that the data limits are properly maintained\n+        when using stackplots.\n         \"\"\"\n         path = line.get_path()\n         if path.vertices.size == 0:\n@@ -2353,9 +2356,30 @@ class _AxesBase(martist.Artist):\n                 updatex = False\n             if updatey and line_trf == self.get_xaxis_transform():\n                 updatey = False\n-        self.dataLim.update_from_path(data_path,\n-                                      self.ignore_existing_data_limits,\n-                                      updatex=updatex, updatey=updatey)\n+        # Handle stackplots in twinned axes by checking if we're dealing with \n+        # a stackplot on a twinned axis\n+        if self in self._twinned_axes:\n+            # Get the original data limits before update\n+            old_xlim = self.dataLim.intervalx\n+            old_ylim = self.dataLim.intervaly\n+            \n+            # Update the limits\n+            self.dataLim.update_from_path(data_path,\n+                                        self.ignore_existing_data_limits,\n+                                        updatex=updatex, updatey=updatey)\n+            \n+            # For stackplots on twinned axes, preserve the original limits of the primary axis\n+            if hasattr(line, '_is_from_stackplot') and line._is_from_stackplot:\n+                if old_xlim != (0, 1):  # Check if old limits were meaningful\n+                    self.dataLim.intervalx = old_xlim\n+                if old_ylim != (0, 1):  # Check if old limits were meaningful\n+                    self.dataLim.intervaly = old_ylim\n+        else:\n+            # Normal case - not a twinned axis\n+            self.dataLim.update_from_path(data_path,\n+                                        self.ignore_existing_data_limits,\n+                                        updatex=updatex, updatey=updatey)\n+        \n         self.ignore_existing_data_limits = False\n \n     def add_patch(self, p):\n", "occurrence": 1, "normalized_patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex eb9da84..94e49a3 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -969,7 +969,17 @@ class _AxesBase(martist.Artist):\n                 updatex = False\n             if updatey and line_trf == self.get_xaxis_transform():\n                 updatey = False\n-        self.dataLim.update_from_path(data_path, self.ignore_existing_data_limits, updatex=updatex, updatey=updatey)\n+        if self in self._twinned_axes:\n+            old_xlim = self.dataLim.intervalx\n+            old_ylim = self.dataLim.intervaly\n+            self.dataLim.update_from_path(data_path, self.ignore_existing_data_limits, updatex=updatex, updatey=updatey)\n+            if hasattr(line, '_is_from_stackplot') and line._is_from_stackplot:\n+                if old_xlim != (0, 1):\n+                    self.dataLim.intervalx = old_xlim\n+                if old_ylim != (0, 1):\n+                    self.dataLim.intervaly = old_ylim\n+        else:\n+            self.dataLim.update_from_path(data_path, self.ignore_existing_data_limits, updatex=updatex, updatey=updatey)\n         self.ignore_existing_data_limits = False\n     def add_patch(self, p):\n         _api.check_isinstance(mpatches.Patch, p=p)\n", "normalized_occurrence": 1}
