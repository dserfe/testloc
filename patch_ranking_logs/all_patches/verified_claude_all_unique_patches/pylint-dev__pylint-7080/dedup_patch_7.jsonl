{"model_name_or_path": "agentless_claude", "instance_id": "pylint-dev__pylint-7080", "model_patch": "diff --git a/pylint/lint/pylinter.py b/pylint/lint/pylinter.py\nindex 440e6fe..1fdc355 100644\n--- a/pylint/lint/pylinter.py\n+++ b/pylint/lint/pylinter.py\n@@ -548,15 +548,11 @@ class PyLinter(\n         return needed_checkers\n \n     # pylint: disable=unused-argument\n-    @staticmethod\n-    def should_analyze_file(modname: str, path: str, is_argument: bool = False) -> bool:\n+    def should_analyze_file(self, modname: str, path: str, is_argument: bool = False) -> bool:\n         \"\"\"Returns whether a module should be checked.\n \n-        This implementation returns True for all python source file, indicating\n-        that all files should be linted.\n-\n-        Subclasses may override this method to indicate that modules satisfying\n-        certain conditions should not be linted.\n+        This implementation returns True for all python source files that don't match\n+        ignore patterns in the configuration.\n \n         :param str modname: The name of the module to be checked.\n         :param str path: The full path to the source code of the module.\n@@ -565,9 +561,15 @@ class PyLinter(\n                                  checked, since the user requested it explicitly.\n         :returns: True if the module should be checked.\n         \"\"\"\n+        if not path.endswith(\".py\"):\n+            return False\n         if is_argument:\n             return True\n-        return path.endswith(\".py\")\n+        # Check against ignore-paths patterns\n+        for pattern in self._ignore_paths_re:\n+            if pattern.search(path):\n+                return False\n+        return True\n \n     # pylint: enable=unused-argument\n \n", "occurrence": 1, "normalized_patch": "diff --git a/pylint/lint/pylinter.py b/pylint/lint/pylinter.py\nindex afb1178..f0812ec 100644\n--- a/pylint/lint/pylinter.py\n+++ b/pylint/lint/pylinter.py\n@@ -214,11 +214,15 @@ class PyLinter(_ArgumentsManager, _MessageStateHandler, reporters.ReportsHandler\n             if messages or any((self.report_is_enabled(r[0]) for r in checker.reports)):\n                 needed_checkers.append(checker)\n         return needed_checkers\n-    @staticmethod\n-    def should_analyze_file(modname: str, path: str, is_argument: bool=False) -> bool:\n+    def should_analyze_file(self, modname: str, path: str, is_argument: bool=False) -> bool:\n+        if not path.endswith('.py'):\n+            return False\n         if is_argument:\n             return True\n-        return path.endswith('.py')\n+        for pattern in self._ignore_paths_re:\n+            if pattern.search(path):\n+                return False\n+        return True\n     def initialize(self) -> None:\n         for msg in self.msgs_store.messages:\n             if not msg.may_be_emitted():\n", "normalized_occurrence": 2}
