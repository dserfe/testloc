{"model_name_or_path": "agentless_claude", "instance_id": "django__django-13315", "model_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex e59da5c..e2f7889 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1257,6 +1257,10 @@ class ModelChoiceField(ChoiceField):\n         # accessed) so that we can ensure the QuerySet has not been consumed. This\n         # construct might look complicated but it allows for lazy evaluation of\n         # the queryset.\n+        limit_choices_to = self.get_limit_choices_to()\n+        if limit_choices_to is not None:\n+            queryset = self.queryset.filter(limit_choices_to).distinct()\n+            return self.iterator(type('ModelChoiceField', (object,), {'queryset': queryset, 'empty_label': self.empty_label})())\n         return self.iterator(self)\n \n     choices = property(_get_choices, ChoiceField._set_choices)\n", "normalized_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex bdd2237..4e0f3b0 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -643,6 +643,10 @@ class ModelChoiceField(ChoiceField):\n     def _get_choices(self):\n         if hasattr(self, '_choices'):\n             return self._choices\n+        limit_choices_to = self.get_limit_choices_to()\n+        if limit_choices_to is not None:\n+            queryset = self.queryset.filter(limit_choices_to).distinct()\n+            return self.iterator(type('ModelChoiceField', (object,), {'queryset': queryset, 'empty_label': self.empty_label})())\n         return self.iterator(self)\n     choices = property(_get_choices, ChoiceField._set_choices)\n     def prepare_value(self, value):\n", "normalized_occurrence": 1}
