{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-17630", "model_patch": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex 5a4ea29..2daed2f 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -166,7 +166,12 @@ class BlockMatrix(MatrixExpr):\n                 self.colblocksizes == other.rowblocksizes):\n             return BlockMatrix(self.blocks*other.blocks)\n \n-        return self * other\n+        result = self.blocks * other.blocks\n+        for i in range(result.rows):\n+            for j in range(result.cols):\n+                if result[i, j] == 0:\n+                    result[i, j] = ZeroMatrix(self.blocks[i, 0].rows, other.blocks[0, j].cols)\n+        return BlockMatrix(result)\n \n     def _blockadd(self, other):\n         if (isinstance(other, BlockMatrix)\n@@ -451,7 +456,12 @@ def bc_dist(expr):\n     return unpacked\n \n \n-def bc_matmul(expr):\n+def _convert_zeros_to_zeromatrix(matrix, rowblocksizes, colblocksizes):\n+    for i in range(matrix.rows):\n+        for j in range(matrix.cols):\n+            if matrix[i, j] == 0:\n+                matrix[i, j] = ZeroMatrix(rowblocksizes[i], colblocksizes[j])\n+    return matrix\n     if isinstance(expr, MatPow):\n         if expr.args[1].is_Integer:\n             factor, matrices = (1, [expr.args[0]]*expr.args[1])\n@@ -474,7 +484,10 @@ def bc_matmul(expr):\n             matrices.pop(i+1)\n         else:\n             i+=1\n-    return MatMul(factor, *matrices).doit()\n+    result = MatMul(factor, *matrices).doit()\n+    if isinstance(result, BlockMatrix):\n+        result.blocks = _convert_zeros_to_zeromatrix(result.blocks, result.rowblocksizes, result.colblocksizes)\n+    return result\n \n def bc_transpose(expr):\n     collapse = block_collapse(expr.arg)\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex c0f9049..4a1d842 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -73,7 +73,12 @@ class BlockMatrix(MatrixExpr):\n     def _blockmul(self, other):\n         if isinstance(other, BlockMatrix) and self.colblocksizes == other.rowblocksizes:\n             return BlockMatrix(self.blocks * other.blocks)\n-        return self * other\n+        result = self.blocks * other.blocks\n+        for i in range(result.rows):\n+            for j in range(result.cols):\n+                if result[i, j] == 0:\n+                    result[i, j] = ZeroMatrix(self.blocks[i, 0].rows, other.blocks[0, j].cols)\n+        return BlockMatrix(result)\n     def _blockadd(self, other):\n         if isinstance(other, BlockMatrix) and self.structurally_equal(other):\n             return BlockMatrix(self.blocks + other.blocks)\n@@ -225,7 +230,12 @@ def bc_dist(expr):\n         new_B = [[factor * B[i, j] for j in range(B.cols)] for i in range(B.rows)]\n         return BlockMatrix(new_B)\n     return unpacked\n-def bc_matmul(expr):\n+def _convert_zeros_to_zeromatrix(matrix, rowblocksizes, colblocksizes):\n+    for i in range(matrix.rows):\n+        for j in range(matrix.cols):\n+            if matrix[i, j] == 0:\n+                matrix[i, j] = ZeroMatrix(rowblocksizes[i], colblocksizes[j])\n+    return matrix\n     if isinstance(expr, MatPow):\n         if expr.args[1].is_Integer:\n             factor, matrices = (1, [expr.args[0]] * expr.args[1])\n@@ -247,7 +257,10 @@ def bc_matmul(expr):\n             matrices.pop(i + 1)\n         else:\n             i += 1\n-    return MatMul(factor, *matrices).doit()\n+    result = MatMul(factor, *matrices).doit()\n+    if isinstance(result, BlockMatrix):\n+        result.blocks = _convert_zeros_to_zeromatrix(result.blocks, result.rowblocksizes, result.colblocksizes)\n+    return result\n def bc_transpose(expr):\n     collapse = block_collapse(expr.arg)\n     return collapse._eval_transpose()\n", "normalized_occurrence": 1}
