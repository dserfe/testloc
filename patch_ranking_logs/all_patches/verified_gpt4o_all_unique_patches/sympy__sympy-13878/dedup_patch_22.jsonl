{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13878", "model_patch": "diff --git a/sympy/stats/crv_types.py b/sympy/stats/crv_types.py\nindex e880705..b272b67 100644\n--- a/sympy/stats/crv_types.py\n+++ b/sympy/stats/crv_types.py\n@@ -150,6 +150,55 @@ def rv(symbol, cls, args):\n class ArcsinDistribution(SingleContinuousDistribution):\n     _argnames = ('a', 'b')\n \n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum(\n+            (-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))\n+        ).doit()\n+\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1)/2 + x * hyper([S(1)/2, S(1)/2], [S(3)/2], -x**2/nu) / (sqrt(nu) * beta_fn(S(1)/2, nu / 2))\n+\n+    def _cdf(self, x):\n+        mu, omega = self.mu, self.omega\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+\n+    def _cdf(self, x):\n+        mu, s = self.mu, self.s\n+        return 1 / (1 + exp(-(x - mu) / s))\n+\n+    def _cdf(self, x):\n+        mu, b = self.mu, self.b\n+        return Piecewise(\n+            (S(1)/2 * exp((x - mu) / b), x < mu),\n+            (1 - S(1)/2 * exp(-(x - mu) / b), x >= mu)\n+        )\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 1 - (1 - x ** a) ** b\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return uppergamma(a, b / x) / gamma(a)\n+\n+    def _cdf(self, x):\n+        k, theta = self.k, self.theta\n+        return lowergamma(k, x / theta) / gamma(k)\n+\n+    def _cdf(self, x):\n+        a, s, m = self.a, self.s, self.m\n+        return exp(-((x - m) / s) ** (-a))\n+\n+    def _cdf(self, x):\n+        p, a, b = self.p, self.a, self.b\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 2/pi * asin(sqrt((x - a) / (b - a)))\n+\n     def pdf(self, x):\n         return 1/(pi*sqrt((x - self.a)*(self.b - x)))\n \n@@ -666,6 +715,55 @@ def ChiSquared(name, k):\n class DagumDistribution(SingleContinuousDistribution):\n     _argnames = ('p', 'a', 'b')\n \n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum(\n+            (-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))\n+        ).doit()\n+\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1)/2 + x * hyper([S(1)/2, S(1)/2], [S(3)/2], -x**2/nu) / (sqrt(nu) * beta_fn(S(1)/2, nu / 2))\n+\n+    def _cdf(self, x):\n+        mu, omega = self.mu, self.omega\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+\n+    def _cdf(self, x):\n+        mu, s = self.mu, self.s\n+        return 1 / (1 + exp(-(x - mu) / s))\n+\n+    def _cdf(self, x):\n+        mu, b = self.mu, self.b\n+        return Piecewise(\n+            (S(1)/2 * exp((x - mu) / b), x < mu),\n+            (1 - S(1)/2 * exp(-(x - mu) / b), x >= mu)\n+        )\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 1 - (1 - x ** a) ** b\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return uppergamma(a, b / x) / gamma(a)\n+\n+    def _cdf(self, x):\n+        k, theta = self.k, self.theta\n+        return lowergamma(k, x / theta) / gamma(k)\n+\n+    def _cdf(self, x):\n+        a, s, m = self.a, self.s, self.m\n+        return exp(-((x - m) / s) ** (-a))\n+\n+    def _cdf(self, x):\n+        p, a, b = self.p, self.a, self.b\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 2/pi * asin(sqrt((x - a) / (b - a)))\n+\n     def pdf(self, x):\n         p, a, b = self.p, self.a, self.b\n         return a*p/x*((x/b)**(a*p)/(((x/b)**a + 1)**(p + 1)))\n@@ -1038,6 +1136,55 @@ class FrechetDistribution(SingleContinuousDistribution):\n         a, s, m = list(map(sympify, (a, s, m)))\n         return Basic.__new__(cls, a, s, m)\n \n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum(\n+            (-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))\n+        ).doit()\n+\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1)/2 + x * hyper([S(1)/2, S(1)/2], [S(3)/2], -x**2/nu) / (sqrt(nu) * beta_fn(S(1)/2, nu / 2))\n+\n+    def _cdf(self, x):\n+        mu, omega = self.mu, self.omega\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+\n+    def _cdf(self, x):\n+        mu, s = self.mu, self.s\n+        return 1 / (1 + exp(-(x - mu) / s))\n+\n+    def _cdf(self, x):\n+        mu, b = self.mu, self.b\n+        return Piecewise(\n+            (S(1)/2 * exp((x - mu) / b), x < mu),\n+            (1 - S(1)/2 * exp(-(x - mu) / b), x >= mu)\n+        )\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 1 - (1 - x ** a) ** b\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return uppergamma(a, b / x) / gamma(a)\n+\n+    def _cdf(self, x):\n+        k, theta = self.k, self.theta\n+        return lowergamma(k, x / theta) / gamma(k)\n+\n+    def _cdf(self, x):\n+        a, s, m = self.a, self.s, self.m\n+        return exp(-((x - m) / s) ** (-a))\n+\n+    def _cdf(self, x):\n+        p, a, b = self.p, self.a, self.b\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 2/pi * asin(sqrt((x - a) / (b - a)))\n+\n     def pdf(self, x):\n         a, s, m = self.a, self.s, self.m\n         return a/s * ((x-m)/s)**(-1-a) * exp(-((x-m)/s)**(-a))\n@@ -1104,6 +1251,55 @@ class GammaDistribution(SingleContinuousDistribution):\n         _value_check(k > 0, \"k must be positive\")\n         _value_check(theta > 0, \"Theta must be positive\")\n \n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum(\n+            (-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))\n+        ).doit()\n+\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1)/2 + x * hyper([S(1)/2, S(1)/2], [S(3)/2], -x**2/nu) / (sqrt(nu) * beta_fn(S(1)/2, nu / 2))\n+\n+    def _cdf(self, x):\n+        mu, omega = self.mu, self.omega\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+\n+    def _cdf(self, x):\n+        mu, s = self.mu, self.s\n+        return 1 / (1 + exp(-(x - mu) / s))\n+\n+    def _cdf(self, x):\n+        mu, b = self.mu, self.b\n+        return Piecewise(\n+            (S(1)/2 * exp((x - mu) / b), x < mu),\n+            (1 - S(1)/2 * exp(-(x - mu) / b), x >= mu)\n+        )\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 1 - (1 - x ** a) ** b\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return uppergamma(a, b / x) / gamma(a)\n+\n+    def _cdf(self, x):\n+        k, theta = self.k, self.theta\n+        return lowergamma(k, x / theta) / gamma(k)\n+\n+    def _cdf(self, x):\n+        a, s, m = self.a, self.s, self.m\n+        return exp(-((x - m) / s) ** (-a))\n+\n+    def _cdf(self, x):\n+        p, a, b = self.p, self.a, self.b\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 2/pi * asin(sqrt((x - a) / (b - a)))\n+\n     def pdf(self, x):\n         k, theta = self.k, self.theta\n         return x**(k - 1) * exp(-x/theta) / (gamma(k)*theta**k)\n@@ -1196,6 +1392,55 @@ class GammaInverseDistribution(SingleContinuousDistribution):\n         _value_check(a > 0, \"alpha must be positive\")\n         _value_check(b > 0, \"beta must be positive\")\n \n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum(\n+            (-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))\n+        ).doit()\n+\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1)/2 + x * hyper([S(1)/2, S(1)/2], [S(3)/2], -x**2/nu) / (sqrt(nu) * beta_fn(S(1)/2, nu / 2))\n+\n+    def _cdf(self, x):\n+        mu, omega = self.mu, self.omega\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+\n+    def _cdf(self, x):\n+        mu, s = self.mu, self.s\n+        return 1 / (1 + exp(-(x - mu) / s))\n+\n+    def _cdf(self, x):\n+        mu, b = self.mu, self.b\n+        return Piecewise(\n+            (S(1)/2 * exp((x - mu) / b), x < mu),\n+            (1 - S(1)/2 * exp(-(x - mu) / b), x >= mu)\n+        )\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 1 - (1 - x ** a) ** b\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return uppergamma(a, b / x) / gamma(a)\n+\n+    def _cdf(self, x):\n+        k, theta = self.k, self.theta\n+        return lowergamma(k, x / theta) / gamma(k)\n+\n+    def _cdf(self, x):\n+        a, s, m = self.a, self.s, self.m\n+        return exp(-((x - m) / s) ** (-a))\n+\n+    def _cdf(self, x):\n+        p, a, b = self.p, self.a, self.b\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 2/pi * asin(sqrt((x - a) / (b - a)))\n+\n     def pdf(self, x):\n         a, b = self.a, self.b\n         return b**a/gamma(a) * x**(-a-1) * exp(-b/x)\n@@ -1381,6 +1626,55 @@ class KumaraswamyDistribution(SingleContinuousDistribution):\n         _value_check(a > 0, \"a must be positive\")\n         _value_check(b > 0, \"b must be positive\")\n \n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum(\n+            (-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))\n+        ).doit()\n+\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1)/2 + x * hyper([S(1)/2, S(1)/2], [S(3)/2], -x**2/nu) / (sqrt(nu) * beta_fn(S(1)/2, nu / 2))\n+\n+    def _cdf(self, x):\n+        mu, omega = self.mu, self.omega\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+\n+    def _cdf(self, x):\n+        mu, s = self.mu, self.s\n+        return 1 / (1 + exp(-(x - mu) / s))\n+\n+    def _cdf(self, x):\n+        mu, b = self.mu, self.b\n+        return Piecewise(\n+            (S(1)/2 * exp((x - mu) / b), x < mu),\n+            (1 - S(1)/2 * exp(-(x - mu) / b), x >= mu)\n+        )\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 1 - (1 - x ** a) ** b\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return uppergamma(a, b / x) / gamma(a)\n+\n+    def _cdf(self, x):\n+        k, theta = self.k, self.theta\n+        return lowergamma(k, x / theta) / gamma(k)\n+\n+    def _cdf(self, x):\n+        a, s, m = self.a, self.s, self.m\n+        return exp(-((x - m) / s) ** (-a))\n+\n+    def _cdf(self, x):\n+        p, a, b = self.p, self.a, self.b\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 2/pi * asin(sqrt((x - a) / (b - a)))\n+\n     def pdf(self, x):\n         a, b = self.a, self.b\n         return a * b * x**(a-1) * (1-x**a)**(b-1)\n@@ -1441,6 +1735,55 @@ def Kumaraswamy(name, a, b):\n class LaplaceDistribution(SingleContinuousDistribution):\n     _argnames = ('mu', 'b')\n \n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum(\n+            (-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))\n+        ).doit()\n+\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1)/2 + x * hyper([S(1)/2, S(1)/2], [S(3)/2], -x**2/nu) / (sqrt(nu) * beta_fn(S(1)/2, nu / 2))\n+\n+    def _cdf(self, x):\n+        mu, omega = self.mu, self.omega\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+\n+    def _cdf(self, x):\n+        mu, s = self.mu, self.s\n+        return 1 / (1 + exp(-(x - mu) / s))\n+\n+    def _cdf(self, x):\n+        mu, b = self.mu, self.b\n+        return Piecewise(\n+            (S(1)/2 * exp((x - mu) / b), x < mu),\n+            (1 - S(1)/2 * exp(-(x - mu) / b), x >= mu)\n+        )\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 1 - (1 - x ** a) ** b\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return uppergamma(a, b / x) / gamma(a)\n+\n+    def _cdf(self, x):\n+        k, theta = self.k, self.theta\n+        return lowergamma(k, x / theta) / gamma(k)\n+\n+    def _cdf(self, x):\n+        a, s, m = self.a, self.s, self.m\n+        return exp(-((x - m) / s) ** (-a))\n+\n+    def _cdf(self, x):\n+        p, a, b = self.p, self.a, self.b\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 2/pi * asin(sqrt((x - a) / (b - a)))\n+\n     def pdf(self, x):\n         mu, b = self.mu, self.b\n         return 1/(2*b)*exp(-Abs(x - mu)/b)\n@@ -1497,6 +1840,55 @@ def Laplace(name, mu, b):\n class LogisticDistribution(SingleContinuousDistribution):\n     _argnames = ('mu', 's')\n \n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum(\n+            (-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))\n+        ).doit()\n+\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1)/2 + x * hyper([S(1)/2, S(1)/2], [S(3)/2], -x**2/nu) / (sqrt(nu) * beta_fn(S(1)/2, nu / 2))\n+\n+    def _cdf(self, x):\n+        mu, omega = self.mu, self.omega\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+\n+    def _cdf(self, x):\n+        mu, s = self.mu, self.s\n+        return 1 / (1 + exp(-(x - mu) / s))\n+\n+    def _cdf(self, x):\n+        mu, b = self.mu, self.b\n+        return Piecewise(\n+            (S(1)/2 * exp((x - mu) / b), x < mu),\n+            (1 - S(1)/2 * exp(-(x - mu) / b), x >= mu)\n+        )\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 1 - (1 - x ** a) ** b\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return uppergamma(a, b / x) / gamma(a)\n+\n+    def _cdf(self, x):\n+        k, theta = self.k, self.theta\n+        return lowergamma(k, x / theta) / gamma(k)\n+\n+    def _cdf(self, x):\n+        a, s, m = self.a, self.s, self.m\n+        return exp(-((x - m) / s) ** (-a))\n+\n+    def _cdf(self, x):\n+        p, a, b = self.p, self.a, self.b\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 2/pi * asin(sqrt((x - a) / (b - a)))\n+\n     def pdf(self, x):\n         mu, s = self.mu, self.s\n         return exp(-(x - mu)/s)/(s*(1 + exp(-(x - mu)/s))**2)\n@@ -1707,6 +2099,55 @@ class NakagamiDistribution(SingleContinuousDistribution):\n \n     set = Interval(0, oo)\n \n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum(\n+            (-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))\n+        ).doit()\n+\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1)/2 + x * hyper([S(1)/2, S(1)/2], [S(3)/2], -x**2/nu) / (sqrt(nu) * beta_fn(S(1)/2, nu / 2))\n+\n+    def _cdf(self, x):\n+        mu, omega = self.mu, self.omega\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+\n+    def _cdf(self, x):\n+        mu, s = self.mu, self.s\n+        return 1 / (1 + exp(-(x - mu) / s))\n+\n+    def _cdf(self, x):\n+        mu, b = self.mu, self.b\n+        return Piecewise(\n+            (S(1)/2 * exp((x - mu) / b), x < mu),\n+            (1 - S(1)/2 * exp(-(x - mu) / b), x >= mu)\n+        )\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 1 - (1 - x ** a) ** b\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return uppergamma(a, b / x) / gamma(a)\n+\n+    def _cdf(self, x):\n+        k, theta = self.k, self.theta\n+        return lowergamma(k, x / theta) / gamma(k)\n+\n+    def _cdf(self, x):\n+        a, s, m = self.a, self.s, self.m\n+        return exp(-((x - m) / s) ** (-a))\n+\n+    def _cdf(self, x):\n+        p, a, b = self.p, self.a, self.b\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 2/pi * asin(sqrt((x - a) / (b - a)))\n+\n     def pdf(self, x):\n         mu, omega = self.mu, self.omega\n         return 2*mu**mu/(gamma(mu)*omega**mu)*x**(2*mu - 1)*exp(-mu/omega*x**2)\n@@ -2223,6 +2664,55 @@ def ShiftedGompertz(name, b, eta):\n class StudentTDistribution(SingleContinuousDistribution):\n     _argnames = ('nu',)\n \n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum(\n+            (-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))\n+        ).doit()\n+\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1)/2 + x * hyper([S(1)/2, S(1)/2], [S(3)/2], -x**2/nu) / (sqrt(nu) * beta_fn(S(1)/2, nu / 2))\n+\n+    def _cdf(self, x):\n+        mu, omega = self.mu, self.omega\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+\n+    def _cdf(self, x):\n+        mu, s = self.mu, self.s\n+        return 1 / (1 + exp(-(x - mu) / s))\n+\n+    def _cdf(self, x):\n+        mu, b = self.mu, self.b\n+        return Piecewise(\n+            (S(1)/2 * exp((x - mu) / b), x < mu),\n+            (1 - S(1)/2 * exp(-(x - mu) / b), x >= mu)\n+        )\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 1 - (1 - x ** a) ** b\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return uppergamma(a, b / x) / gamma(a)\n+\n+    def _cdf(self, x):\n+        k, theta = self.k, self.theta\n+        return lowergamma(k, x / theta) / gamma(k)\n+\n+    def _cdf(self, x):\n+        a, s, m = self.a, self.s, self.m\n+        return exp(-((x - m) / s) ** (-a))\n+\n+    def _cdf(self, x):\n+        p, a, b = self.p, self.a, self.b\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 2/pi * asin(sqrt((x - a) / (b - a)))\n+\n     def pdf(self, x):\n         nu = self.nu\n         return 1/(sqrt(nu)*beta_fn(S(1)/2, nu/2))*(1 + x**2/nu)**(-(nu + 1)/2)\n@@ -2548,6 +3038,55 @@ class UniformSumDistribution(SingleContinuousDistribution):\n     def set(self):\n         return Interval(0, self.n)\n \n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum(\n+            (-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))\n+        ).doit()\n+\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1)/2 + x * hyper([S(1)/2, S(1)/2], [S(3)/2], -x**2/nu) / (sqrt(nu) * beta_fn(S(1)/2, nu / 2))\n+\n+    def _cdf(self, x):\n+        mu, omega = self.mu, self.omega\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+\n+    def _cdf(self, x):\n+        mu, s = self.mu, self.s\n+        return 1 / (1 + exp(-(x - mu) / s))\n+\n+    def _cdf(self, x):\n+        mu, b = self.mu, self.b\n+        return Piecewise(\n+            (S(1)/2 * exp((x - mu) / b), x < mu),\n+            (1 - S(1)/2 * exp(-(x - mu) / b), x >= mu)\n+        )\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 1 - (1 - x ** a) ** b\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return uppergamma(a, b / x) / gamma(a)\n+\n+    def _cdf(self, x):\n+        k, theta = self.k, self.theta\n+        return lowergamma(k, x / theta) / gamma(k)\n+\n+    def _cdf(self, x):\n+        a, s, m = self.a, self.s, self.m\n+        return exp(-((x - m) / s) ** (-a))\n+\n+    def _cdf(self, x):\n+        p, a, b = self.p, self.a, self.b\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+\n+    def _cdf(self, x):\n+        a, b = self.a, self.b\n+        return 2/pi * asin(sqrt((x - a) / (b - a)))\n+\n     def pdf(self, x):\n         n = self.n\n         k = Dummy(\"k\")\n", "occurrence": 1, "normalized_patch": "--- a/sympy/stats/crv_types.py\n+++ b/sympy/stats/crv_types.py\n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum((-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))).doit()\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1) / 2 + x * hyper([S(1) / 2, S(1) / 2], [S(3) / 2], -x ** 2 / nu) / (sqrt(nu) * beta_fn(S(1) / 2, nu / 2))\n+    def _cdf(self, x):\n+        mu, omega = (self.mu, self.omega)\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+    def _cdf(self, x):\n+        mu, s = (self.mu, self.s)\n+        return 1 / (1 + exp(-(x - mu) / s))\n+    def _cdf(self, x):\n+        mu, b = (self.mu, self.b)\n+        return Piecewise((S(1) / 2 * exp((x - mu) / b), x < mu), (1 - S(1) / 2 * exp(-(x - mu) / b), x >= mu))\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 1 - (1 - x ** a) ** b\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return uppergamma(a, b / x) / gamma(a)\n+    def _cdf(self, x):\n+        k, theta = (self.k, self.theta)\n+        return lowergamma(k, x / theta) / gamma(k)\n+    def _cdf(self, x):\n+        a, s, m = (self.a, self.s, self.m)\n+        return exp(-((x - m) / s) ** (-a))\n+    def _cdf(self, x):\n+        p, a, b = (self.p, self.a, self.b)\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 2 / pi * asin(sqrt((x - a) / (b - a)))\n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum((-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))).doit()\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1) / 2 + x * hyper([S(1) / 2, S(1) / 2], [S(3) / 2], -x ** 2 / nu) / (sqrt(nu) * beta_fn(S(1) / 2, nu / 2))\n+    def _cdf(self, x):\n+        mu, omega = (self.mu, self.omega)\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+    def _cdf(self, x):\n+        mu, s = (self.mu, self.s)\n+        return 1 / (1 + exp(-(x - mu) / s))\n+    def _cdf(self, x):\n+        mu, b = (self.mu, self.b)\n+        return Piecewise((S(1) / 2 * exp((x - mu) / b), x < mu), (1 - S(1) / 2 * exp(-(x - mu) / b), x >= mu))\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 1 - (1 - x ** a) ** b\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return uppergamma(a, b / x) / gamma(a)\n+    def _cdf(self, x):\n+        k, theta = (self.k, self.theta)\n+        return lowergamma(k, x / theta) / gamma(k)\n+    def _cdf(self, x):\n+        a, s, m = (self.a, self.s, self.m)\n+        return exp(-((x - m) / s) ** (-a))\n+    def _cdf(self, x):\n+        p, a, b = (self.p, self.a, self.b)\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 2 / pi * asin(sqrt((x - a) / (b - a)))\n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum((-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))).doit()\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1) / 2 + x * hyper([S(1) / 2, S(1) / 2], [S(3) / 2], -x ** 2 / nu) / (sqrt(nu) * beta_fn(S(1) / 2, nu / 2))\n+    def _cdf(self, x):\n+        mu, omega = (self.mu, self.omega)\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+    def _cdf(self, x):\n+        mu, s = (self.mu, self.s)\n+        return 1 / (1 + exp(-(x - mu) / s))\n+    def _cdf(self, x):\n+        mu, b = (self.mu, self.b)\n+        return Piecewise((S(1) / 2 * exp((x - mu) / b), x < mu), (1 - S(1) / 2 * exp(-(x - mu) / b), x >= mu))\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 1 - (1 - x ** a) ** b\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return uppergamma(a, b / x) / gamma(a)\n+    def _cdf(self, x):\n+        k, theta = (self.k, self.theta)\n+        return lowergamma(k, x / theta) / gamma(k)\n+    def _cdf(self, x):\n+        a, s, m = (self.a, self.s, self.m)\n+        return exp(-((x - m) / s) ** (-a))\n+    def _cdf(self, x):\n+        p, a, b = (self.p, self.a, self.b)\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 2 / pi * asin(sqrt((x - a) / (b - a)))\n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum((-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))).doit()\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1) / 2 + x * hyper([S(1) / 2, S(1) / 2], [S(3) / 2], -x ** 2 / nu) / (sqrt(nu) * beta_fn(S(1) / 2, nu / 2))\n+    def _cdf(self, x):\n+        mu, omega = (self.mu, self.omega)\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+    def _cdf(self, x):\n+        mu, s = (self.mu, self.s)\n+        return 1 / (1 + exp(-(x - mu) / s))\n+    def _cdf(self, x):\n+        mu, b = (self.mu, self.b)\n+        return Piecewise((S(1) / 2 * exp((x - mu) / b), x < mu), (1 - S(1) / 2 * exp(-(x - mu) / b), x >= mu))\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 1 - (1 - x ** a) ** b\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return uppergamma(a, b / x) / gamma(a)\n+    def _cdf(self, x):\n+        k, theta = (self.k, self.theta)\n+        return lowergamma(k, x / theta) / gamma(k)\n+    def _cdf(self, x):\n+        a, s, m = (self.a, self.s, self.m)\n+        return exp(-((x - m) / s) ** (-a))\n+    def _cdf(self, x):\n+        p, a, b = (self.p, self.a, self.b)\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 2 / pi * asin(sqrt((x - a) / (b - a)))\n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum((-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))).doit()\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1) / 2 + x * hyper([S(1) / 2, S(1) / 2], [S(3) / 2], -x ** 2 / nu) / (sqrt(nu) * beta_fn(S(1) / 2, nu / 2))\n+    def _cdf(self, x):\n+        mu, omega = (self.mu, self.omega)\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+    def _cdf(self, x):\n+        mu, s = (self.mu, self.s)\n+        return 1 / (1 + exp(-(x - mu) / s))\n+    def _cdf(self, x):\n+        mu, b = (self.mu, self.b)\n+        return Piecewise((S(1) / 2 * exp((x - mu) / b), x < mu), (1 - S(1) / 2 * exp(-(x - mu) / b), x >= mu))\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 1 - (1 - x ** a) ** b\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return uppergamma(a, b / x) / gamma(a)\n+    def _cdf(self, x):\n+        k, theta = (self.k, self.theta)\n+        return lowergamma(k, x / theta) / gamma(k)\n+    def _cdf(self, x):\n+        a, s, m = (self.a, self.s, self.m)\n+        return exp(-((x - m) / s) ** (-a))\n+    def _cdf(self, x):\n+        p, a, b = (self.p, self.a, self.b)\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 2 / pi * asin(sqrt((x - a) / (b - a)))\n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum((-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))).doit()\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1) / 2 + x * hyper([S(1) / 2, S(1) / 2], [S(3) / 2], -x ** 2 / nu) / (sqrt(nu) * beta_fn(S(1) / 2, nu / 2))\n+    def _cdf(self, x):\n+        mu, omega = (self.mu, self.omega)\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+    def _cdf(self, x):\n+        mu, s = (self.mu, self.s)\n+        return 1 / (1 + exp(-(x - mu) / s))\n+    def _cdf(self, x):\n+        mu, b = (self.mu, self.b)\n+        return Piecewise((S(1) / 2 * exp((x - mu) / b), x < mu), (1 - S(1) / 2 * exp(-(x - mu) / b), x >= mu))\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 1 - (1 - x ** a) ** b\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return uppergamma(a, b / x) / gamma(a)\n+    def _cdf(self, x):\n+        k, theta = (self.k, self.theta)\n+        return lowergamma(k, x / theta) / gamma(k)\n+    def _cdf(self, x):\n+        a, s, m = (self.a, self.s, self.m)\n+        return exp(-((x - m) / s) ** (-a))\n+    def _cdf(self, x):\n+        p, a, b = (self.p, self.a, self.b)\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 2 / pi * asin(sqrt((x - a) / (b - a)))\n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum((-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))).doit()\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1) / 2 + x * hyper([S(1) / 2, S(1) / 2], [S(3) / 2], -x ** 2 / nu) / (sqrt(nu) * beta_fn(S(1) / 2, nu / 2))\n+    def _cdf(self, x):\n+        mu, omega = (self.mu, self.omega)\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+    def _cdf(self, x):\n+        mu, s = (self.mu, self.s)\n+        return 1 / (1 + exp(-(x - mu) / s))\n+    def _cdf(self, x):\n+        mu, b = (self.mu, self.b)\n+        return Piecewise((S(1) / 2 * exp((x - mu) / b), x < mu), (1 - S(1) / 2 * exp(-(x - mu) / b), x >= mu))\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 1 - (1 - x ** a) ** b\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return uppergamma(a, b / x) / gamma(a)\n+    def _cdf(self, x):\n+        k, theta = (self.k, self.theta)\n+        return lowergamma(k, x / theta) / gamma(k)\n+    def _cdf(self, x):\n+        a, s, m = (self.a, self.s, self.m)\n+        return exp(-((x - m) / s) ** (-a))\n+    def _cdf(self, x):\n+        p, a, b = (self.p, self.a, self.b)\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 2 / pi * asin(sqrt((x - a) / (b - a)))\n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum((-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))).doit()\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1) / 2 + x * hyper([S(1) / 2, S(1) / 2], [S(3) / 2], -x ** 2 / nu) / (sqrt(nu) * beta_fn(S(1) / 2, nu / 2))\n+    def _cdf(self, x):\n+        mu, omega = (self.mu, self.omega)\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+    def _cdf(self, x):\n+        mu, s = (self.mu, self.s)\n+        return 1 / (1 + exp(-(x - mu) / s))\n+    def _cdf(self, x):\n+        mu, b = (self.mu, self.b)\n+        return Piecewise((S(1) / 2 * exp((x - mu) / b), x < mu), (1 - S(1) / 2 * exp(-(x - mu) / b), x >= mu))\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 1 - (1 - x ** a) ** b\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return uppergamma(a, b / x) / gamma(a)\n+    def _cdf(self, x):\n+        k, theta = (self.k, self.theta)\n+        return lowergamma(k, x / theta) / gamma(k)\n+    def _cdf(self, x):\n+        a, s, m = (self.a, self.s, self.m)\n+        return exp(-((x - m) / s) ** (-a))\n+    def _cdf(self, x):\n+        p, a, b = (self.p, self.a, self.b)\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 2 / pi * asin(sqrt((x - a) / (b - a)))\n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum((-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))).doit()\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1) / 2 + x * hyper([S(1) / 2, S(1) / 2], [S(3) / 2], -x ** 2 / nu) / (sqrt(nu) * beta_fn(S(1) / 2, nu / 2))\n+    def _cdf(self, x):\n+        mu, omega = (self.mu, self.omega)\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+    def _cdf(self, x):\n+        mu, s = (self.mu, self.s)\n+        return 1 / (1 + exp(-(x - mu) / s))\n+    def _cdf(self, x):\n+        mu, b = (self.mu, self.b)\n+        return Piecewise((S(1) / 2 * exp((x - mu) / b), x < mu), (1 - S(1) / 2 * exp(-(x - mu) / b), x >= mu))\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 1 - (1 - x ** a) ** b\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return uppergamma(a, b / x) / gamma(a)\n+    def _cdf(self, x):\n+        k, theta = (self.k, self.theta)\n+        return lowergamma(k, x / theta) / gamma(k)\n+    def _cdf(self, x):\n+        a, s, m = (self.a, self.s, self.m)\n+        return exp(-((x - m) / s) ** (-a))\n+    def _cdf(self, x):\n+        p, a, b = (self.p, self.a, self.b)\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 2 / pi * asin(sqrt((x - a) / (b - a)))\n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum((-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))).doit()\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1) / 2 + x * hyper([S(1) / 2, S(1) / 2], [S(3) / 2], -x ** 2 / nu) / (sqrt(nu) * beta_fn(S(1) / 2, nu / 2))\n+    def _cdf(self, x):\n+        mu, omega = (self.mu, self.omega)\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+    def _cdf(self, x):\n+        mu, s = (self.mu, self.s)\n+        return 1 / (1 + exp(-(x - mu) / s))\n+    def _cdf(self, x):\n+        mu, b = (self.mu, self.b)\n+        return Piecewise((S(1) / 2 * exp((x - mu) / b), x < mu), (1 - S(1) / 2 * exp(-(x - mu) / b), x >= mu))\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 1 - (1 - x ** a) ** b\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return uppergamma(a, b / x) / gamma(a)\n+    def _cdf(self, x):\n+        k, theta = (self.k, self.theta)\n+        return lowergamma(k, x / theta) / gamma(k)\n+    def _cdf(self, x):\n+        a, s, m = (self.a, self.s, self.m)\n+        return exp(-((x - m) / s) ** (-a))\n+    def _cdf(self, x):\n+        p, a, b = (self.p, self.a, self.b)\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 2 / pi * asin(sqrt((x - a) / (b - a)))\n+    def _cdf(self, x):\n+        n = self.n\n+        return 1 / factorial(n - 1) * Sum((-1) ** k * binomial(n, k) * (x - k) ** (n - 1), (k, 0, floor(x))).doit()\n+    def _cdf(self, x):\n+        nu = self.nu\n+        return S(1) / 2 + x * hyper([S(1) / 2, S(1) / 2], [S(3) / 2], -x ** 2 / nu) / (sqrt(nu) * beta_fn(S(1) / 2, nu / 2))\n+    def _cdf(self, x):\n+        mu, omega = (self.mu, self.omega)\n+        return gamma(mu, mu / omega * x ** 2) / gamma(mu)\n+    def _cdf(self, x):\n+        mu, s = (self.mu, self.s)\n+        return 1 / (1 + exp(-(x - mu) / s))\n+    def _cdf(self, x):\n+        mu, b = (self.mu, self.b)\n+        return Piecewise((S(1) / 2 * exp((x - mu) / b), x < mu), (1 - S(1) / 2 * exp(-(x - mu) / b), x >= mu))\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 1 - (1 - x ** a) ** b\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return uppergamma(a, b / x) / gamma(a)\n+    def _cdf(self, x):\n+        k, theta = (self.k, self.theta)\n+        return lowergamma(k, x / theta) / gamma(k)\n+    def _cdf(self, x):\n+        a, s, m = (self.a, self.s, self.m)\n+        return exp(-((x - m) / s) ** (-a))\n+    def _cdf(self, x):\n+        p, a, b = (self.p, self.a, self.b)\n+        return 1 - (1 + (x / b) ** (-a)) ** (-p)\n+    def _cdf(self, x):\n+        a, b = (self.a, self.b)\n+        return 2 / pi * asin(sqrt((x - a) / (b - a)))", "normalized_occurrence": 1}
