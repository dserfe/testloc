{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13146", "model_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex e24efd1..0e6f10d 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -642,6 +642,13 @@ def evalf_pow(v, prec, options):\n \n     target_prec = prec\n     base, exp = v.args\n+    \n+    # Convert float exponents to rational numbers for consistent evaluation\n+    if exp.is_Float:\n+        from sympy.core.numbers import Float\n+        exp = Float(exp).as_rational()\n+        v = v.func(base, exp)\n+        return evalf_pow(v, prec, options)\n \n     # We handle x**n separately. This has two purposes: 1) it is much\n     # faster, because we avoid calling evalf on the exponent, and 2) it\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex 54c5b3f..68fce59 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -357,6 +357,11 @@ def evalf_mul(v, prec, options):\n def evalf_pow(v, prec, options):\n     target_prec = prec\n     base, exp = v.args\n+    if exp.is_Float:\n+        from sympy.core.numbers import Float\n+        exp = Float(exp).as_rational()\n+        v = v.func(base, exp)\n+        return evalf_pow(v, prec, options)\n     if exp.is_Integer:\n         p = exp.p\n         if not p:\n", "normalized_occurrence": 1}
