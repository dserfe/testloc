{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13647", "model_patch": "diff --git a/sympy/matrices/dense.py b/sympy/matrices/dense.py\nindex 8faef3a..863a090 100644\n--- a/sympy/matrices/dense.py\n+++ b/sympy/matrices/dense.py\n@@ -410,23 +410,22 @@ class MutableDenseMatrix(DenseMatrix, MatrixBase):\n     def __new__(cls, *args, **kwargs):\n         return cls._new(*args, **kwargs)\n \n-    @classmethod\n-    def _new(cls, *args, **kwargs):\n-        # if the `copy` flag is set to False, the input\n-        # was rows, cols, [list].  It should be used directly\n-        # without creating a copy.\n-        if kwargs.get('copy', True) is False:\n-            if len(args) != 3:\n-                raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n-            rows, cols, flat_list = args\n-        else:\n-            rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n-            flat_list = list(flat_list) # create a shallow copy\n-        self = object.__new__(cls)\n-        self.rows = rows\n-        self.cols = cols\n-        self._mat = flat_list\n-        return self\n+    def col_insert(self, pos, other):\n+        if not isinstance(other, MatrixBase):\n+            raise TypeError(\"`other` must be of type Matrix\")\n+\n+        if self.rows != other.rows:\n+            raise ShapeError(\"`self` and `other` must have the same number of rows.\")\n+\n+        new_mat = self._mat[:]\n+        col_offset = 0\n+\n+        for i in range(other.cols):\n+            for j in range(self.rows):\n+                new_mat.insert((pos + col_offset) * self.rows + j, other[j, i])\n+            col_offset += 1\n+\n+        return self._new(self.rows, self.cols + other.cols, new_mat)\n \n     def __setitem__(self, key, value):\n         \"\"\"\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/matrices/dense.py b/sympy/matrices/dense.py\nindex ed7ad28..fd6ac8d 100644\n--- a/sympy/matrices/dense.py\n+++ b/sympy/matrices/dense.py\n@@ -204,20 +204,18 @@ def _force_mutable(x):\n class MutableDenseMatrix(DenseMatrix, MatrixBase):\n     def __new__(cls, *args, **kwargs):\n         return cls._new(*args, **kwargs)\n-    @classmethod\n-    def _new(cls, *args, **kwargs):\n-        if kwargs.get('copy', True) is False:\n-            if len(args) != 3:\n-                raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n-            rows, cols, flat_list = args\n-        else:\n-            rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n-            flat_list = list(flat_list)\n-        self = object.__new__(cls)\n-        self.rows = rows\n-        self.cols = cols\n-        self._mat = flat_list\n-        return self\n+    def col_insert(self, pos, other):\n+        if not isinstance(other, MatrixBase):\n+            raise TypeError('`other` must be of type Matrix')\n+        if self.rows != other.rows:\n+            raise ShapeError('`self` and `other` must have the same number of rows.')\n+        new_mat = self._mat[:]\n+        col_offset = 0\n+        for i in range(other.cols):\n+            for j in range(self.rows):\n+                new_mat.insert((pos + col_offset) * self.rows + j, other[j, i])\n+            col_offset += 1\n+        return self._new(self.rows, self.cols + other.cols, new_mat)\n     def __setitem__(self, key, value):\n         rv = self._setitem(key, value)\n         if rv is not None:\n", "normalized_occurrence": 1}
