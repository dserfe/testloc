{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13757", "model_patch": "diff --git a/sympy/core/mul.py b/sympy/core/mul.py\nindex dd02372..d11b127 100644\n--- a/sympy/core/mul.py\n+++ b/sympy/core/mul.py\n@@ -173,31 +173,7 @@ class Mul(Expr, AssocOp):\n               Removal of 1 from the sequence is already handled by AssocOp.__new__.\n         \"\"\"\n \n-        from sympy.calculus.util import AccumBounds\n-        from sympy.matrices.expressions import MatrixExpr\n-        rv = None\n-        if len(seq) == 2:\n-            a, b = seq\n-            if b.is_Rational:\n-                a, b = b, a\n-            assert not a is S.One\n-            if not a.is_zero and a.is_Rational:\n-                r, b = b.as_coeff_Mul()\n-                if b.is_Add:\n-                    if r is not S.One:  # 2-arg hack\n-                        # leave the Mul as a Mul\n-                        rv = [cls(a*r, b, evaluate=False)], [], None\n-                    elif global_distribute[0] and b.is_commutative:\n-                        r, b = b.as_coeff_Add()\n-                        bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]\n-                        _addsort(bargs)\n-                        ar = a*r\n-                        if ar:\n-                            bargs.insert(0, ar)\n-                        bargs = [Add._from_args(bargs)]\n-                        rv = bargs, [], None\n-            if rv:\n-                return rv\n+\n \n         # apply associativity, separate commutative part of seq\n         c_part = []         # out: commutative factors\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/mul.py b/sympy/core/mul.py\nindex 6739e29..0e1934e 100644\n--- a/sympy/core/mul.py\n+++ b/sympy/core/mul.py\n@@ -47,30 +47,6 @@ class Mul(Expr, AssocOp):\n     is_Mul = True\n     @classmethod\n     def flatten(cls, seq):\n-        from sympy.calculus.util import AccumBounds\n-        from sympy.matrices.expressions import MatrixExpr\n-        rv = None\n-        if len(seq) == 2:\n-            a, b = seq\n-            if b.is_Rational:\n-                a, b = (b, a)\n-            assert not a is S.One\n-            if not a.is_zero and a.is_Rational:\n-                r, b = b.as_coeff_Mul()\n-                if b.is_Add:\n-                    if r is not S.One:\n-                        rv = ([cls(a * r, b, evaluate=False)], [], None)\n-                    elif global_distribute[0] and b.is_commutative:\n-                        r, b = b.as_coeff_Add()\n-                        bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]\n-                        _addsort(bargs)\n-                        ar = a * r\n-                        if ar:\n-                            bargs.insert(0, ar)\n-                        bargs = [Add._from_args(bargs)]\n-                        rv = (bargs, [], None)\n-            if rv:\n-                return rv\n         c_part = []\n         nc_part = []\n         nc_seq = []\n", "normalized_occurrence": 1}
