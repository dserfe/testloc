{"model_name_or_path": "agentless_claude", "instance_id": "django__django-15957", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 5314293..58a7989 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -2145,16 +2145,27 @@ class Prefetch:\n         self.prefetch_through = lookup\n         # `prefetch_to` is the path to the attribute that stores the result.\n         self.prefetch_to = lookup\n-        if queryset is not None and (\n-            isinstance(queryset, RawQuerySet)\n-            or (\n+        if queryset is not None:\n+            if isinstance(queryset, RawQuerySet) or (\n                 hasattr(queryset, \"_iterable_class\")\n                 and not issubclass(queryset._iterable_class, ModelIterable)\n-            )\n-        ):\n-            raise ValueError(\n-                \"Prefetch querysets cannot use raw(), values(), and values_list().\"\n-            )\n+            ):\n+                raise ValueError(\n+                    \"Prefetch querysets cannot use raw(), values(), and values_list().\"\n+                )\n+            \n+            # Handle sliced querysets\n+            if queryset._has_filters() and (\n+                queryset.query.low_mark or queryset.query.high_mark\n+            ):\n+                self._limit_start = queryset.query.low_mark\n+                self._limit_stop = queryset.query.high_mark\n+                # Create a new queryset without the slice\n+                queryset = queryset.model._base_manager.all()\n+            else:\n+                self._limit_start = None\n+                self._limit_stop = None\n+\n         if to_attr:\n             self.prefetch_to = LOOKUP_SEP.join(\n                 lookup.split(LOOKUP_SEP)[:-1] + [to_attr]\n@@ -2188,7 +2199,12 @@ class Prefetch:\n \n     def get_current_queryset(self, level):\n         if self.get_current_prefetch_to(level) == self.prefetch_to:\n-            return self.queryset\n+            queryset = self.queryset\n+            if queryset is not None and hasattr(self, '_limit_start') and (\n+                self._limit_start is not None or self._limit_stop is not None\n+            ):\n+                queryset = queryset.all()[self._limit_start:self._limit_stop]\n+            return queryset\n         return None\n \n     def __eq__(self, other):\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex cb06696..dc5d06b 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1117,8 +1117,16 @@ class Prefetch:\n     def __init__(self, lookup, queryset=None, to_attr=None):\n         self.prefetch_through = lookup\n         self.prefetch_to = lookup\n-        if queryset is not None and (isinstance(queryset, RawQuerySet) or (hasattr(queryset, '_iterable_class') and (not issubclass(queryset._iterable_class, ModelIterable)))):\n-            raise ValueError('Prefetch querysets cannot use raw(), values(), and values_list().')\n+        if queryset is not None:\n+            if isinstance(queryset, RawQuerySet) or (hasattr(queryset, '_iterable_class') and (not issubclass(queryset._iterable_class, ModelIterable))):\n+                raise ValueError('Prefetch querysets cannot use raw(), values(), and values_list().')\n+            if queryset._has_filters() and (queryset.query.low_mark or queryset.query.high_mark):\n+                self._limit_start = queryset.query.low_mark\n+                self._limit_stop = queryset.query.high_mark\n+                queryset = queryset.model._base_manager.all()\n+            else:\n+                self._limit_start = None\n+                self._limit_stop = None\n         if to_attr:\n             self.prefetch_to = LOOKUP_SEP.join(lookup.split(LOOKUP_SEP)[:-1] + [to_attr])\n         self.queryset = queryset\n@@ -1143,7 +1151,10 @@ class Prefetch:\n         return (to_attr, as_attr)\n     def get_current_queryset(self, level):\n         if self.get_current_prefetch_to(level) == self.prefetch_to:\n-            return self.queryset\n+            queryset = self.queryset\n+            if queryset is not None and hasattr(self, '_limit_start') and (self._limit_start is not None or self._limit_stop is not None):\n+                queryset = queryset.all()[self._limit_start:self._limit_stop]\n+            return queryset\n         return None\n     def __eq__(self, other):\n         if not isinstance(other, Prefetch):\n", "normalized_occurrence": 1}
