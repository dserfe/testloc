{"model_name_or_path": "agentless_claude", "instance_id": "django__django-12858", "model_patch": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 8f934b7..9ddd55d 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -32,6 +32,19 @@ def check_all_models(app_configs=None, **kwargs):\n             )\n         else:\n             errors.extend(model.check(**kwargs))\n+            \n+        # Check ordering fields\n+        for field_name in model._meta.ordering:\n+            is_valid, error_msg = _validate_field_lookup(model, field_name)\n+            if not is_valid:\n+                errors.append(\n+                    Error(\n+                        \"'ordering' refers to %s\" % error_msg,\n+                        obj=model,\n+                        id='models.E015',\n+                    )\n+                )\n+                \n         for model_index in model._meta.indexes:\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n@@ -86,6 +99,45 @@ def check_all_models(app_configs=None, **kwargs):\n     return errors\n \n \n+def _validate_field_lookup(model, field_name):\n+    \"\"\"\n+    Validate that a field lookup path is valid for a model.\n+    Returns a tuple of (is_valid, error_message).\n+    \"\"\"\n+    # Handle empty field name\n+    if not field_name:\n+        return False, \"Empty field name is not allowed.\"\n+\n+    parts = field_name.split('__')\n+    model_cls = model\n+\n+    # Handle '-' prefix for reverse ordering\n+    if parts[0].startswith('-'):\n+        parts[0] = parts[0][1:]\n+\n+    # Traverse through foreign key relationships\n+    for i, part in enumerate(parts):\n+        try:\n+            if i < len(parts) - 1:  # Not the last part\n+                field = model_cls._meta.get_field(part)\n+                if hasattr(field, 'remote_field') and field.remote_field:\n+                    model_cls = field.remote_field.model\n+                else:\n+                    return False, f\"Field '{part}' is not a relation field.\"\n+            else:  # Last part\n+                # If it ends with a known lookup, it's valid\n+                if part in VALID_LOOKUP_ENDS:\n+                    return True, None\n+                # Otherwise, it should be a valid field\n+                field = model_cls._meta.get_field(part)\n+                return True, None\n+        except Exception:\n+            if i == len(parts) - 1 and part in VALID_LOOKUP_ENDS:\n+                return True, None\n+            return False, f\"Field '{part}' does not exist.\"\n+\n+    return True, None\n+\n def _check_lazy_references(apps, ignore=None):\n     \"\"\"\n     Ensure all lazy (i.e. string) model references have been resolved.\n", "occurrence": 1, "normalized_patch": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 50dfeb8..640795c 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -22,6 +22,10 @@ def check_all_models(app_configs=None, **kwargs):\n             errors.append(Error(\"The '%s.check()' class method is currently overridden by %r.\" % (model.__name__, model.check), obj=model, id='models.E020'))\n         else:\n             errors.extend(model.check(**kwargs))\n+        for field_name in model._meta.ordering:\n+            is_valid, error_msg = _validate_field_lookup(model, field_name)\n+            if not is_valid:\n+                errors.append(Error(\"'ordering' refers to %s\" % error_msg, obj=model, id='models.E015'))\n         for model_index in model._meta.indexes:\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n@@ -45,6 +49,31 @@ def check_all_models(app_configs=None, **kwargs):\n             model_labels = set(model_labels)\n             errors.append(Error(\"constraint name '%s' is not unique %s %s.\" % (constraint_name, 'for model' if len(model_labels) == 1 else 'amongst models:', ', '.join(sorted(model_labels))), id='models.E031' if len(model_labels) == 1 else 'models.E032'))\n     return errors\n+def _validate_field_lookup(model, field_name):\n+    if not field_name:\n+        return (False, 'Empty field name is not allowed.')\n+    parts = field_name.split('__')\n+    model_cls = model\n+    if parts[0].startswith('-'):\n+        parts[0] = parts[0][1:]\n+    for i, part in enumerate(parts):\n+        try:\n+            if i < len(parts) - 1:\n+                field = model_cls._meta.get_field(part)\n+                if hasattr(field, 'remote_field') and field.remote_field:\n+                    model_cls = field.remote_field.model\n+                else:\n+                    return (False, f\"Field '{part}' is not a relation field.\")\n+            else:\n+                if part in VALID_LOOKUP_ENDS:\n+                    return (True, None)\n+                field = model_cls._meta.get_field(part)\n+                return (True, None)\n+        except Exception:\n+            if i == len(parts) - 1 and part in VALID_LOOKUP_ENDS:\n+                return (True, None)\n+            return (False, f\"Field '{part}' does not exist.\")\n+    return (True, None)\n def _check_lazy_references(apps, ignore=None):\n     pending_models = set(apps._pending_operations) - (ignore or set())\n     if not pending_models:\n", "normalized_occurrence": 1}
