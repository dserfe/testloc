{"model_name_or_path": "agentless_claude", "instance_id": "django__django-12858", "model_patch": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 8f934b7..d3d3b4c 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -18,6 +18,25 @@ def check_all_models(app_configs=None, **kwargs):\n         models = apps.get_models()\n     else:\n         models = chain.from_iterable(app_config.get_models() for app_config in app_configs)\n+        \n+    # Check model ordering\n+    for model in models:\n+        if model._meta.ordering:\n+            for field_name in model._meta.ordering:\n+                # Skip expressions\n+                if hasattr(field_name, 'asc') or hasattr(field_name, 'desc'):\n+                    continue\n+                # Remove descending prefix if present\n+                if field_name.startswith('-'):\n+                    field_name = field_name[1:]\n+                if not _is_valid_ordering_reference(field_name, model):\n+                    errors.append(\n+                        Error(\n+                            \"'ordering' refers to the nonexistent field, related field, or lookup '%s'.\" % field_name,\n+                            obj=model,\n+                            id='models.E015',\n+                        )\n+                    )\n     for model in models:\n         if model._meta.managed and not model._meta.proxy:\n             db_table_models[model._meta.db_table].append(model._meta.label)\n@@ -86,6 +105,27 @@ def check_all_models(app_configs=None, **kwargs):\n     return errors\n \n \n+def _is_valid_ordering_reference(field_name, model):\n+    \"\"\"\n+    Check if the field name is a valid reference for ordering.\n+    Allows for regular fields, related fields, transforms, and the __isnull lookup.\n+    \"\"\"\n+    try:\n+        if field_name.endswith('__isnull'):\n+            # Handle __isnull lookup specially since it's valid for ordering\n+            base_field = field_name[:-8]  # Remove '__isnull'\n+            if not base_field:  # If field_name was just '__isnull'\n+                return False\n+            # Validate the base field exists\n+            model._meta.get_field_by_name(base_field) if hasattr(model._meta, 'get_field_by_name') else model._meta.get_field(base_field)\n+            return True\n+        else:\n+            # Regular field validation\n+            model._meta.get_field_by_name(field_name) if hasattr(model._meta, 'get_field_by_name') else model._meta.get_field(field_name)\n+            return True\n+    except:\n+        return False\n+\n def _check_lazy_references(apps, ignore=None):\n     \"\"\"\n     Ensure all lazy (i.e. string) model references have been resolved.\n", "occurrence": 1, "normalized_patch": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 50dfeb8..20a7786 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -15,6 +15,15 @@ def check_all_models(app_configs=None, **kwargs):\n         models = apps.get_models()\n     else:\n         models = chain.from_iterable((app_config.get_models() for app_config in app_configs))\n+    for model in models:\n+        if model._meta.ordering:\n+            for field_name in model._meta.ordering:\n+                if hasattr(field_name, 'asc') or hasattr(field_name, 'desc'):\n+                    continue\n+                if field_name.startswith('-'):\n+                    field_name = field_name[1:]\n+                if not _is_valid_ordering_reference(field_name, model):\n+                    errors.append(Error(\"'ordering' refers to the nonexistent field, related field, or lookup '%s'.\" % field_name, obj=model, id='models.E015'))\n     for model in models:\n         if model._meta.managed and (not model._meta.proxy):\n             db_table_models[model._meta.db_table].append(model._meta.label)\n@@ -45,6 +54,19 @@ def check_all_models(app_configs=None, **kwargs):\n             model_labels = set(model_labels)\n             errors.append(Error(\"constraint name '%s' is not unique %s %s.\" % (constraint_name, 'for model' if len(model_labels) == 1 else 'amongst models:', ', '.join(sorted(model_labels))), id='models.E031' if len(model_labels) == 1 else 'models.E032'))\n     return errors\n+def _is_valid_ordering_reference(field_name, model):\n+    try:\n+        if field_name.endswith('__isnull'):\n+            base_field = field_name[:-8]\n+            if not base_field:\n+                return False\n+            model._meta.get_field_by_name(base_field) if hasattr(model._meta, 'get_field_by_name') else model._meta.get_field(base_field)\n+            return True\n+        else:\n+            model._meta.get_field_by_name(field_name) if hasattr(model._meta, 'get_field_by_name') else model._meta.get_field(field_name)\n+            return True\n+    except:\n+        return False\n def _check_lazy_references(apps, ignore=None):\n     pending_models = set(apps._pending_operations) - (ignore or set())\n     if not pending_models:\n", "normalized_occurrence": 1}
