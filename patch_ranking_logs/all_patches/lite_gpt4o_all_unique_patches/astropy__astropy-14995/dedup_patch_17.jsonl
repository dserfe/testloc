{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-14995", "model_patch": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex fbb2aba..87c3a0c 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -473,7 +473,7 @@ class NDArithmeticMixin:\n             operand.uncertainty = None\n             return result_uncert\n \n-        else:\n+        elif self.mask is not None and operand is not None and operand.mask is not None:\n             # Both have uncertainties so just propagate.\n \n             # only supply the axis kwarg if one has been specified for a collapsing operation\n@@ -517,14 +517,16 @@ class NDArithmeticMixin:\n             self.mask is None and operand is not None and operand.mask is None\n         ) or handle_mask is None:\n             return None\n-        elif self.mask is None and operand is not None:\n+        elif self.mask is None and operand is not None and operand.mask is not None:\n             # Make a copy so there is no reference in the result.\n             return deepcopy(operand.mask)\n-        elif operand is None:\n+        elif operand is not None and operand.mask is None:\n             return deepcopy(self.mask)\n-        else:\n+        elif self.mask is not None and operand is not None and operand.mask is not None:\n             # Now lets calculate the resulting mask (operation enforces copy)\n             return handle_mask(self.mask, operand.mask, **kwds)\n+        elif self.mask is not None and operand is not None and operand.mask is not None:\n+            return deepcopy(self.mask) if self.mask is not None else deepcopy(operand.mask)\n \n     def _arithmetic_wcs(self, operation, operand, compare_wcs, **kwds):\n         \"\"\"\n", "occurrence": 1, "normalized_patch": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex b7eb663..fbb3165 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -108,18 +108,20 @@ class NDArithmeticMixin:\n             result_uncert = self.uncertainty.propagate(operation, operand, result, correlation)\n             operand.uncertainty = None\n             return result_uncert\n-        else:\n+        elif self.mask is not None and operand is not None and (operand.mask is not None):\n             axis_kwarg = dict(axis=kwds['axis']) if 'axis' in kwds else dict()\n             return self.uncertainty.propagate(operation, operand, result, correlation, **axis_kwarg)\n     def _arithmetic_mask(self, operation, operand, handle_mask, axis=None, **kwds):\n         if self.mask is None and operand is not None and (operand.mask is None) or handle_mask is None:\n             return None\n-        elif self.mask is None and operand is not None:\n+        elif self.mask is None and operand is not None and (operand.mask is not None):\n             return deepcopy(operand.mask)\n-        elif operand is None:\n+        elif operand is not None and operand.mask is None:\n             return deepcopy(self.mask)\n-        else:\n+        elif self.mask is not None and operand is not None and (operand.mask is not None):\n             return handle_mask(self.mask, operand.mask, **kwds)\n+        elif self.mask is not None and operand is not None and (operand.mask is not None):\n+            return deepcopy(self.mask) if self.mask is not None else deepcopy(operand.mask)\n     def _arithmetic_wcs(self, operation, operand, compare_wcs, **kwds):\n         if not compare_wcs(self.wcs, operand.wcs, **kwds):\n             raise ValueError('WCS are not equal.')\n", "normalized_occurrence": 1}
