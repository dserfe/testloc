{"model_name_or_path": "agentless_claude", "instance_id": "scikit-learn__scikit-learn-12682", "model_patch": "diff --git a/sklearn/decomposition/dict_learning.py b/sklearn/decomposition/dict_learning.py\nindex 8cfbe5f..93a5fcb 100644\n--- a/sklearn/decomposition/dict_learning.py\n+++ b/sklearn/decomposition/dict_learning.py\n@@ -896,11 +896,12 @@ class SparseCodingMixin(TransformerMixin):\n \n         X = check_array(X)\n \n+        params = {} if self.transform_algorithm_params is None else self.transform_algorithm_params\n         code = sparse_encode(\n             X, self.components_, algorithm=self.transform_algorithm,\n             n_nonzero_coefs=self.transform_n_nonzero_coefs,\n             alpha=self.transform_alpha, n_jobs=self.n_jobs,\n-            positive=self.positive_code)\n+            positive=self.positive_code, **params)\n \n         if self.split_sign:\n             # feature vector is split into a positive and negative side\n@@ -974,6 +975,13 @@ class SparseCoder(BaseEstimator, SparseCodingMixin):\n \n         .. versionadded:: 0.20\n \n+    transform_algorithm_params : dict, optional\n+        Additional parameters to pass to the transform algorithm. For example,\n+        when transform_algorithm='lasso_cd', you can pass max_iter to control\n+        the maximum number of iterations.\n+\n+        .. versionadded:: 1.4\n+\n     Attributes\n     ----------\n     components_ : array, [n_components, n_features]\n@@ -991,12 +999,14 @@ class SparseCoder(BaseEstimator, SparseCodingMixin):\n \n     def __init__(self, dictionary, transform_algorithm='omp',\n                  transform_n_nonzero_coefs=None, transform_alpha=None,\n-                 split_sign=False, n_jobs=None, positive_code=False):\n+                 split_sign=False, n_jobs=None, positive_code=False,\n+                 transform_algorithm_params=None):\n         self._set_sparse_coding_params(dictionary.shape[0],\n                                        transform_algorithm,\n                                        transform_n_nonzero_coefs,\n                                        transform_alpha, split_sign, n_jobs,\n                                        positive_code)\n+        self.transform_algorithm_params = transform_algorithm_params\n         self.components_ = dictionary\n \n     def fit(self, X, y=None):\n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/decomposition/dict_learning.py b/sklearn/decomposition/dict_learning.py\nindex 8a206a7..99c07e7 100644\n--- a/sklearn/decomposition/dict_learning.py\n+++ b/sklearn/decomposition/dict_learning.py\n@@ -274,7 +274,8 @@ class SparseCodingMixin(TransformerMixin):\n     def transform(self, X):\n         check_is_fitted(self, 'components_')\n         X = check_array(X)\n-        code = sparse_encode(X, self.components_, algorithm=self.transform_algorithm, n_nonzero_coefs=self.transform_n_nonzero_coefs, alpha=self.transform_alpha, n_jobs=self.n_jobs, positive=self.positive_code)\n+        params = {} if self.transform_algorithm_params is None else self.transform_algorithm_params\n+        code = sparse_encode(X, self.components_, algorithm=self.transform_algorithm, n_nonzero_coefs=self.transform_n_nonzero_coefs, alpha=self.transform_alpha, n_jobs=self.n_jobs, positive=self.positive_code, **params)\n         if self.split_sign:\n             n_samples, n_features = code.shape\n             split_code = np.empty((n_samples, 2 * n_features))\n@@ -284,8 +285,9 @@ class SparseCodingMixin(TransformerMixin):\n         return code\n class SparseCoder(BaseEstimator, SparseCodingMixin):\n     _required_parameters = ['dictionary']\n-    def __init__(self, dictionary, transform_algorithm='omp', transform_n_nonzero_coefs=None, transform_alpha=None, split_sign=False, n_jobs=None, positive_code=False):\n+    def __init__(self, dictionary, transform_algorithm='omp', transform_n_nonzero_coefs=None, transform_alpha=None, split_sign=False, n_jobs=None, positive_code=False, transform_algorithm_params=None):\n         self._set_sparse_coding_params(dictionary.shape[0], transform_algorithm, transform_n_nonzero_coefs, transform_alpha, split_sign, n_jobs, positive_code)\n+        self.transform_algorithm_params = transform_algorithm_params\n         self.components_ = dictionary\n     def fit(self, X, y=None):\n         return self\n", "normalized_occurrence": 1}
