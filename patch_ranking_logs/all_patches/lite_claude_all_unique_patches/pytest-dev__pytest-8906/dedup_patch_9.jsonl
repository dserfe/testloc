{"model_name_or_path": "agentless_claude", "instance_id": "pytest-dev__pytest-8906", "model_patch": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 6515102..3edaac2 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -120,28 +120,28 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+\n+\n+\n @_with_exception(Skipped)\n-def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n-    \"\"\"Skip an executing test with the given message.\n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the rest of the current module with the given message.\n \n-    This function should be called only during testing (setup, call or teardown) or\n-    during collection by using the ``allow_module_level`` flag.  This function can\n-    be called in doctests as well.\n+    This is a convenience function that calls skip() with allow_module_level=True.\n+    It's useful when you need to skip an entire module, for example when the module\n+    contains syntax that is only valid in newer Python versions.\n \n-    :param bool allow_module_level:\n-        Allows this function to be called at module level, skipping the rest\n-        of the module. Defaults to False.\n+    :param str msg: Message to display for the skip.\n \n-    .. note::\n-        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n-        possible to declare a test to be skipped under certain conditions\n-        like mismatching platforms or dependencies.\n-        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n-        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n-        to skip a doctest statically.\n+    Example::\n+\n+        if sys.version_info < (3, 8):\n+            skip_module(\"This module requires Python 3.8+\")\n+\n+        # The rest of the module will be skipped if Python version < 3.8\n     \"\"\"\n     __tracebackhide__ = True\n-    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n+    raise Skipped(msg=msg, allow_module_level=True)\n \n \n @_with_exception(Failed)\n", "occurrence": 1, "normalized_patch": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 4e411e5..3583446 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -79,27 +79,24 @@ def exit(msg: str, returncode: Optional[int]=None) -> 'NoReturn':\n     raise Exit(msg, returncode)\n \n @_with_exception(Skipped)\n-def skip(msg: str='', *, allow_module_level: bool=False) -> 'NoReturn':\n-    \"\"\"Skip an executing test with the given message.\n+def skip_module(msg: str='') -> 'NoReturn':\n+    \"\"\"Skip the rest of the current module with the given message.\n \n-    This function should be called only during testing (setup, call or teardown) or\n-    during collection by using the ``allow_module_level`` flag.  This function can\n-    be called in doctests as well.\n+    This is a convenience function that calls skip() with allow_module_level=True.\n+    It's useful when you need to skip an entire module, for example when the module\n+    contains syntax that is only valid in newer Python versions.\n \n-    :param bool allow_module_level:\n-        Allows this function to be called at module level, skipping the rest\n-        of the module. Defaults to False.\n+    :param str msg: Message to display for the skip.\n \n-    .. note::\n-        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n-        possible to declare a test to be skipped under certain conditions\n-        like mismatching platforms or dependencies.\n-        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n-        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n-        to skip a doctest statically.\n+    Example::\n+\n+        if sys.version_info < (3, 8):\n+            skip_module(\"This module requires Python 3.8+\")\n+\n+        # The rest of the module will be skipped if Python version < 3.8\n     \"\"\"\n     __tracebackhide__ = True\n-    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n+    raise Skipped(msg=msg, allow_module_level=True)\n \n @_with_exception(Failed)\n def fail(msg: str='', pytrace: bool=True) -> 'NoReturn':\n", "normalized_occurrence": 1}
