{"model_name_or_path": "agentless_claude", "instance_id": "matplotlib__matplotlib-25433", "model_patch": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 38a11f3..de378c7 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -2086,6 +2086,10 @@ class FigureCanvasBase:\n         before saving output to disk. For example computing limits,\n         auto-limits, and tick values.\n         \"\"\"\n+        # Reset widget lock state when redrawing to prevent input blocking\n+        was_locked = self.widgetlock.locked()\n+        if was_locked:\n+            self.widgetlock.release(self.widgetlock.locked_obj)\n \n     def draw_idle(self, *args, **kwargs):\n         \"\"\"\n", "occurrence": 1, "normalized_patch": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 66fda6d..6be6bad 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1816,6 +1816,9 @@ class FigureCanvasBase:\n         before saving output to disk. For example computing limits,\n         auto-limits, and tick values.\n         \"\"\"\n+        was_locked = self.widgetlock.locked()\n+        if was_locked:\n+            self.widgetlock.release(self.widgetlock.locked_obj)\n \n     def draw_idle(self, *args, **kwargs):\n         \"\"\"\n", "normalized_occurrence": 1}
