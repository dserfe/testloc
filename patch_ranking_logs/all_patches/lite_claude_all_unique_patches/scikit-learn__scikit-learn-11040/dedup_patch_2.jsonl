{"model_name_or_path": "agentless_claude", "instance_id": "scikit-learn__scikit-learn-11040", "model_patch": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 01d85d0..201352b 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -106,6 +106,13 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n+        \n+        if n_neighbors is not None and not isinstance(n_neighbors, (int, np.integer)):\n+            raise TypeError(\n+                'n_neighbors must be an integer, got %s' % type(n_neighbors))\n+        if n_neighbors is not None and n_neighbors <= 0:\n+            raise ValueError(\n+                'Expected n_neighbors > 0. Got %d' % n_neighbors)\n \n         self.n_neighbors = n_neighbors\n         self.radius = radius\n@@ -281,6 +288,10 @@ class KNeighborsMixin(object):\n                 or (n_query, n_indexed) if metric == 'precomputed'\n             The query point or points.\n             If not provided, neighbors of each indexed point are returned.\n+\n+        n_neighbors : int, optional (default=None)\n+            Number of neighbors required for each sample.\n+            The default is the value passed to the constructor.\n             In this case, the query point is not considered its own neighbor.\n \n         n_neighbors : int\n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex ddfefae..5679961 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -47,6 +47,10 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None, algorithm='auto', leaf_size=30, metric='minkowski', p=2, metric_params=None, n_jobs=1):\n+        if n_neighbors is not None and (not isinstance(n_neighbors, (int, np.integer))):\n+            raise TypeError('n_neighbors must be an integer, got %s' % type(n_neighbors))\n+        if n_neighbors is not None and n_neighbors <= 0:\n+            raise ValueError('Expected n_neighbors > 0. Got %d' % n_neighbors)\n         self.n_neighbors = n_neighbors\n         self.radius = radius\n         self.algorithm = algorithm\n", "normalized_occurrence": 1}
