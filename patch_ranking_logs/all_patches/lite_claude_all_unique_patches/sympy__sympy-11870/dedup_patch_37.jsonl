{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-11870", "model_patch": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex bd243c1..ea49e0e 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -538,6 +538,22 @@ def exptrigsimp(expr):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n+        \n+        # Handle common exponential patterns that map to trig functions\n+        if e.is_Mul and S.ImaginaryUnit in e.free_symbols:\n+            # Try to match sin(x) = (exp(ix) - exp(-ix))/(2i) pattern\n+            coeff, terms = e.as_coeff_mul()\n+            terms = list(terms)\n+            if len(terms) == 2 and all(isinstance(t, exp) for t in terms):\n+                t1, t2 = terms\n+                if (t1.args[0].is_Mul and t2.args[0].is_Mul and \n+                    S.ImaginaryUnit in t1.args[0].args and S.ImaginaryUnit in t2.args[0].args):\n+                    # Check if arguments are negatives of each other\n+                    if t1.args[0] == -t2.args[0]:\n+                        k = t1.args[0].args[1] if len(t1.args[0].args) == 2 else t1.args[0]/S.ImaginaryUnit\n+                        if coeff == S.Half * S.ImaginaryUnit:\n+                            choices.append(sin(k))\n+        \n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n \n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 8c4936d..32f2d27 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -180,6 +180,16 @@ def exptrigsimp(expr):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n+        if e.is_Mul and S.ImaginaryUnit in e.free_symbols:\n+            coeff, terms = e.as_coeff_mul()\n+            terms = list(terms)\n+            if len(terms) == 2 and all((isinstance(t, exp) for t in terms)):\n+                t1, t2 = terms\n+                if t1.args[0].is_Mul and t2.args[0].is_Mul and (S.ImaginaryUnit in t1.args[0].args) and (S.ImaginaryUnit in t2.args[0].args):\n+                    if t1.args[0] == -t2.args[0]:\n+                        k = t1.args[0].args[1] if len(t1.args[0].args) == 2 else t1.args[0] / S.ImaginaryUnit\n+                        if coeff == S.Half * S.ImaginaryUnit:\n+                            choices.append(sin(k))\n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n     def f(rv):\n", "normalized_occurrence": 1}
