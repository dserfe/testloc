{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-14308", "model_patch": "diff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex 81d644a..6ddc087 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -876,92 +876,30 @@ class PrettyPrinter(Printer):\n             delim = u' \\N{N-ARY CIRCLED TIMES OPERATOR} '\n         else:\n             delim = ' x '\n-        return self._print_seq(expr.args, None, None, delim,\n-                parenthesize=lambda x: isinstance(x, (MatAdd, MatMul)))\n-\n-    _print_MatrixSymbol = _print_Symbol\n-\n-    def _print_FunctionMatrix(self, X):\n-        D = self._print(X.lamda.expr)\n-        D = prettyForm(*D.parens('[', ']'))\n-        return D\n+        if expr == expr.zero:\n+            return prettyForm(expr.zero._pretty_form)\n+        components = expr.components\n+        items = sorted(components.items(), key=lambda x: x[0].__str__())\n+        \n+        parts = []\n+        for k, v in items:\n+            if v == 1:\n+                part = prettyForm(k._pretty_form)\n+            elif v == -1:\n+                part = prettyForm(f\"(-1) {k._pretty_form}\")\n+            else:\n+                part = prettyForm(f\"({self._print(v)}) {k._pretty_form}\")\n \n-    def _print_BasisDependent(self, expr):\n-        from sympy.vector import Vector\n+            parts.append(part)\n \n-        if not self._use_unicode:\n-            raise NotImplementedError(\"ASCII pretty printing of BasisDependent is not implemented\")\n+        if not parts:\n+            return prettyForm('')\n \n-        if expr == expr.zero:\n-            return prettyForm(expr.zero._pretty_form)\n-        o1 = []\n-        vectstrs = []\n-        if isinstance(expr, Vector):\n-            items = expr.separate().items()\n-        else:\n-            items = [(0, expr)]\n-        for system, vect in items:\n-            inneritems = list(vect.components.items())\n-            inneritems.sort(key = lambda x: x[0].__str__())\n-            for k, v in inneritems:\n-                #if the coef of the basis vector is 1\n-                #we skip the 1\n-                if v == 1:\n-                    o1.append(u\"\" +\n-                              k._pretty_form)\n-                #Same for -1\n-                elif v == -1:\n-                    o1.append(u\"(-1) \" +\n-                              k._pretty_form)\n-                #For a general expr\n-                else:\n-                    #We always wrap the measure numbers in\n-                    #parentheses\n-                    arg_str = self._print(\n-                        v).parens()[0]\n-\n-                    o1.append(arg_str + ' ' + k._pretty_form)\n-                vectstrs.append(k._pretty_form)\n-\n-        #outstr = u(\"\").join(o1)\n-        if o1[0].startswith(u\" + \"):\n-            o1[0] = o1[0][3:]\n-        elif o1[0].startswith(\" \"):\n-            o1[0] = o1[0][1:]\n-        #Fixing the newlines\n-        lengths = []\n-        strs = ['']\n-        for i, partstr in enumerate(o1):\n-            # XXX: What is this hack?\n-            if '\\n' in partstr:\n-                tempstr = partstr\n-                tempstr = tempstr.replace(vectstrs[i], '')\n-                tempstr = tempstr.replace(u'\\N{RIGHT PARENTHESIS UPPER HOOK}',\n-                                          u'\\N{RIGHT PARENTHESIS UPPER HOOK}'\n-                                          + ' ' + vectstrs[i])\n-                o1[i] = tempstr\n-        o1 = [x.split('\\n') for x in o1]\n-        n_newlines = max([len(x) for x in o1])\n-        for parts in o1:\n-            lengths.append(len(parts[0]))\n-            for j in range(n_newlines):\n-                if j+1 <= len(parts):\n-                    if j >= len(strs):\n-                        strs.append(' ' * (sum(lengths[:-1]) +\n-                                           3*(len(lengths)-1)))\n-                    if j == 0:\n-                        strs[0] += parts[0] + ' + '\n-                    else:\n-                        strs[j] += parts[j] + ' '*(lengths[-1] -\n-                                                   len(parts[j])+\n-                                                   3)\n-                else:\n-                    if j >= len(strs):\n-                        strs.append(' ' * (sum(lengths[:-1]) +\n-                                           3*(len(lengths)-1)))\n-                    strs[j] += ' '*(lengths[-1]+3)\n+        result = parts[0]\n+        for part in parts[1:]:\n+            result = prettyForm(*result.right(' + ')[0], *part.picture)\n \n-        return prettyForm(u'\\n'.join([s[:-3] for s in strs]))\n+        return result\n \n     def _print_NDimArray(self, expr):\n         from sympy import ImmutableMatrix\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex 35c3eb3..036f87f 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -633,65 +633,25 @@ class PrettyPrinter(Printer):\n             delim = u' ⨂ '\n         else:\n             delim = ' x '\n-        return self._print_seq(expr.args, None, None, delim, parenthesize=lambda x: isinstance(x, (MatAdd, MatMul)))\n-    _print_MatrixSymbol = _print_Symbol\n-    def _print_FunctionMatrix(self, X):\n-        D = self._print(X.lamda.expr)\n-        D = prettyForm(*D.parens('[', ']'))\n-        return D\n-    def _print_BasisDependent(self, expr):\n-        from sympy.vector import Vector\n-        if not self._use_unicode:\n-            raise NotImplementedError('ASCII pretty printing of BasisDependent is not implemented')\n         if expr == expr.zero:\n             return prettyForm(expr.zero._pretty_form)\n-        o1 = []\n-        vectstrs = []\n-        if isinstance(expr, Vector):\n-            items = expr.separate().items()\n-        else:\n-            items = [(0, expr)]\n-        for system, vect in items:\n-            inneritems = list(vect.components.items())\n-            inneritems.sort(key=lambda x: x[0].__str__())\n-            for k, v in inneritems:\n-                if v == 1:\n-                    o1.append(u'' + k._pretty_form)\n-                elif v == -1:\n-                    o1.append(u'(-1) ' + k._pretty_form)\n-                else:\n-                    arg_str = self._print(v).parens()[0]\n-                    o1.append(arg_str + ' ' + k._pretty_form)\n-                vectstrs.append(k._pretty_form)\n-        if o1[0].startswith(u' + '):\n-            o1[0] = o1[0][3:]\n-        elif o1[0].startswith(' '):\n-            o1[0] = o1[0][1:]\n-        lengths = []\n-        strs = ['']\n-        for i, partstr in enumerate(o1):\n-            if '\\n' in partstr:\n-                tempstr = partstr\n-                tempstr = tempstr.replace(vectstrs[i], '')\n-                tempstr = tempstr.replace(u'⎞', u'⎞' + ' ' + vectstrs[i])\n-                o1[i] = tempstr\n-        o1 = [x.split('\\n') for x in o1]\n-        n_newlines = max([len(x) for x in o1])\n-        for parts in o1:\n-            lengths.append(len(parts[0]))\n-            for j in range(n_newlines):\n-                if j + 1 <= len(parts):\n-                    if j >= len(strs):\n-                        strs.append(' ' * (sum(lengths[:-1]) + 3 * (len(lengths) - 1)))\n-                    if j == 0:\n-                        strs[0] += parts[0] + ' + '\n-                    else:\n-                        strs[j] += parts[j] + ' ' * (lengths[-1] - len(parts[j]) + 3)\n-                else:\n-                    if j >= len(strs):\n-                        strs.append(' ' * (sum(lengths[:-1]) + 3 * (len(lengths) - 1)))\n-                    strs[j] += ' ' * (lengths[-1] + 3)\n-        return prettyForm(u'\\n'.join([s[:-3] for s in strs]))\n+        components = expr.components\n+        items = sorted(components.items(), key=lambda x: x[0].__str__())\n+        parts = []\n+        for k, v in items:\n+            if v == 1:\n+                part = prettyForm(k._pretty_form)\n+            elif v == -1:\n+                part = prettyForm(f'(-1) {k._pretty_form}')\n+            else:\n+                part = prettyForm(f'({self._print(v)}) {k._pretty_form}')\n+            parts.append(part)\n+        if not parts:\n+            return prettyForm('')\n+        result = parts[0]\n+        for part in parts[1:]:\n+            result = prettyForm(*result.right(' + ')[0], *part.picture)\n+        return result\n     def _print_NDimArray(self, expr):\n         from sympy import ImmutableMatrix\n         if expr.rank() == 0:\n", "normalized_occurrence": 1}
