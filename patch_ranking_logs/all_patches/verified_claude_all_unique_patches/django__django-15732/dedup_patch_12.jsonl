{"model_name_or_path": "agentless_claude", "instance_id": "django__django-15732", "model_patch": "diff --git a/django/db/backends/postgresql/schema.py b/django/db/backends/postgresql/schema.py\nindex fdd1271..8a44362 100644\n--- a/django/db/backends/postgresql/schema.py\n+++ b/django/db/backends/postgresql/schema.py\n@@ -1,3 +1,4 @@\n+\n import psycopg2\n \n from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n@@ -234,16 +235,51 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             )\n             self.execute(self._delete_index_sql(model, index_to_remove))\n \n-    def _index_columns(self, table, columns, col_suffixes, opclasses):\n-        if opclasses:\n-            return IndexColumns(\n-                table,\n-                columns,\n-                self.quote_name,\n-                col_suffixes=col_suffixes,\n-                opclasses=opclasses,\n+\n+\n+    def _get_unique_constraints(self, table_name, columns):\n+        \"\"\"\n+        Return list of unique constraint names for specified table and columns.\n+        \"\"\"\n+        sql = \"\"\"\n+            SELECT tc.constraint_name \n+            FROM information_schema.table_constraints AS tc \n+            JOIN information_schema.constraint_column_usage AS ccu\n+                ON tc.constraint_name = ccu.constraint_name\n+                AND tc.table_schema = ccu.table_schema\n+            WHERE tc.constraint_type = 'UNIQUE'\n+                AND tc.table_name = %s\n+                AND ccu.column_name = ANY(%s)\n+        \"\"\"\n+        with self.connection.cursor() as cursor:\n+            cursor.execute(sql, [table_name, columns])\n+            return [row[0] for row in cursor.fetchall()]\n+\n+    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        \"\"\"\n+        Deal with a model changing its unique_together. The input is two sets of field names.\n+        \"\"\"\n+        old_unique_together = {tuple(fields) for fields in old_unique_together}\n+        new_unique_together = {tuple(fields) for fields in new_unique_together}\n+\n+        # Drop all unique constraints that match the old_unique_together but aren't in new_unique_together\n+        for fields in old_unique_together - new_unique_together:\n+            # Get the name of each constraint, remove them one by one\n+            columns = [model._meta.get_field(field).column for field in fields]\n+            # Get all unique constraints matching these columns\n+            constraints = self._get_unique_constraints(model._meta.db_table, columns)\n+            for constraint_name in constraints:\n+                self.execute(self._delete_constraint_sql(\n+                    self.sql_delete_unique, model, constraint_name))\n+\n+        # Add new unique constraints\n+        for fields in new_unique_together - old_unique_together:\n+            columns = [model._meta.get_field(field).column for field in fields]\n+            condition = \" AND \".join(\n+                [\"%s IS NOT NULL\" % self.quote_name(column) for column in columns]\n             )\n-        return super()._index_columns(table, columns, col_suffixes, opclasses)\n+            sql = self._create_unique_sql(model, columns, condition=condition)\n+            self.execute(sql)\n \n     def add_index(self, model, index, concurrently=False):\n         self.execute(\n@@ -296,4 +332,4 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             condition=condition,\n             include=include,\n             expressions=expressions,\n-        )\n+        )\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/backends/postgresql/schema.py b/django/db/backends/postgresql/schema.py\nindex d911e18..d5a79a0 100644\n--- a/django/db/backends/postgresql/schema.py\n+++ b/django/db/backends/postgresql/schema.py\n@@ -83,10 +83,24 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         if old_field.unique and (not (new_field.db_index or new_field.unique)):\n             index_to_remove = self._create_index_name(model._meta.db_table, [old_field.column], suffix='_like')\n             self.execute(self._delete_index_sql(model, index_to_remove))\n-    def _index_columns(self, table, columns, col_suffixes, opclasses):\n-        if opclasses:\n-            return IndexColumns(table, columns, self.quote_name, col_suffixes=col_suffixes, opclasses=opclasses)\n-        return super()._index_columns(table, columns, col_suffixes, opclasses)\n+    def _get_unique_constraints(self, table_name, columns):\n+        sql = \"\\n            SELECT tc.constraint_name \\n            FROM information_schema.table_constraints AS tc \\n            JOIN information_schema.constraint_column_usage AS ccu\\n                ON tc.constraint_name = ccu.constraint_name\\n                AND tc.table_schema = ccu.table_schema\\n            WHERE tc.constraint_type = 'UNIQUE'\\n                AND tc.table_name = %s\\n                AND ccu.column_name = ANY(%s)\\n        \"\n+        with self.connection.cursor() as cursor:\n+            cursor.execute(sql, [table_name, columns])\n+            return [row[0] for row in cursor.fetchall()]\n+    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        old_unique_together = {tuple(fields) for fields in old_unique_together}\n+        new_unique_together = {tuple(fields) for fields in new_unique_together}\n+        for fields in old_unique_together - new_unique_together:\n+            columns = [model._meta.get_field(field).column for field in fields]\n+            constraints = self._get_unique_constraints(model._meta.db_table, columns)\n+            for constraint_name in constraints:\n+                self.execute(self._delete_constraint_sql(self.sql_delete_unique, model, constraint_name))\n+        for fields in new_unique_together - old_unique_together:\n+            columns = [model._meta.get_field(field).column for field in fields]\n+            condition = ' AND '.join(['%s IS NOT NULL' % self.quote_name(column) for column in columns])\n+            sql = self._create_unique_sql(model, columns, condition=condition)\n+            self.execute(sql)\n     def add_index(self, model, index, concurrently=False):\n         self.execute(index.create_sql(model, self, concurrently=concurrently), params=None)\n     def remove_index(self, model, index, concurrently=False):\n", "normalized_occurrence": 1}
