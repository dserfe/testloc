{"model_name_or_path": "agentless_claude", "instance_id": "astropy__astropy-12907", "model_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex d6e9246..0d92765 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -207,12 +207,21 @@ def _coord_matrix(model, pos, noutp):\n         else:\n             mat[-model.n_outputs:, -model.n_inputs:] = 1\n     else:\n+        # First check if model has a pre-calculated separability matrix\n+        if (transform_matrix := model._calculate_separability_matrix()) is not NotImplemented:\n+            base_mat = transform_matrix\n+        else:\n+            # If not, create a diagonal matrix for separable model\n+            base_mat = np.zeros((model.n_outputs, model.n_inputs))\n+            for i in range(model.n_inputs):\n+                base_mat[i, i] = 1\n+                \n+        # Create the final matrix of the right size\n         mat = np.zeros((noutp, model.n_inputs))\n-\n-        for i in range(model.n_inputs):\n-            mat[i, i] = 1\n-        if pos == 'right':\n-            mat = np.roll(mat, (noutp - model.n_outputs))\n+        if pos == 'left':\n+            mat[:model.n_outputs, :model.n_inputs] = base_mat\n+        else:\n+            mat[-model.n_outputs:, -model.n_inputs:] = base_mat\n     return mat\n \n \n@@ -314,4 +323,4 @@ def _separable(transform):\n # Maps modeling operators to a function computing and represents the\n # relationship of axes as an array of 0-es and 1-s\n _operators = {'&': _cstack, '|': _cdot, '+': _arith_oper, '-': _arith_oper,\n-              '*': _arith_oper, '/': _arith_oper, '**': _arith_oper}\n+              '*': _arith_oper, '/': _arith_oper, '**': _arith_oper}\n", "occurrence": 1, "normalized_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex 198a838..9ff9f3d 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -61,11 +61,17 @@ def _coord_matrix(model, pos, noutp):\n         else:\n             mat[-model.n_outputs:, -model.n_inputs:] = 1\n     else:\n+        if (transform_matrix := model._calculate_separability_matrix()) is not NotImplemented:\n+            base_mat = transform_matrix\n+        else:\n+            base_mat = np.zeros((model.n_outputs, model.n_inputs))\n+            for i in range(model.n_inputs):\n+                base_mat[i, i] = 1\n         mat = np.zeros((noutp, model.n_inputs))\n-        for i in range(model.n_inputs):\n-            mat[i, i] = 1\n-        if pos == 'right':\n-            mat = np.roll(mat, noutp - model.n_outputs)\n+        if pos == 'left':\n+            mat[:model.n_outputs, :model.n_inputs] = base_mat\n+        else:\n+            mat[-model.n_outputs:, -model.n_inputs:] = base_mat\n     return mat\n def _cstack(left, right):\n     noutp = _compute_n_outputs(left, right)\n", "normalized_occurrence": 1}
