{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-5221", "model_patch": "diff --git a/src/_pytest/terminal.py b/src/_pytest/terminal.py\nindex 400ae0b..7021d7b 100644\n--- a/src/_pytest/terminal.py\n+++ b/src/_pytest/terminal.py\n@@ -620,40 +620,22 @@ class TerminalReporter(object):\n                 for rep in self.stats.get(\"failed\"):\n                     rep.toterminal(self._tw)\n \n-    def _printcollecteditems(self, items):\n-        # to print out items and their parent collectors\n-        # we take care to leave out Instances aka ()\n-        # because later versions are going to get rid of them anyway\n-        if self.config.option.verbose < 0:\n-            if self.config.option.verbose < -1:\n-                counts = {}\n-                for item in items:\n-                    name = item.nodeid.split(\"::\", 1)[0]\n-                    counts[name] = counts.get(name, 0) + 1\n-                for name, count in sorted(counts.items()):\n-                    self._tw.line(\"%s: %d\" % (name, count))\n-            else:\n-                for item in items:\n-                    self._tw.line(item.nodeid)\n-            return\n-        stack = []\n-        indent = \"\"\n-        for item in items:\n-            needed_collectors = item.listchain()[1:]  # strip root node\n-            while stack:\n-                if stack == needed_collectors[: len(stack)]:\n-                    break\n-                stack.pop()\n-            for col in needed_collectors[len(stack) :]:\n-                stack.append(col)\n-                if col.name == \"()\":  # Skip Instances.\n-                    continue\n-                indent = (len(stack) - 1) * \"  \"\n-                self._tw.line(\"%s%s\" % (indent, col))\n-                if self.config.option.verbose >= 1:\n-                    if hasattr(col, \"_obj\") and col._obj.__doc__:\n-                        for line in col._obj.__doc__.strip().splitlines():\n-                            self._tw.line(\"%s%s\" % (indent + \"  \", line.strip()))\n+    def _printfixtures(self, fixturemanager):\n+        from _pytest.fixtures import scopes\n+\n+        fm = fixturemanager\n+        available = []\n+        for argname, fixturedefs in sorted(fm._arg2fixturedefs.items()):\n+            fixturedef = fixturedefs[-1]\n+            loc = getlocation(fixturedef.func, config=self.config)\n+            scope = scopes[fixturedef.scope]\n+            available.append((argname, fixturedef, loc, scope))\n+\n+        for argname, fixturedef, loc, scope in available:\n+            self.write_line(\"fixture %s -- %s -- scope: %s\" % (argname, loc, scope))\n+            if fixturedef.func.__doc__:\n+                for line in fixturedef.func.__doc__.strip().splitlines():\n+                    self.write_line(\"    %s\" % line.strip())\n \n     @pytest.hookimpl(hookwrapper=True)\n     def pytest_sessionfinish(self, exitstatus):\n", "occurrence": 1, "normalized_patch": "diff --git a/src/_pytest/terminal.py b/src/_pytest/terminal.py\nindex 17fce8c..578bf26 100644\n--- a/src/_pytest/terminal.py\n+++ b/src/_pytest/terminal.py\n@@ -396,37 +396,20 @@ class TerminalReporter(object):\n                 self._tw.sep('!', 'collection failures')\n                 for rep in self.stats.get('failed'):\n                     rep.toterminal(self._tw)\n-    def _printcollecteditems(self, items):\n-        if self.config.option.verbose < 0:\n-            if self.config.option.verbose < -1:\n-                counts = {}\n-                for item in items:\n-                    name = item.nodeid.split('::', 1)[0]\n-                    counts[name] = counts.get(name, 0) + 1\n-                for name, count in sorted(counts.items()):\n-                    self._tw.line('%s: %d' % (name, count))\n-            else:\n-                for item in items:\n-                    self._tw.line(item.nodeid)\n-            return\n-        stack = []\n-        indent = ''\n-        for item in items:\n-            needed_collectors = item.listchain()[1:]\n-            while stack:\n-                if stack == needed_collectors[:len(stack)]:\n-                    break\n-                stack.pop()\n-            for col in needed_collectors[len(stack):]:\n-                stack.append(col)\n-                if col.name == '()':\n-                    continue\n-                indent = (len(stack) - 1) * '  '\n-                self._tw.line('%s%s' % (indent, col))\n-                if self.config.option.verbose >= 1:\n-                    if hasattr(col, '_obj') and col._obj.__doc__:\n-                        for line in col._obj.__doc__.strip().splitlines():\n-                            self._tw.line('%s%s' % (indent + '  ', line.strip()))\n+    def _printfixtures(self, fixturemanager):\n+        from _pytest.fixtures import scopes\n+        fm = fixturemanager\n+        available = []\n+        for argname, fixturedefs in sorted(fm._arg2fixturedefs.items()):\n+            fixturedef = fixturedefs[-1]\n+            loc = getlocation(fixturedef.func, config=self.config)\n+            scope = scopes[fixturedef.scope]\n+            available.append((argname, fixturedef, loc, scope))\n+        for argname, fixturedef, loc, scope in available:\n+            self.write_line('fixture %s -- %s -- scope: %s' % (argname, loc, scope))\n+            if fixturedef.func.__doc__:\n+                for line in fixturedef.func.__doc__.strip().splitlines():\n+                    self.write_line('    %s' % line.strip())\n     @pytest.hookimpl(hookwrapper=True)\n     def pytest_sessionfinish(self, exitstatus):\n         outcome = (yield)\n", "normalized_occurrence": 1}
