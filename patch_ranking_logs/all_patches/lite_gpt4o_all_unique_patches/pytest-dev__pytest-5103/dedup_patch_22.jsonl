{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-5103", "model_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 4810cdd..8c65391 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -814,6 +814,23 @@ class AssertionRewriter(ast.NodeVisitor):\n     def visit_Assert(self, assert_):\n         \"\"\"Return the AST statements to replace the ast.Assert instance.\n \n+        This rewrites the test of an assertion to provide\n+        intermediate values and replace it with an if statement which\n+        raises an assertion error with a detailed explanation in case\n+        the expression is false.\n+        \n+        This method has been extended to specifically handle `all` and `any` calls\n+        to give more meaningful error messages.\n+        \"\"\"\n+        def is_all_or_any_call(node):\n+            \"\"\"Check if the node represents an `all` or `any` call.\"\"\"\n+            return (\n+                isinstance(node, ast.Call) and \n+                isinstance(node.func, ast.Name) and \n+                node.func.id in ('all', 'any')\n+            )\n+        \"\"\"Return the AST statements to replace the ast.Assert instance.\n+\n         This rewrites the test of an assertion to provide\n         intermediate values and replace it with an if statement which\n         raises an assertion error with a detailed explanation in case\n@@ -841,7 +858,44 @@ class AssertionRewriter(ast.NodeVisitor):\n         self.push_format_context()\n         # Rewrite assert into a bunch of statements.\n         top_condition, explanation = self.visit(assert_.test)\n-        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n+        if is_all_or_any_call(assert_.test):\n+            function_name = assert_.test.func.id\n+            negation = ast.UnaryOp(ast.Not(), top_condition)\n+            iterable = assert_.test.args[0]\n+            if isinstance(iterable, ast.GeneratorExp):\n+                iterable = ast.List(elts=[iterable], ctx=ast.Load())\n+            \n+            loop_var = ast.Name(id='@py_iter_var', ctx=ast.Store())\n+            loop_assign = ast.Assign(targets=[loop_var], value=ast.Name(id='None', ctx=ast.Load()))\n+            loop_body = [\n+                loop_assign,\n+                ast.For(target=loop_var, iter=iterable, body=[\n+                    ast.If(\n+                        test=ast.UnaryOp(ast.Not(), ast.Call(\n+                            func=assert_.test.args[0].elt, \n+                            args=[loop_var], \n+                            keywords=[]\n+                        )),\n+                        body=[ast.Raise(\n+                            exc=ast.Call(\n+                                func=ast.Name(id='AssertionError', ctx=ast.Load()),\n+                                args=[\n+                                    ast.BinOp(\n+                                        left=ast.Str(s=f'assert {function_name}({loop_var.id})'),\n+                                        op=ast.Add(),\n+                                        right=ast.Str(s=' failed.')\n+                                    )\n+                                ],\n+                                keywords=[]\n+                            ),\n+                            cause=None\n+                        )],\n+                        orelse=[]\n+                    )\n+                ], orelse=[])\n+            ]\n+            self.statements.extend(loop_body)\n+            return self.statements\n         if self.module_path is not None:\n             self.statements.append(\n                 self.warn_about_none_ast(\n@@ -1081,4 +1135,4 @@ warn_explicit(\n             res = ast.BoolOp(ast.And(), load_names)\n         else:\n             res = load_names[0]\n-        return res, self.explanation_param(self.pop_format_context(expl_call))\n+        return res, self.explanation_param(self.pop_format_context(expl_call))\n", "occurrence": 1, "normalized_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2ada5b2..188a1cb 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -448,6 +448,9 @@ class AssertionRewriter(ast.NodeVisitor):\n         res = self.assign(node)\n         return (res, self.explanation_param(self.display(res)))\n     def visit_Assert(self, assert_):\n+        def is_all_or_any_call(node):\n+            return isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and (node.func.id in ('all', 'any'))\n+        'Return the AST statements to replace the ast.Assert instance.\\n\\n        This rewrites the test of an assertion to provide\\n        intermediate values and replace it with an if statement which\\n        raises an assertion error with a detailed explanation in case\\n        the expression is false.\\n\\n        '\n         if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n             from _pytest.warning_types import PytestAssertRewriteWarning\n             import warnings\n@@ -459,6 +462,17 @@ class AssertionRewriter(ast.NodeVisitor):\n         self.on_failure = []\n         self.push_format_context()\n         top_condition, explanation = self.visit(assert_.test)\n+        if is_all_or_any_call(assert_.test):\n+            function_name = assert_.test.func.id\n+            negation = ast.UnaryOp(ast.Not(), top_condition)\n+            iterable = assert_.test.args[0]\n+            if isinstance(iterable, ast.GeneratorExp):\n+                iterable = ast.List(elts=[iterable], ctx=ast.Load())\n+            loop_var = ast.Name(id='@py_iter_var', ctx=ast.Store())\n+            loop_assign = ast.Assign(targets=[loop_var], value=ast.Name(id='None', ctx=ast.Load()))\n+            loop_body = [loop_assign, ast.For(target=loop_var, iter=iterable, body=[ast.If(test=ast.UnaryOp(ast.Not(), ast.Call(func=assert_.test.args[0].elt, args=[loop_var], keywords=[])), body=[ast.Raise(exc=ast.Call(func=ast.Name(id='AssertionError', ctx=ast.Load()), args=[ast.BinOp(left=ast.Str(s=f'assert {function_name}({loop_var.id})'), op=ast.Add(), right=ast.Str(s=' failed.'))], keywords=[]), cause=None)], orelse=[])], orelse=[])]\n+            self.statements.extend(loop_body)\n+            return self.statements\n         if self.module_path is not None:\n             self.statements.append(self.warn_about_none_ast(top_condition, module_path=self.module_path, lineno=assert_.lineno))\n         body = self.on_failure\n", "normalized_occurrence": 1}
