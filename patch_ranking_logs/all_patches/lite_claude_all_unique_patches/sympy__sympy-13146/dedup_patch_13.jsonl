{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13146", "model_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex e24efd1..8af0f2b 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -678,20 +678,19 @@ def evalf_pow(v, prec, options):\n         # Assumes full accuracy in input\n         return finalize_complex(re, im, target_prec)\n \n-    # Pure square root\n-    if exp is S.Half:\n+    # Handle rational exponents\n+    if exp.is_Rational:\n         xre, xim, _, _ = evalf(base, prec + 5, options)\n-        # General complex square root\n+        yre = float(exp)  # Convert rational to float for consistent handling\n         if xim:\n-            re, im = libmp.mpc_sqrt((xre or fzero, xim), prec)\n-            return finalize_complex(re, im, prec)\n+            re, im = libmp.mpc_pow((xre or fzero, xim), (from_float(yre), None), target_prec)\n+            return finalize_complex(re, im, target_prec)\n         if not xre:\n             return None, None, None, None\n-        # Square root of a negative real number\n         if mpf_lt(xre, fzero):\n-            return None, mpf_sqrt(mpf_neg(xre), prec), None, prec\n-        # Positive square root\n-        return mpf_sqrt(xre, prec), None, prec, None\n+            re, im = libmp.mpc_pow((xre, fzero), (from_float(yre), None), target_prec)\n+            return finalize_complex(re, im, target_prec)\n+        return mpf_pow(xre, from_float(yre), target_prec), None, target_prec, None\n \n     # We first evaluate the exponent to find its magnitude\n     # This determines the working precision that must be used\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex 54c5b3f..3057bc1 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -380,16 +380,18 @@ def evalf_pow(v, prec, options):\n             return (None, None, None, None)\n         re, im = libmp.mpc_pow_int((re, im), p, prec)\n         return finalize_complex(re, im, target_prec)\n-    if exp is S.Half:\n+    if exp.is_Rational:\n         xre, xim, _, _ = evalf(base, prec + 5, options)\n+        yre = float(exp)\n         if xim:\n-            re, im = libmp.mpc_sqrt((xre or fzero, xim), prec)\n-            return finalize_complex(re, im, prec)\n+            re, im = libmp.mpc_pow((xre or fzero, xim), (from_float(yre), None), target_prec)\n+            return finalize_complex(re, im, target_prec)\n         if not xre:\n             return (None, None, None, None)\n         if mpf_lt(xre, fzero):\n-            return (None, mpf_sqrt(mpf_neg(xre), prec), None, prec)\n-        return (mpf_sqrt(xre, prec), None, prec, None)\n+            re, im = libmp.mpc_pow((xre, fzero), (from_float(yre), None), target_prec)\n+            return finalize_complex(re, im, target_prec)\n+        return (mpf_pow(xre, from_float(yre), target_prec), None, target_prec, None)\n     prec += 10\n     yre, yim, _, _ = evalf(exp, prec, options)\n     if not (yre or yim):\n", "normalized_occurrence": 1}
