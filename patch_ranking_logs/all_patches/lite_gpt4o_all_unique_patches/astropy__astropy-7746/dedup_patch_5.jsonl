{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-7746", "model_patch": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex 369cdd2..27567ca 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1212,13 +1212,16 @@ reduce these to 2 dimensions using the naxis kwarg.\n         \"\"\"\n \n         def _return_list_of_arrays(axes, origin):\n-            try:\n-                axes = np.broadcast_arrays(*axes)\n-            except ValueError:\n-                raise ValueError(\n-                    \"Coordinate arrays are not broadcastable to each other\")\n+            if any(len(x) == 0 for x in axes):\n+                return [np.array([]) for _ in range(self.naxis)]\n+            else:\n+                try:\n+                    axes = np.broadcast_arrays(*axes)\n+                except ValueError:\n+                    raise ValueError(\n+                        \"Coordinate arrays are not broadcastable to each other\")\n \n-            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+                xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n                 xy = self._denormalize_sky(xy)\n@@ -1231,16 +1234,19 @@ reduce these to 2 dimensions using the naxis kwarg.\n                     for i in range(output.shape[1])]\n \n         def _return_single_array(xy, origin):\n-            if xy.shape[-1] != self.naxis:\n-                raise ValueError(\n-                    \"When providing two arguments, the array must be \"\n-                    \"of shape (N, {0})\".format(self.naxis))\n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            result = func(xy, origin)\n-            if ra_dec_order and sky == 'output':\n-                result = self._normalize_sky(result)\n-            return result\n+            if xy.size == 0:\n+                return np.array([]).reshape((0, self.naxis))\n+            else:\n+                if xy.shape[-1] != self.naxis:\n+                    raise ValueError(\n+                        \"When providing two arguments, the array must be \"\n+                        \"of shape (N, {0})\".format(self.naxis))\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                result = func(xy, origin)\n+                if ra_dec_order and sky == 'output':\n+                    result = self._normalize_sky(result)\n+                return result\n \n         if len(args) == 2:\n             try:\n", "occurrence": 2, "normalized_patch": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex 3d9c35a..5d966bb 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -594,11 +594,14 @@ class WCS(WCSBase):\n             return out\n     def _array_converter(self, func, sky, *args, ra_dec_order=False):\n         def _return_list_of_arrays(axes, origin):\n-            try:\n-                axes = np.broadcast_arrays(*axes)\n-            except ValueError:\n-                raise ValueError('Coordinate arrays are not broadcastable to each other')\n-            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+            if any((len(x) == 0 for x in axes)):\n+                return [np.array([]) for _ in range(self.naxis)]\n+            else:\n+                try:\n+                    axes = np.broadcast_arrays(*axes)\n+                except ValueError:\n+                    raise ValueError('Coordinate arrays are not broadcastable to each other')\n+                xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n             if ra_dec_order and sky == 'input':\n                 xy = self._denormalize_sky(xy)\n             output = func(xy, origin)\n@@ -607,14 +610,17 @@ class WCS(WCSBase):\n                 return (output[:, 0].reshape(axes[0].shape), output[:, 1].reshape(axes[0].shape))\n             return [output[:, i].reshape(axes[0].shape) for i in range(output.shape[1])]\n         def _return_single_array(xy, origin):\n-            if xy.shape[-1] != self.naxis:\n-                raise ValueError('When providing two arguments, the array must be of shape (N, {0})'.format(self.naxis))\n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            result = func(xy, origin)\n-            if ra_dec_order and sky == 'output':\n-                result = self._normalize_sky(result)\n-            return result\n+            if xy.size == 0:\n+                return np.array([]).reshape((0, self.naxis))\n+            else:\n+                if xy.shape[-1] != self.naxis:\n+                    raise ValueError('When providing two arguments, the array must be of shape (N, {0})'.format(self.naxis))\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                result = func(xy, origin)\n+                if ra_dec_order and sky == 'output':\n+                    result = self._normalize_sky(result)\n+                return result\n         if len(args) == 2:\n             try:\n                 xy, origin = args\n", "normalized_occurrence": 2}
