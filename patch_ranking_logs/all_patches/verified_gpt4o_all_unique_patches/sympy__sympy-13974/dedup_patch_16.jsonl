{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13974", "model_patch": "diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py\nindex 153c783..992befc 100644\n--- a/sympy/physics/quantum/tensorproduct.py\n+++ b/sympy/physics/quantum/tensorproduct.py\n@@ -240,9 +240,28 @@ class TensorProduct(Expr):\n \n     def _eval_expand_tensorproduct(self, **hints):\n         \"\"\"Distribute TensorProducts across addition.\"\"\"\n+        from sympy import Pow\n+\n+        def expand_power(base, exp):\n+            if isinstance(base, TensorProduct) and isinstance(exp, int) and exp > 1:\n+                expanded = base\n+                for _ in range(exp - 1):\n+                    expanded = expanded * base\n+                return expanded\n+            return Pow(base, exp)\n+\n+        new_args = []\n+        for arg in self.args:\n+            if isinstance(arg, Pow):\n+                new_args.append(expand_power(arg.base, arg.exp))\n+            else:\n+                new_args.append(arg)\n+\n+        self.args = tuple(new_args)\n         args = self.args\n+        \n+        # Existing code for handling Add within TensorProduct\n         add_args = []\n-        stop = False\n         for i in range(len(args)):\n             if isinstance(args[i], Add):\n                 for aa in args[i].args:\n@@ -251,11 +270,11 @@ class TensorProduct(Expr):\n                         tp = tp._eval_expand_tensorproduct()\n                     add_args.append(tp)\n                 break\n-\n+                \n         if add_args:\n             return Add(*add_args)\n         else:\n-            return self\n+            return TensorProduct(*[arg._eval_expand_tensorproduct() if isinstance(arg, TensorProduct) else arg for arg in args])\n \n     def _eval_trace(self, **kwargs):\n         indices = kwargs.get('indices', None)\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py\nindex e23a275..37b0a70 100644\n--- a/sympy/physics/quantum/tensorproduct.py\n+++ b/sympy/physics/quantum/tensorproduct.py\n@@ -109,9 +109,23 @@ class TensorProduct(Expr):\n     def doit(self, **hints):\n         return TensorProduct(*[item.doit(**hints) for item in self.args])\n     def _eval_expand_tensorproduct(self, **hints):\n+        from sympy import Pow\n+        def expand_power(base, exp):\n+            if isinstance(base, TensorProduct) and isinstance(exp, int) and (exp > 1):\n+                expanded = base\n+                for _ in range(exp - 1):\n+                    expanded = expanded * base\n+                return expanded\n+            return Pow(base, exp)\n+        new_args = []\n+        for arg in self.args:\n+            if isinstance(arg, Pow):\n+                new_args.append(expand_power(arg.base, arg.exp))\n+            else:\n+                new_args.append(arg)\n+        self.args = tuple(new_args)\n         args = self.args\n         add_args = []\n-        stop = False\n         for i in range(len(args)):\n             if isinstance(args[i], Add):\n                 for aa in args[i].args:\n@@ -123,7 +137,7 @@ class TensorProduct(Expr):\n         if add_args:\n             return Add(*add_args)\n         else:\n-            return self\n+            return TensorProduct(*[arg._eval_expand_tensorproduct() if isinstance(arg, TensorProduct) else arg for arg in args])\n     def _eval_trace(self, **kwargs):\n         indices = kwargs.get('indices', None)\n         exp = tensor_product_simp(self)\n", "normalized_occurrence": 1}
