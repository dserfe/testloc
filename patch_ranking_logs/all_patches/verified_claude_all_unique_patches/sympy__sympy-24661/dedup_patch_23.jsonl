{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-24661", "model_patch": "diff --git a/sympy/parsing/sympy_parser.py b/sympy/parsing/sympy_parser.py\nindex 2ec3cf6..89249c1 100644\n--- a/sympy/parsing/sympy_parser.py\n+++ b/sympy/parsing/sympy_parser.py\n@@ -1091,8 +1091,33 @@ def evaluateFalse(s: str):\n     \"\"\"\n     Replaces operators with the SymPy equivalent and sets evaluate=False.\n     \"\"\"\n-    node = ast.parse(s)\n-    transformed_node = EvaluateFalseTransformer().visit(node)\n+    # Special handling for relational operations\n+    if any(op in s for op in ['<', '>', '<=', '>=', '==', '!=']):\n+        # Parse into a Module node\n+        node = ast.parse(s)\n+        # Transform the node\n+        transformed_node = EvaluateFalseTransformer().visit(node)\n+        # Add evaluate=False parameter for relational operations\n+        if isinstance(transformed_node.body[0].value, ast.Compare):\n+            comp = transformed_node.body[0].value\n+            func_name = {\n+                ast.Lt: 'Lt',\n+                ast.Gt: 'Gt',\n+                ast.LtE: 'Le',\n+                ast.GtE: 'Ge',\n+                ast.Eq: 'Eq',\n+                ast.NotEq: 'Ne'\n+            }[type(comp.ops[0])]\n+            # Create a new call node with evaluate=False\n+            new_node = ast.Call(\n+                func=ast.Name(id=func_name, ctx=ast.Load()),\n+                args=[comp.left, comp.comparators[0]],\n+                keywords=[ast.keyword(arg='evaluate', value=ast.Constant(value=False))]\n+            )\n+            transformed_node.body[0].value = new_node\n+    else:\n+        node = ast.parse(s)\n+        transformed_node = EvaluateFalseTransformer().visit(node)\n     # node is a Module, we want an Expression\n     transformed_node = ast.Expression(transformed_node.body[0].value)\n \n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/parsing/sympy_parser.py b/sympy/parsing/sympy_parser.py\nindex 0c06cf1..1a4e080 100644\n--- a/sympy/parsing/sympy_parser.py\n+++ b/sympy/parsing/sympy_parser.py\n@@ -522,8 +522,17 @@ def parse_expr(s: str, local_dict: Optional[DICT]=None, transformations: tUnion[\n             local_dict[i] = null\n         raise e from ValueError(f'Error from parse_expr with transformed code: {code!r}')\n def evaluateFalse(s: str):\n-    node = ast.parse(s)\n-    transformed_node = EvaluateFalseTransformer().visit(node)\n+    if any((op in s for op in ['<', '>', '<=', '>=', '==', '!='])):\n+        node = ast.parse(s)\n+        transformed_node = EvaluateFalseTransformer().visit(node)\n+        if isinstance(transformed_node.body[0].value, ast.Compare):\n+            comp = transformed_node.body[0].value\n+            func_name = {ast.Lt: 'Lt', ast.Gt: 'Gt', ast.LtE: 'Le', ast.GtE: 'Ge', ast.Eq: 'Eq', ast.NotEq: 'Ne'}[type(comp.ops[0])]\n+            new_node = ast.Call(func=ast.Name(id=func_name, ctx=ast.Load()), args=[comp.left, comp.comparators[0]], keywords=[ast.keyword(arg='evaluate', value=ast.Constant(value=False))])\n+            transformed_node.body[0].value = new_node\n+    else:\n+        node = ast.parse(s)\n+        transformed_node = EvaluateFalseTransformer().visit(node)\n     transformed_node = ast.Expression(transformed_node.body[0].value)\n     return ast.fix_missing_locations(transformed_node)\n class EvaluateFalseTransformer(ast.NodeTransformer):\n", "normalized_occurrence": 1}
