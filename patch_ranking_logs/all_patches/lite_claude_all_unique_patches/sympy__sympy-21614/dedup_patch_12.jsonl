{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-21614", "model_patch": "diff --git a/sympy/matrices/expressions/matexpr.py b/sympy/matrices/expressions/matexpr.py\nindex 67e1797..1a2f887 100644\n--- a/sympy/matrices/expressions/matexpr.py\n+++ b/sympy/matrices/expressions/matexpr.py\n@@ -214,8 +214,14 @@ class MatrixExpr(Expr):\n         return Basic._eval_derivative_n_times(self, x, n)\n \n     def _eval_derivative(self, x):\n+        from sympy.matrices.expressions.special import ZeroMatrix\n         # `x` is a scalar:\n         if self.has(x):\n+            # Maintain matrix kind in derivative\n+            if hasattr(self, 'kind'):\n+                # Create new derivative while preserving the kind\n+                from sympy import Derivative\n+                return Derivative(self, x, evaluate=False)\n             # See if there are other methods using it:\n             return super()._eval_derivative(x)\n         else:\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/matrices/expressions/matexpr.py b/sympy/matrices/expressions/matexpr.py\nindex 675bb56..7980a63 100644\n--- a/sympy/matrices/expressions/matexpr.py\n+++ b/sympy/matrices/expressions/matexpr.py\n@@ -141,7 +141,11 @@ class MatrixExpr(Expr):\n     def _eval_derivative_n_times(self, x, n):\n         return Basic._eval_derivative_n_times(self, x, n)\n     def _eval_derivative(self, x):\n+        from sympy.matrices.expressions.special import ZeroMatrix\n         if self.has(x):\n+            if hasattr(self, 'kind'):\n+                from sympy import Derivative\n+                return Derivative(self, x, evaluate=False)\n             return super()._eval_derivative(x)\n         else:\n             return ZeroMatrix(*self.shape)\n", "normalized_occurrence": 1}
