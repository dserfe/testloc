{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23314", "model_patch": "diff --git a/lib/mpl_toolkits/mplot3d/axes3d.py b/lib/mpl_toolkits/mplot3d/axes3d.py\nindex 392f89b..abad87f 100644\n--- a/lib/mpl_toolkits/mplot3d/axes3d.py\n+++ b/lib/mpl_toolkits/mplot3d/axes3d.py\n@@ -387,61 +387,62 @@ class Axes3D(Axes):\n \n     @martist.allow_rasterization\n     def draw(self, renderer):\n-        self._unstale_viewLim()\n-\n-        # draw the background patch\n-        self.patch.draw(renderer)\n-        self._frameon = False\n-\n-        # first, set the aspect\n-        # this is duplicated from `axes._base._AxesBase.draw`\n-        # but must be called before any of the artist are drawn as\n-        # it adjusts the view limits and the size of the bounding box\n-        # of the Axes\n-        locator = self.get_axes_locator()\n-        if locator:\n-            pos = locator(self, renderer)\n-            self.apply_aspect(pos)\n-        else:\n-            self.apply_aspect()\n-\n-        # add the projection matrix to the renderer\n-        self.M = self.get_proj()\n-\n-        collections_and_patches = (\n-            artist for artist in self._children\n-            if isinstance(artist, (mcoll.Collection, mpatches.Patch))\n-            and artist.get_visible())\n-        if self.computed_zorder:\n-            # Calculate projection of collections and patches and zorder\n-            # them. Make sure they are drawn above the grids.\n-            zorder_offset = max(axis.get_zorder()\n-                                for axis in self._axis_map.values()) + 1\n-            collection_zorder = patch_zorder = zorder_offset\n-\n-            for artist in sorted(collections_and_patches,\n-                                 key=lambda artist: artist.do_3d_projection(),\n-                                 reverse=True):\n-                if isinstance(artist, mcoll.Collection):\n-                    artist.zorder = collection_zorder\n-                    collection_zorder += 1\n-                elif isinstance(artist, mpatches.Patch):\n-                    artist.zorder = patch_zorder\n-                    patch_zorder += 1\n-        else:\n-            for artist in collections_and_patches:\n-                artist.do_3d_projection()\n-\n-        if self._axis3don:\n-            # Draw panes first\n-            for axis in self._axis_map.values():\n-                axis.draw_pane(renderer)\n-            # Then axes\n-            for axis in self._axis_map.values():\n-                axis.draw(renderer)\n-\n-        # Then rest\n-        super().draw(renderer)\n+        if self.get_visible():\n+            self._unstale_viewLim()\n+\n+            # draw the background patch\n+            self.patch.draw(renderer)\n+            self._frameon = False\n+\n+            # first, set the aspect\n+            # this is duplicated from `axes._base._AxesBase.draw`\n+            # but must be called before any of the artist are drawn as\n+            # it adjusts the view limits and the size of the bounding box\n+            # of the Axes\n+            locator = self.get_axes_locator()\n+            if (locator):\n+                pos = locator(self, renderer)\n+                self.apply_aspect(pos)\n+            else:\n+                self.apply_aspect()\n+\n+            # add the projection matrix to the renderer\n+            self.M = self.get_proj()\n+\n+            collections_and_patches = (\n+                artist for artist in self._children\n+                if isinstance(artist, (mcoll.Collection, mpatches.Patch))\n+                and artist.get_visible())\n+            if self.computed_zorder:\n+                # Calculate projection of collections and patches and zorder\n+                # them. Make sure they are drawn above the grids.\n+                zorder_offset = max(axis.get_zorder()\n+                                    for axis in self._axis_map.values()) + 1\n+                collection_zorder = patch_zorder = zorder_offset\n+\n+                for artist in sorted(collections_and_patches,\n+                                     key=lambda artist: artist.do_3d_projection(),\n+                                     reverse=True):\n+                    if isinstance(artist, mcoll.Collection):\n+                        artist.zorder = collection_zorder\n+                        collection_zorder += 1\n+                    elif isinstance(artist, mpatches.Patch):\n+                        artist.zorder = patch_zorder\n+                        patch_zorder += 1\n+            else:\n+                for artist in collections_and_patches:\n+                    artist.do_3d_projection()\n+\n+            if self._axis3don:\n+                # Draw panes first\n+                for axis in self._axis_map.values():\n+                    axis.draw_pane(renderer)\n+                # Then axes\n+                for axis in self._axis_map.values():\n+                    axis.draw(renderer)\n+\n+            # Then rest\n+            super().draw(renderer)\n \n     def get_axis_position(self):\n         vals = self.get_w_lims()\n", "occurrence": 1, "normalized_patch": "diff --git a/lib/mpl_toolkits/mplot3d/axes3d.py b/lib/mpl_toolkits/mplot3d/axes3d.py\nindex 626fa6e..619cccb 100644\n--- a/lib/mpl_toolkits/mplot3d/axes3d.py\n+++ b/lib/mpl_toolkits/mplot3d/axes3d.py\n@@ -300,36 +300,37 @@ class Axes3D(Axes):\n \n     @martist.allow_rasterization\n     def draw(self, renderer):\n-        self._unstale_viewLim()\n-        self.patch.draw(renderer)\n-        self._frameon = False\n-        locator = self.get_axes_locator()\n-        if locator:\n-            pos = locator(self, renderer)\n-            self.apply_aspect(pos)\n-        else:\n-            self.apply_aspect()\n-        self.M = self.get_proj()\n-        collections_and_patches = (artist for artist in self._children if isinstance(artist, (mcoll.Collection, mpatches.Patch)) and artist.get_visible())\n-        if self.computed_zorder:\n-            zorder_offset = max((axis.get_zorder() for axis in self._axis_map.values())) + 1\n-            collection_zorder = patch_zorder = zorder_offset\n-            for artist in sorted(collections_and_patches, key=lambda artist: artist.do_3d_projection(), reverse=True):\n-                if isinstance(artist, mcoll.Collection):\n-                    artist.zorder = collection_zorder\n-                    collection_zorder += 1\n-                elif isinstance(artist, mpatches.Patch):\n-                    artist.zorder = patch_zorder\n-                    patch_zorder += 1\n-        else:\n-            for artist in collections_and_patches:\n-                artist.do_3d_projection()\n-        if self._axis3don:\n-            for axis in self._axis_map.values():\n-                axis.draw_pane(renderer)\n-            for axis in self._axis_map.values():\n-                axis.draw(renderer)\n-        super().draw(renderer)\n+        if self.get_visible():\n+            self._unstale_viewLim()\n+            self.patch.draw(renderer)\n+            self._frameon = False\n+            locator = self.get_axes_locator()\n+            if locator:\n+                pos = locator(self, renderer)\n+                self.apply_aspect(pos)\n+            else:\n+                self.apply_aspect()\n+            self.M = self.get_proj()\n+            collections_and_patches = (artist for artist in self._children if isinstance(artist, (mcoll.Collection, mpatches.Patch)) and artist.get_visible())\n+            if self.computed_zorder:\n+                zorder_offset = max((axis.get_zorder() for axis in self._axis_map.values())) + 1\n+                collection_zorder = patch_zorder = zorder_offset\n+                for artist in sorted(collections_and_patches, key=lambda artist: artist.do_3d_projection(), reverse=True):\n+                    if isinstance(artist, mcoll.Collection):\n+                        artist.zorder = collection_zorder\n+                        collection_zorder += 1\n+                    elif isinstance(artist, mpatches.Patch):\n+                        artist.zorder = patch_zorder\n+                        patch_zorder += 1\n+            else:\n+                for artist in collections_and_patches:\n+                    artist.do_3d_projection()\n+            if self._axis3don:\n+                for axis in self._axis_map.values():\n+                    axis.draw_pane(renderer)\n+                for axis in self._axis_map.values():\n+                    axis.draw(renderer)\n+            super().draw(renderer)\n \n     def get_axis_position(self):\n         vals = self.get_w_lims()\n", "normalized_occurrence": 1}
