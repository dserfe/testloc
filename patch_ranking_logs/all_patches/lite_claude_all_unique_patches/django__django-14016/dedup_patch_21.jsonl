{"model_name_or_path": "agentless_claude", "instance_id": "django__django-14016", "model_patch": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex ce7aa22..b9029b6 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -19,6 +19,11 @@ from django.utils import tree\n # sides of the relation. The join_field is the field backing the relation.\n PathInfo = namedtuple('PathInfo', 'from_opts to_opts target_fields join_field m2m direct filtered_relation')\n \n+# Dict view types for type checking\n+dict_keys = type({}.keys())\n+dict_values = type({}.values())\n+dict_items = type({}.items())\n+\n \n def subclasses(cls):\n     yield cls\n@@ -44,17 +49,37 @@ class Q(tree.Node):\n         if not isinstance(other, Q):\n             raise TypeError(other)\n \n+        def make_pickleable(node):\n+            \"\"\"Convert non-pickleable objects in the node to pickleable ones.\"\"\"\n+            if not node:\n+                return node\n+            obj = type(node)()\n+            obj.connector = node.connector\n+            obj.negated = node.negated\n+            children = []\n+            for child in node.children:\n+                if isinstance(child, tuple) and len(child) == 2:\n+                    # Handle dict_keys and similar iterables\n+                    key, value = child\n+                    if isinstance(value, (dict_keys, dict_values, dict_items)):\n+                        value = list(value)\n+                    children.append((key, value))\n+                else:\n+                    children.append(make_pickleable(child))\n+            obj.children = children\n+            return obj\n+\n         # If the other Q() is empty, ignore it and just use `self`.\n         if not other:\n-            return copy.deepcopy(self)\n+            return make_pickleable(self)\n         # Or if this Q is empty, ignore it and just use `other`.\n         elif not self:\n-            return copy.deepcopy(other)\n+            return make_pickleable(other)\n \n         obj = type(self)()\n         obj.connector = conn\n-        obj.add(self, conn)\n-        obj.add(other, conn)\n+        obj.add(make_pickleable(self), conn)\n+        obj.add(make_pickleable(other), conn)\n         return obj\n \n     def __or__(self, other):\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex d1b043f..3a7f52e 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -6,6 +6,9 @@ from django.core.exceptions import FieldError\n from django.db.models.constants import LOOKUP_SEP\n from django.utils import tree\n PathInfo = namedtuple('PathInfo', 'from_opts to_opts target_fields join_field m2m direct filtered_relation')\n+dict_keys = type({}.keys())\n+dict_values = type({}.values())\n+dict_items = type({}.items())\n def subclasses(cls):\n     yield cls\n     for subclass in cls.__subclasses__():\n@@ -20,14 +23,31 @@ class Q(tree.Node):\n     def _combine(self, other, conn):\n         if not isinstance(other, Q):\n             raise TypeError(other)\n+        def make_pickleable(node):\n+            if not node:\n+                return node\n+            obj = type(node)()\n+            obj.connector = node.connector\n+            obj.negated = node.negated\n+            children = []\n+            for child in node.children:\n+                if isinstance(child, tuple) and len(child) == 2:\n+                    key, value = child\n+                    if isinstance(value, (dict_keys, dict_values, dict_items)):\n+                        value = list(value)\n+                    children.append((key, value))\n+                else:\n+                    children.append(make_pickleable(child))\n+            obj.children = children\n+            return obj\n         if not other:\n-            return copy.deepcopy(self)\n+            return make_pickleable(self)\n         elif not self:\n-            return copy.deepcopy(other)\n+            return make_pickleable(other)\n         obj = type(self)()\n         obj.connector = conn\n-        obj.add(self, conn)\n-        obj.add(other, conn)\n+        obj.add(make_pickleable(self), conn)\n+        obj.add(make_pickleable(other), conn)\n         return obj\n     def __or__(self, other):\n         return self._combine(other, self.OR)\n", "normalized_occurrence": 1}
