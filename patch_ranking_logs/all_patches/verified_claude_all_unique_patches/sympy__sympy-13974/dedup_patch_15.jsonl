{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13974", "model_patch": "diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py\nindex 153c783..995161b 100644\n--- a/sympy/physics/quantum/tensorproduct.py\n+++ b/sympy/physics/quantum/tensorproduct.py\n@@ -268,6 +268,42 @@ class TensorProduct(Expr):\n                          for idx, value in enumerate(exp.args)])\n \n \n+def tensor_product_simp_Pow(e):\n+    \"\"\"Simplify a Pow with TensorProduct base.\n+\n+    This function handles expressions like (A⊗B)^n by converting them to (A^n)⊗(B^n).\n+\n+    Parameters\n+    ==========\n+\n+    e : Expr\n+        A ``Pow`` with ``TensorProduct`` base to be simplified.\n+\n+    Returns\n+    =======\n+\n+    e : Expr\n+        A ``TensorProduct`` with the power distributed to each component.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy.physics.quantum import TensorProduct\n+    >>> from sympy import Symbol\n+    >>> A = Symbol('A',commutative=False)\n+    >>> B = Symbol('B',commutative=False)\n+    >>> e = TensorProduct(A,B)**2\n+    >>> tensor_product_simp_Pow(e)\n+    (A**2)x(B**2)\n+    \"\"\"\n+    if not isinstance(e, Pow):\n+        return e\n+    if not isinstance(e.base, TensorProduct):\n+        return e\n+        \n+    # For (A⊗B)^n, return A^n ⊗ B^n\n+    return TensorProduct(*[arg**e.exp for arg in e.base.args])\n+\n def tensor_product_simp_Mul(e):\n     \"\"\"Simplify a Mul with TensorProducts.\n \n@@ -345,49 +381,4 @@ def tensor_product_simp_Mul(e):\n         return e\n \n \n-def tensor_product_simp(e, **hints):\n-    \"\"\"Try to simplify and combine TensorProducts.\n-\n-    In general this will try to pull expressions inside of ``TensorProducts``.\n-    It currently only works for relatively simple cases where the products have\n-    only scalars, raw ``TensorProducts``, not ``Add``, ``Pow``, ``Commutators``\n-    of ``TensorProducts``. It is best to see what it does by showing examples.\n \n-    Examples\n-    ========\n-\n-    >>> from sympy.physics.quantum import tensor_product_simp\n-    >>> from sympy.physics.quantum import TensorProduct\n-    >>> from sympy import Symbol\n-    >>> A = Symbol('A',commutative=False)\n-    >>> B = Symbol('B',commutative=False)\n-    >>> C = Symbol('C',commutative=False)\n-    >>> D = Symbol('D',commutative=False)\n-\n-    First see what happens to products of tensor products:\n-\n-    >>> e = TensorProduct(A,B)*TensorProduct(C,D)\n-    >>> e\n-    AxB*CxD\n-    >>> tensor_product_simp(e)\n-    (A*C)x(B*D)\n-\n-    This is the core logic of this function, and it works inside, powers, sums,\n-    commutators and anticommutators as well:\n-\n-    >>> tensor_product_simp(e**2)\n-    (A*C)x(B*D)**2\n-\n-    \"\"\"\n-    if isinstance(e, Add):\n-        return Add(*[tensor_product_simp(arg) for arg in e.args])\n-    elif isinstance(e, Pow):\n-        return tensor_product_simp(e.base) ** e.exp\n-    elif isinstance(e, Mul):\n-        return tensor_product_simp_Mul(e)\n-    elif isinstance(e, Commutator):\n-        return Commutator(*[tensor_product_simp(arg) for arg in e.args])\n-    elif isinstance(e, AntiCommutator):\n-        return AntiCommutator(*[tensor_product_simp(arg) for arg in e.args])\n-    else:\n-        return e\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py\nindex e23a275..6da21f9 100644\n--- a/sympy/physics/quantum/tensorproduct.py\n+++ b/sympy/physics/quantum/tensorproduct.py\n@@ -131,6 +131,12 @@ class TensorProduct(Expr):\n             return Mul(*[Tr(arg).doit() for arg in exp.args])\n         else:\n             return Mul(*[Tr(value).doit() if idx in indices else value for idx, value in enumerate(exp.args)])\n+def tensor_product_simp_Pow(e):\n+    if not isinstance(e, Pow):\n+        return e\n+    if not isinstance(e.base, TensorProduct):\n+        return e\n+    return TensorProduct(*[arg ** e.exp for arg in e.base.args])\n def tensor_product_simp_Mul(e):\n     if not isinstance(e, Mul):\n         return e\n@@ -155,18 +161,5 @@ def tensor_product_simp_Mul(e):\n                     new_args[i] = new_args[i] * next\n             current = next\n         return Mul(*c_part) * TensorProduct(*new_args)\n-    else:\n-        return e\n-def tensor_product_simp(e, **hints):\n-    if isinstance(e, Add):\n-        return Add(*[tensor_product_simp(arg) for arg in e.args])\n-    elif isinstance(e, Pow):\n-        return tensor_product_simp(e.base) ** e.exp\n-    elif isinstance(e, Mul):\n-        return tensor_product_simp_Mul(e)\n-    elif isinstance(e, Commutator):\n-        return Commutator(*[tensor_product_simp(arg) for arg in e.args])\n-    elif isinstance(e, AntiCommutator):\n-        return AntiCommutator(*[tensor_product_simp(arg) for arg in e.args])\n     else:\n         return e\n\\ No newline at end of file\n", "normalized_occurrence": 1}
