{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-22080", "model_patch": "diff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex ca33049..ef45bbe 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -138,6 +138,10 @@ class Mod(Function):\n                 both_l[isinstance(arg, cls)].append(arg)\n \n             if mod_l and all(inner.args[1] == q for inner in mod_l):\n+                # If there is exactly one Mod term and some non-Mod terms,\n+                # keep the multiplication outside\n+                if len(mod_l) == 1 and non_mod_l:\n+                    return Mul(*non_mod_l) * mod_l[0]\n                 # finding distributive term\n                 non_mod_l = [cls(x, q) for x in non_mod_l]\n                 mod = []\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex 57d2396..fe0890d 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -85,6 +85,8 @@ class Mod(Function):\n             for arg in p.args:\n                 both_l[isinstance(arg, cls)].append(arg)\n             if mod_l and all((inner.args[1] == q for inner in mod_l)):\n+                if len(mod_l) == 1 and non_mod_l:\n+                    return Mul(*non_mod_l) * mod_l[0]\n                 non_mod_l = [cls(x, q) for x in non_mod_l]\n                 mod = []\n                 non_mod = []\n", "normalized_occurrence": 1}
