{"model_name_or_path": "agentless_claude", "instance_id": "pydata__xarray-4094", "model_patch": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex d48a6e6..f2e96b8 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1898,73 +1898,7 @@ class DataArray(AbstractArray, DataWithCoords):\n         ds = self._to_temp_dataset().unstack(dim, fill_value, sparse)\n         return self._from_temp_dataset(ds)\n \n-    def to_unstacked_dataset(self, dim, level=0):\n-        \"\"\"Unstack DataArray expanding to Dataset along a given level of a\n-        stacked coordinate.\n \n-        This is the inverse operation of Dataset.to_stacked_array.\n-\n-        Parameters\n-        ----------\n-        dim : str\n-            Name of existing dimension to unstack\n-        level : int or str\n-            The MultiIndex level to expand to a dataset along. Can either be\n-            the integer index of the level or its name.\n-        label : int, default 0\n-            Label of the level to expand dataset along. Overrides the label\n-            argument if given.\n-\n-        Returns\n-        -------\n-        unstacked: Dataset\n-\n-        Examples\n-        --------\n-        >>> import xarray as xr\n-        >>> arr = xr.DataArray(\n-        ...     np.arange(6).reshape(2, 3),\n-        ...     coords=[(\"x\", [\"a\", \"b\"]), (\"y\", [0, 1, 2])],\n-        ... )\n-        >>> data = xr.Dataset({\"a\": arr, \"b\": arr.isel(y=0)})\n-        >>> data\n-        <xarray.Dataset>\n-        Dimensions:  (x: 2, y: 3)\n-        Coordinates:\n-          * x        (x) <U1 'a' 'b'\n-          * y        (y) int64 0 1 2\n-        Data variables:\n-            a        (x, y) int64 0 1 2 3 4 5\n-            b        (x) int64 0 3\n-        >>> stacked = data.to_stacked_array(\"z\", [\"y\"])\n-        >>> stacked.indexes[\"z\"]\n-        MultiIndex(levels=[['a', 'b'], [0, 1, 2]],\n-                labels=[[0, 0, 0, 1], [0, 1, 2, -1]],\n-                names=['variable', 'y'])\n-        >>> roundtripped = stacked.to_unstacked_dataset(dim=\"z\")\n-        >>> data.identical(roundtripped)\n-        True\n-\n-        See Also\n-        --------\n-        Dataset.to_stacked_array\n-        \"\"\"\n-\n-        idx = self.indexes[dim]\n-        if not isinstance(idx, pd.MultiIndex):\n-            raise ValueError(f\"'{dim}' is not a stacked coordinate\")\n-\n-        level_number = idx._get_level_number(level)\n-        variables = idx.levels[level_number]\n-        variable_dim = idx.names[level_number]\n-\n-        # pull variables out of datarray\n-        data_dict = {}\n-        for k in variables:\n-            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n-\n-        # unstacked dataset\n-        return Dataset(data_dict)\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\n", "occurrence": 1, "normalized_patch": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex 3d86f26..88422a7 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -525,17 +525,6 @@ class DataArray(AbstractArray, DataWithCoords):\n     def unstack(self, dim: Union[Hashable, Sequence[Hashable], None]=None, fill_value: Any=dtypes.NA, sparse: bool=False) -> 'DataArray':\n         ds = self._to_temp_dataset().unstack(dim, fill_value, sparse)\n         return self._from_temp_dataset(ds)\n-    def to_unstacked_dataset(self, dim, level=0):\n-        idx = self.indexes[dim]\n-        if not isinstance(idx, pd.MultiIndex):\n-            raise ValueError(f\"'{dim}' is not a stacked coordinate\")\n-        level_number = idx._get_level_number(level)\n-        variables = idx.levels[level_number]\n-        variable_dim = idx.names[level_number]\n-        data_dict = {}\n-        for k in variables:\n-            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n-        return Dataset(data_dict)\n     def transpose(self, *dims: Hashable, transpose_coords: bool=True) -> 'DataArray':\n         if dims:\n             dims = tuple(utils.infix_dims(dims, self.dims))\n", "normalized_occurrence": 1}
