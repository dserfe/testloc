{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-10949", "model_patch": "diff --git a/sklearn/utils/validation.py b/sklearn/utils/validation.py\nindex 7e2fa63..1edd193 100644\n--- a/sklearn/utils/validation.py\n+++ b/sklearn/utils/validation.py\n@@ -502,6 +502,11 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n                                       force_all_finite=force_all_finite,\n                                       accept_large_sparse=accept_large_sparse)\n     else:\n+        if warn_on_dtype and dtype_orig is not None and dtype_orig == object:\n+            msg = (\"Data with input dtype %s was converted to %s%s.\"\n+                   % (dtype_orig, np.float64, context))\n+            warnings.warn(msg, DataConversionWarning)\n+\n         # If np.array(..) gives ComplexWarning, then we convert the warning\n         # to an error. This is needed because specifying a non complex\n         # dtype to the function converts complex to real dtype,\n@@ -573,7 +578,7 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n                              % (n_features, shape_repr, ensure_min_features,\n                                 context))\n \n-    if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n+    if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig and dtype_orig != object:\n         msg = (\"Data with input dtype %s was converted to %s%s.\"\n                % (dtype_orig, array.dtype, context))\n         warnings.warn(msg, DataConversionWarning)\n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/utils/validation.py b/sklearn/utils/validation.py\nindex 7db8b51..201c8cd 100644\n--- a/sklearn/utils/validation.py\n+++ b/sklearn/utils/validation.py\n@@ -152,6 +152,9 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True, dtype='num\n         _ensure_no_complex_data(array)\n         array = _ensure_sparse_format(array, accept_sparse=accept_sparse, dtype=dtype, copy=copy, force_all_finite=force_all_finite, accept_large_sparse=accept_large_sparse)\n     else:\n+        if warn_on_dtype and dtype_orig is not None and (dtype_orig == object):\n+            msg = 'Data with input dtype %s was converted to %s%s.' % (dtype_orig, np.float64, context)\n+            warnings.warn(msg, DataConversionWarning)\n         with warnings.catch_warnings():\n             try:\n                 warnings.simplefilter('error', ComplexWarning)\n@@ -181,7 +184,7 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True, dtype='num\n         n_features = array.shape[1]\n         if n_features < ensure_min_features:\n             raise ValueError('Found array with %d feature(s) (shape=%s) while a minimum of %d is required%s.' % (n_features, shape_repr, ensure_min_features, context))\n-    if warn_on_dtype and dtype_orig is not None and (array.dtype != dtype_orig):\n+    if warn_on_dtype and dtype_orig is not None and (array.dtype != dtype_orig) and (dtype_orig != object):\n         msg = 'Data with input dtype %s was converted to %s%s.' % (dtype_orig, array.dtype, context)\n         warnings.warn(msg, DataConversionWarning)\n     if copy and np.may_share_memory(array, array_orig):\n", "normalized_occurrence": 1}
