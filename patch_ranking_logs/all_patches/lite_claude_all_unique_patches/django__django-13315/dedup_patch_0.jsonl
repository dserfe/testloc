{"model_name_or_path": "agentless_claude", "instance_id": "django__django-13315", "model_patch": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 4d90328..0bfb2fa 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -986,9 +986,18 @@ class ForeignKey(ForeignObject):\n             raise ValueError(\"Cannot create form field for %r yet, because \"\n                              \"its related model %r has not been loaded yet\" %\n                              (self.name, self.remote_field.model))\n+        \n+        # Get base queryset\n+        qs = self.remote_field.model._default_manager.using(using)\n+        \n+        # If limit_choices_to is defined, ensure distinct results when joins might be involved\n+        limit_choices = self.get_limit_choices_to()\n+        if limit_choices is not None:\n+            qs = qs.filter(limit_choices).distinct()\n+            \n         return super().formfield(**{\n             'form_class': forms.ModelChoiceField,\n-            'queryset': self.remote_field.model._default_manager.using(using),\n+            'queryset': qs,\n             'to_field_name': self.remote_field.field_name,\n             **kwargs,\n             'blank': self.blank,\n", "normalized_patch": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 119c3cb..bd497c9 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -439,7 +439,11 @@ class ForeignKey(ForeignObject):\n     def formfield(self, *, using=None, **kwargs):\n         if isinstance(self.remote_field.model, str):\n             raise ValueError('Cannot create form field for %r yet, because its related model %r has not been loaded yet' % (self.name, self.remote_field.model))\n-        return super().formfield(**{'form_class': forms.ModelChoiceField, 'queryset': self.remote_field.model._default_manager.using(using), 'to_field_name': self.remote_field.field_name, **kwargs, 'blank': self.blank})\n+        qs = self.remote_field.model._default_manager.using(using)\n+        limit_choices = self.get_limit_choices_to()\n+        if limit_choices is not None:\n+            qs = qs.filter(limit_choices).distinct()\n+        return super().formfield(**{'form_class': forms.ModelChoiceField, 'queryset': qs, 'to_field_name': self.remote_field.field_name, **kwargs, 'blank': self.blank})\n     def db_check(self, connection):\n         return []\n     def db_type(self, connection):\n", "normalized_occurrence": 1}
