{"model_name_or_path": "agentless_claude", "instance_id": "django__django-15128", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 782e26e..cd3914a 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -761,7 +761,20 @@ class Query(BaseExpression):\n \n         # Create a new alias for this table.\n         if alias_list:\n-            alias = '%s%d' % (self.alias_prefix, len(self.alias_map) + 1)\n+            # Find the next available alias number that won't conflict\n+            # with existing aliases or pending alias changes\n+            counter = len(self.alias_map) + 1\n+            while True:\n+                alias = '%s%d' % (self.alias_prefix, counter)\n+                # Check if this alias would conflict with existing aliases\n+                # or any aliases that might be created during remapping\n+                if alias not in self.alias_map and not any(\n+                    a.startswith(self.alias_prefix) and \n+                    int(a[1:]) <= counter \n+                    for a in self.alias_map\n+                ):\n+                    break\n+                counter += 1\n             alias_list.append(alias)\n         else:\n             # The first occurrence of a table uses the table name directly.\n@@ -845,8 +858,17 @@ class Query(BaseExpression):\n         Change the aliases in change_map (which maps old-alias -> new-alias),\n         relabelling any references to them in select columns and the where\n         clause.\n+\n+        The assertion ensures no alias is changed twice by checking that the set\n+        of old aliases (keys) has no overlap with the set of new aliases (values).\n+        This prevents ambiguous cases like {'T1': 'T2', 'T2': 'T3'} where 'T2'\n+        would need to be both removed and added, making the result dependent on\n+        operation order.\n         \"\"\"\n-        assert set(change_map).isdisjoint(change_map.values())\n+        assert set(change_map).isdisjoint(change_map.values()), (\n+            \"Alias renaming map contains conflicting changes: old aliases %r \"\n+            \"overlap with new aliases %r\" % (change_map.keys(), change_map.values())\n+        )\n \n         # 1. Update references in \"select\" (normal columns plus aliases),\n         # \"group by\" and \"where\".\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex c6ee433..c68ce5d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -429,7 +429,12 @@ class Query(BaseExpression):\n             self.alias_refcount[alias] += 1\n             return (alias, False)\n         if alias_list:\n-            alias = '%s%d' % (self.alias_prefix, len(self.alias_map) + 1)\n+            counter = len(self.alias_map) + 1\n+            while True:\n+                alias = '%s%d' % (self.alias_prefix, counter)\n+                if alias not in self.alias_map and (not any((a.startswith(self.alias_prefix) and int(a[1:]) <= counter for a in self.alias_map))):\n+                    break\n+                counter += 1\n             alias_list.append(alias)\n         else:\n             alias = filtered_relation.alias if filtered_relation is not None else table_name\n@@ -467,7 +472,7 @@ class Query(BaseExpression):\n             unref_amount = cur_refcount - to_counts.get(alias, 0)\n             self.unref_alias(alias, unref_amount)\n     def change_aliases(self, change_map):\n-        assert set(change_map).isdisjoint(change_map.values())\n+        assert set(change_map).isdisjoint(change_map.values()), 'Alias renaming map contains conflicting changes: old aliases %r overlap with new aliases %r' % (change_map.keys(), change_map.values())\n         self.where.relabel_aliases(change_map)\n         if isinstance(self.group_by, tuple):\n             self.group_by = tuple([col.relabeled_clone(change_map) for col in self.group_by])\n", "normalized_occurrence": 1}
