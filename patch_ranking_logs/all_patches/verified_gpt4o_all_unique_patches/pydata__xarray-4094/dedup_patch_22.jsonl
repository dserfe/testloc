{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4094", "model_patch": "diff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 7838e8d..42a1dd2 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -1408,6 +1408,11 @@ class Variable(\n         if len(dims) == 0:\n             # don't stack\n             return self.copy(deep=False)\n+        elif len(dims) == 1:\n+            # Only one dimension to stack, reshape accordingly\n+            new_data = self.data.reshape(self.shape + (1,))\n+            new_dims = self.dims + (new_dim,)\n+            return Variable(new_dims, new_data, self._attrs, self._encoding, fastpath=True)\n \n         other_dims = [d for d in self.dims if d not in dims]\n         dim_order = other_dims + list(dims)\n@@ -1451,11 +1456,17 @@ class Variable(\n         return result\n \n     def _unstack_once(self, dims, old_dim):\n+        if len(dims) == 1:\n+            # Only one dimension to unstack, reshape accordingly\n+            new_data = self.data.reshape(self.shape[:-1])\n+            new_dims = self.dims[:-1]\n+            return Variable(new_dims, new_data, self._attrs, self._encoding, fastpath=True)\n         new_dim_names = tuple(dims.keys())\n         new_dim_sizes = tuple(dims.values())\n \n         if old_dim not in self.dims:\n             raise ValueError(\"invalid existing dimension: %s\" % old_dim)\n+            raise ValueError(\"invalid existing dimension: %s\" % old_dim)\n \n         if set(new_dim_names).intersection(self.dims):\n             raise ValueError(\n", "occurrence": 1, "normalized_patch": "diff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 44b3a8e..bb75dd2 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -1067,6 +1067,10 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic, utils.NdimSi\n             raise ValueError('cannot create a new dimension with the same name as an existing dimension')\n         if len(dims) == 0:\n             return self.copy(deep=False)\n+        elif len(dims) == 1:\n+            new_data = self.data.reshape(self.shape + (1,))\n+            new_dims = self.dims + (new_dim,)\n+            return Variable(new_dims, new_data, self._attrs, self._encoding, fastpath=True)\n         other_dims = [d for d in self.dims if d not in dims]\n         dim_order = other_dims + list(dims)\n         reordered = self.transpose(*dim_order)\n@@ -1107,10 +1111,15 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic, utils.NdimSi\n         return result\n \n     def _unstack_once(self, dims, old_dim):\n+        if len(dims) == 1:\n+            new_data = self.data.reshape(self.shape[:-1])\n+            new_dims = self.dims[:-1]\n+            return Variable(new_dims, new_data, self._attrs, self._encoding, fastpath=True)\n         new_dim_names = tuple(dims.keys())\n         new_dim_sizes = tuple(dims.values())\n         if old_dim not in self.dims:\n             raise ValueError('invalid existing dimension: %s' % old_dim)\n+            raise ValueError('invalid existing dimension: %s' % old_dim)\n         if set(new_dim_names).intersection(self.dims):\n             raise ValueError('cannot create a new dimension with the same name as an existing dimension')\n         if np.prod(new_dim_sizes) != self.sizes[old_dim]:\n", "normalized_occurrence": 1}
