{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-19487", "model_patch": "diff --git a/sympy/core/function.py b/sympy/core/function.py\nindex 8682270..055e25c 100644\n--- a/sympy/core/function.py\n+++ b/sympy/core/function.py\n@@ -348,6 +348,15 @@ class Application(Basic, metaclass=FunctionClass):\n \n \n class Function(Application, Expr):\n+    def rewrite(self, *args, **hints):\n+        from sympy import Abs, sign\n+        if self.func == sign:\n+            if len(self.args) == 1:\n+                arg = self.args[0]\n+                if arg == 0:\n+                    return S.NaN if hints.get('nan', False) else 0\n+                return arg / Abs(arg)\n+        return super().rewrite(*args, **hints)\n     \"\"\"\n     Base class for applied mathematical functions.\n \n", "occurrence": 1, "normalized_patch": "--- a/sympy/core/function.py\n+++ b/sympy/core/function.py\n+    def rewrite(self, *args, **hints):\n+        from sympy import Abs, sign\n+        if self.func == sign:\n+            if len(self.args) == 1:\n+                arg = self.args[0]\n+                if arg == 0:\n+                    return S.NaN if hints.get('nan', False) else 0\n+                return arg / Abs(arg)\n+        return super().rewrite(*args, **hints)\n+    \"\\n    Base class for applied mathematical functions.\\n\\n    It also serves as a constructor for undefined function classes.\\n\\n    Examples\\n    ========\\n\\n    First example shows how to use Function as a constructor for undefined\\n    function classes:\\n\\n    >>> from sympy import Function, Symbol\\n    >>> x = Symbol('x')\\n    >>> f = Function('f')\\n    >>> g = Function('g')(x)\\n    >>> f\\n    f\\n    >>> f(x)\\n    f(x)\\n    >>> g\\n    g(x)\\n    >>> f(x).diff(x)\\n    Derivative(f(x), x)\\n    >>> g.diff(x)\\n    Derivative(g(x), x)\\n\\n    Assumptions can be passed to Function, and if function is initialized with a\\n    Symbol, the function inherits the name and assumptions associated with the Symbol:\\n\\n    >>> f_real = Function('f', real=True)\\n    >>> f_real(x).is_real\\n    True\\n    >>> f_real_inherit = Function(Symbol('f', real=True))\\n    >>> f_real_inherit(x).is_real\\n    True\\n\\n    Note that assumptions on a function are unrelated to the assumptions on\\n    the variable it is called on. If you want to add a relationship, subclass\\n    Function and define the appropriate ``_eval_is_assumption`` methods.\\n\\n    In the following example Function is used as a base class for\\n    ``my_func`` that represents a mathematical function *my_func*. Suppose\\n    that it is well known, that *my_func(0)* is *1* and *my_func* at infinity\\n    goes to *0*, so we want those two simplifications to occur automatically.\\n    Suppose also that *my_func(x)* is real exactly when *x* is real. Here is\\n    an implementation that honours those requirements:\\n\\n    >>> from sympy import Function, S, oo, I, sin\\n    >>> class my_func(Function):\\n    ...\\n    ...     @classmethod\\n    ...     def eval(cls, x):\\n    ...         if x.is_Number:\\n    ...             if x.is_zero:\\n    ...                 return S.One\\n    ...             elif x is S.Infinity:\\n    ...                 return S.Zero\\n    ...\\n    ...     def _eval_is_real(self):\\n    ...         return self.args[0].is_real\\n    ...\\n    >>> x = S('x')\\n    >>> my_func(0) + sin(0)\\n    1\\n    >>> my_func(oo)\\n    0\\n    >>> my_func(3.54).n() # Not yet implemented for my_func.\\n    my_func(3.54)\\n    >>> my_func(I).is_real\\n    False\\n\\n    In order for ``my_func`` to become useful, several other methods would\\n    need to be implemented. See source code of some of the already\\n    implemented functions for more complete examples.\\n\\n    Also, if the function can take more than one argument, then ``nargs``\\n    must be defined, e.g. if ``my_func`` can take one or two arguments\\n    then,\\n\\n    >>> class my_func(Function):\\n    ...     nargs = (1, 2)\\n    ...\\n    >>>\\n\\n    \"", "normalized_occurrence": 1}
