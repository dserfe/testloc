{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-5103", "model_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 4810cdd..6b90dfe 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -748,7 +748,55 @@ class AssertionRewriter(ast.NodeVisitor):\n         \"\"\"Call saferepr on the expression.\"\"\"\n         return self.helper(\"_saferepr\", expr)\n \n-    def helper(self, name, *args):\n+    def visit_Call_all_any(self, call, func_name):\n+        \"\"\"\n+        Handles `all` and `any` calls by unrolling the iterables and providing detailed assertion messages.\n+        \"\"\"\n+        assert func_name in {\"all\", \"any\"}\n+\n+        # Visit the first argument which should be an iterable\n+        first_arg = call.args[0]\n+        res_var = self.variable()\n+        expl_list = self.assign(ast.List([], ast.Load()))\n+        app = ast.Attribute(expl_list, \"append\", ast.Load())\n+\n+        self.push_format_context()\n+        self.statements.append(self.assign(call))\n+\n+        # Unroll the iterable\n+        iter_var = self.variable()\n+        self.statements.append(ast.Assign([ast.Name(iter_var, ast.Store())], first_arg))\n+\n+        loop_var = self.variable()\n+        loop = ast.For(\n+            target=ast.Name(loop_var, ast.Store()),\n+            iter=ast.Name(iter_var, ast.Load()),\n+            body=[],\n+            orelse=[]\n+        )\n+\n+        # Process each element in the iterable\n+        self.push_format_context()\n+        res, expl = self.visit(ast.Call(\n+            func=ast.Name(func_name, ast.Load()),\n+            args=[ast.Name(loop_var, ast.Load())],\n+            keywords=[]\n+        ))\n+        loop.body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))\n+        expl_format = self.pop_format_context(ast.Str(expl))\n+        call = ast_Call(app, [expl_format], [])\n+        loop.body.append(ast.Expr(call))\n+        self.statements.append(loop)\n+\n+        # Negation for all and any\n+        if func_name == \"all\":\n+            negation = ast.UnaryOp(ast.Not(), ast.Name(res_var, ast.Load()))\n+        else:\n+            negation = ast.Name(res_var, ast.Load())\n+\n+        expl_template = self.helper(\"_format_boolop\", expl_list, ast.Num(int(func_name == \"any\")))\n+        expl = self.pop_format_context(expl_template)\n+        return ast.Name(res_var, ast.Load()), self.explanation_param(expl)\n         \"\"\"Call a helper in this module.\"\"\"\n         py_name = ast.Name(\"@pytest_ar\", ast.Load())\n         attr = ast.Attribute(py_name, name, ast.Load())\n@@ -969,6 +1017,10 @@ warn_explicit(\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n         new_func, func_expl = self.visit(call.func)\n+\n+        # Check if the function is `all` or `any`\n+        if isinstance(new_func, ast.Name) and new_func.id in {\"all\", \"any\"}:\n+            return self.visit_Call_all_any(call, new_func.id)\n         arg_expls = []\n         new_args = []\n         new_kwargs = []\n@@ -1002,6 +1054,10 @@ warn_explicit(\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n         new_func, func_expl = self.visit(call.func)\n+\n+        # Check if the function is `all` or `any`\n+        if isinstance(new_func, ast.Name) and new_func.id in {\"all\", \"any\"}:\n+            return self.visit_Call_all_any(call, new_func.id)\n         arg_expls = []\n         new_args = []\n         new_kwargs = []\n@@ -1081,4 +1137,4 @@ warn_explicit(\n             res = ast.BoolOp(ast.And(), load_names)\n         else:\n             res = load_names[0]\n-        return res, self.explanation_param(self.pop_format_context(expl_call))\n+        return res, self.explanation_param(self.pop_format_context(expl_call))\n", "occurrence": 1, "normalized_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2ada5b2..17f5df2 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -419,7 +419,32 @@ class AssertionRewriter(ast.NodeVisitor):\n         return ast.Name(name, ast.Load())\n     def display(self, expr):\n         return self.helper('_saferepr', expr)\n-    def helper(self, name, *args):\n+    def visit_Call_all_any(self, call, func_name):\n+        assert func_name in {'all', 'any'}\n+        first_arg = call.args[0]\n+        res_var = self.variable()\n+        expl_list = self.assign(ast.List([], ast.Load()))\n+        app = ast.Attribute(expl_list, 'append', ast.Load())\n+        self.push_format_context()\n+        self.statements.append(self.assign(call))\n+        iter_var = self.variable()\n+        self.statements.append(ast.Assign([ast.Name(iter_var, ast.Store())], first_arg))\n+        loop_var = self.variable()\n+        loop = ast.For(target=ast.Name(loop_var, ast.Store()), iter=ast.Name(iter_var, ast.Load()), body=[], orelse=[])\n+        self.push_format_context()\n+        res, expl = self.visit(ast.Call(func=ast.Name(func_name, ast.Load()), args=[ast.Name(loop_var, ast.Load())], keywords=[]))\n+        loop.body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))\n+        expl_format = self.pop_format_context(ast.Str(expl))\n+        call = ast_Call(app, [expl_format], [])\n+        loop.body.append(ast.Expr(call))\n+        self.statements.append(loop)\n+        if func_name == 'all':\n+            negation = ast.UnaryOp(ast.Not(), ast.Name(res_var, ast.Load()))\n+        else:\n+            negation = ast.Name(res_var, ast.Load())\n+        expl_template = self.helper('_format_boolop', expl_list, ast.Num(int(func_name == 'any')))\n+        expl = self.pop_format_context(expl_template)\n+        return (ast.Name(res_var, ast.Load()), self.explanation_param(expl))\n         py_name = ast.Name('@pytest_ar', ast.Load())\n         attr = ast.Attribute(py_name, name, ast.Load())\n         return ast_Call(attr, list(args), [])\n@@ -545,6 +570,8 @@ class AssertionRewriter(ast.NodeVisitor):\n         return (res, explanation)\n     def visit_Call_35(self, call):\n         new_func, func_expl = self.visit(call.func)\n+        if isinstance(new_func, ast.Name) and new_func.id in {'all', 'any'}:\n+            return self.visit_Call_all_any(call, new_func.id)\n         arg_expls = []\n         new_args = []\n         new_kwargs = []\n@@ -571,6 +598,8 @@ class AssertionRewriter(ast.NodeVisitor):\n         return (new_starred, '*' + expl)\n     def visit_Call_legacy(self, call):\n         new_func, func_expl = self.visit(call.func)\n+        if isinstance(new_func, ast.Name) and new_func.id in {'all', 'any'}:\n+            return self.visit_Call_all_any(call, new_func.id)\n         arg_expls = []\n         new_args = []\n         new_kwargs = []\n", "normalized_occurrence": 1}
