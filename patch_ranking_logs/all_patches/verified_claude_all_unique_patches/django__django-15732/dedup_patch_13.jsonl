{"model_name_or_path": "agentless_claude", "instance_id": "django__django-15732", "model_patch": "diff --git a/django/db/backends/postgresql/schema.py b/django/db/backends/postgresql/schema.py\nindex fdd1271..a2df043 100644\n--- a/django/db/backends/postgresql/schema.py\n+++ b/django/db/backends/postgresql/schema.py\n@@ -1,3 +1,4 @@\n+\n import psycopg2\n \n from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n@@ -186,28 +187,33 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         else:\n             return super()._alter_column_type_sql(model, old_field, new_field, new_type)\n \n-    def _alter_field(\n-        self,\n-        model,\n-        old_field,\n-        new_field,\n-        old_type,\n-        new_type,\n-        old_db_params,\n-        new_db_params,\n-        strict=False,\n-    ):\n-        # Drop indexes on varchar/text/citext columns that are changing to a\n-        # different type.\n-        if (old_field.db_index or old_field.unique) and (\n-            (old_type.startswith(\"varchar\") and not new_type.startswith(\"varchar\"))\n-            or (old_type.startswith(\"text\") and not new_type.startswith(\"text\"))\n-            or (old_type.startswith(\"citext\") and not new_type.startswith(\"citext\"))\n-        ):\n-            index_name = self._create_index_name(\n-                model._meta.db_table, [old_field.column], suffix=\"_like\"\n+\n+\n+        # Drop any unique constraints that might conflict with unique_together changes\n+        if old_field.unique and not new_field.unique:\n+            # Get all unique constraints for this column\n+            self.execute(\n+                \"\"\"\n+                SELECT conname \n+                FROM pg_constraint \n+                WHERE conrelid = %s::regclass \n+                AND contype = 'u' \n+                AND array_to_string(conkey, ',') = (\n+                    SELECT array_to_string(ARRAY[attnum], ',')\n+                    FROM pg_attribute\n+                    WHERE attrelid = %s::regclass\n+                    AND attname = %s\n+                )\n+                \"\"\",\n+                [model._meta.db_table, model._meta.db_table, old_field.column]\n             )\n-            self.execute(self._delete_index_sql(model, index_name))\n+            for constraint in self.connection.cursor().fetchall():\n+                self.execute(\n+                    'ALTER TABLE %s DROP CONSTRAINT IF EXISTS %s' % (\n+                        self.quote_name(model._meta.db_table),\n+                        self.quote_name(constraint[0])\n+                    )\n+                )\n \n         super()._alter_field(\n             model,\n@@ -296,4 +302,4 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             condition=condition,\n             include=include,\n             expressions=expressions,\n-        )\n+        )\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/backends/postgresql/schema.py b/django/db/backends/postgresql/schema.py\nindex d911e18..baa2934 100644\n--- a/django/db/backends/postgresql/schema.py\n+++ b/django/db/backends/postgresql/schema.py\n@@ -71,10 +71,10 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             return (fragment, [(self.sql_delete_sequence % {'sequence': self.quote_name(sequence_name)}, [])])\n         else:\n             return super()._alter_column_type_sql(model, old_field, new_field, new_type)\n-    def _alter_field(self, model, old_field, new_field, old_type, new_type, old_db_params, new_db_params, strict=False):\n-        if (old_field.db_index or old_field.unique) and (old_type.startswith('varchar') and (not new_type.startswith('varchar')) or (old_type.startswith('text') and (not new_type.startswith('text'))) or (old_type.startswith('citext') and (not new_type.startswith('citext')))):\n-            index_name = self._create_index_name(model._meta.db_table, [old_field.column], suffix='_like')\n-            self.execute(self._delete_index_sql(model, index_name))\n+        if old_field.unique and (not new_field.unique):\n+            self.execute(\"\\n                SELECT conname \\n                FROM pg_constraint \\n                WHERE conrelid = %s::regclass \\n                AND contype = 'u' \\n                AND array_to_string(conkey, ',') = (\\n                    SELECT array_to_string(ARRAY[attnum], ',')\\n                    FROM pg_attribute\\n                    WHERE attrelid = %s::regclass\\n                    AND attname = %s\\n                )\\n                \", [model._meta.db_table, model._meta.db_table, old_field.column])\n+            for constraint in self.connection.cursor().fetchall():\n+                self.execute('ALTER TABLE %s DROP CONSTRAINT IF EXISTS %s' % (self.quote_name(model._meta.db_table), self.quote_name(constraint[0])))\n         super()._alter_field(model, old_field, new_field, old_type, new_type, old_db_params, new_db_params, strict)\n         if not (old_field.db_index or old_field.unique) and new_field.db_index or (not old_field.unique and new_field.unique):\n             like_index_statement = self._create_like_index_sql(model, new_field)\n", "normalized_occurrence": 1}
