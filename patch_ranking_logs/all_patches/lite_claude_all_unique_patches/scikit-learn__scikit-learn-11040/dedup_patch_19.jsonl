{"model_name_or_path": "agentless_claude", "instance_id": "scikit-learn__scikit-learn-11040", "model_patch": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 01d85d0..c3541d2 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -253,6 +253,11 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n                              % self.algorithm)\n \n         if self.n_neighbors is not None:\n+            if not isinstance(self.n_neighbors, (int, np.integer)):\n+                raise TypeError(\n+                    \"n_neighbors does not take float values, got %r\" % \n+                    self.n_neighbors\n+                )\n             if self.n_neighbors <= 0:\n                 raise ValueError(\n                     \"Expected n_neighbors > 0. Got %d\" %\n@@ -327,6 +332,11 @@ class KNeighborsMixin(object):\n \n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n+        \n+        if not isinstance(n_neighbors, (int, np.integer)):\n+            raise TypeError(\n+                \"n_neighbors does not take float values, got %r\" % n_neighbors\n+            )\n \n         if X is not None:\n             query_is_train = False\n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex ddfefae..e2376e1 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -151,6 +151,8 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n         else:\n             raise ValueError(\"algorithm = '%s' not recognized\" % self.algorithm)\n         if self.n_neighbors is not None:\n+            if not isinstance(self.n_neighbors, (int, np.integer)):\n+                raise TypeError('n_neighbors does not take float values, got %r' % self.n_neighbors)\n             if self.n_neighbors <= 0:\n                 raise ValueError('Expected n_neighbors > 0. Got %d' % self.n_neighbors)\n         return self\n@@ -162,6 +164,8 @@ class KNeighborsMixin(object):\n         check_is_fitted(self, '_fit_method')\n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n+        if not isinstance(n_neighbors, (int, np.integer)):\n+            raise TypeError('n_neighbors does not take float values, got %r' % n_neighbors)\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n", "normalized_occurrence": 1}
