{"model_name_or_path": "agentless_claude", "instance_id": "django__django-10554", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex ab425fb..5997960 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -344,18 +344,22 @@ class SQLCompiler:\n             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n             if self.query.combinator:\n                 src = resolved.get_source_expressions()[0]\n-                # Relabel order by columns to raw numbers if this is a combined\n-                # query; necessary since the columns can't be referenced by the\n-                # fully qualified name and the simple column names may collide.\n+                # For combined queries, we need to ensure ORDER BY references are valid\n+                # after the combination operation\n                 for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n                     if is_ref and col_alias == src.refs:\n                         src = src.source\n                     elif col_alias:\n                         continue\n                     if src == sel_expr:\n-                        resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n+                        # Use position in final select list for ordering\n+                        resolved.set_source_expressions([RawSQL('\"%s\"' % (idx + 1), ())])\n                         break\n                 else:\n+                    # If we can't find the expression, it might be an ordering on a \n+                    # column that only exists in the combined query\n+                    if has_ordering:\n+                        continue\n                     raise DatabaseError('ORDER BY term does not match any column in the result set.')\n             sql, params = self.compile(resolved)\n             # Don't add the same column twice, but the order direction is\n@@ -419,6 +423,8 @@ class SQLCompiler:\n                     raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')\n                 if compiler.get_order_by():\n                     raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')\n+        \n+        has_ordering = any(compiler.query.order_by for compiler in compilers)\n         parts = ()\n         for compiler in compilers:\n             try:\n@@ -481,7 +487,11 @@ class SQLCompiler:\n             if combinator:\n                 if not getattr(features, 'supports_select_{}'.format(combinator)):\n                     raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n+                # Reset order_by since it will be handled by get_combinator_sql()\n+                saved_order_by = self.query.order_by\n+                self.query.order_by = ()\n                 result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+                self.query.order_by = saved_order_by\n             else:\n                 distinct_fields, distinct_params = self.get_distinct()\n                 # This must come after 'select', 'ordering', and 'distinct'\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 0a7444d..aba7b03 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -189,9 +189,11 @@ class SQLCompiler:\n                     elif col_alias:\n                         continue\n                     if src == sel_expr:\n-                        resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n+                        resolved.set_source_expressions([RawSQL('\"%s\"' % (idx + 1), ())])\n                         break\n                 else:\n+                    if has_ordering:\n+                        continue\n                     raise DatabaseError('ORDER BY term does not match any column in the result set.')\n             sql, params = self.compile(resolved)\n             without_ordering = self.ordering_parts.search(sql).group(1)\n@@ -237,6 +239,7 @@ class SQLCompiler:\n                     raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')\n                 if compiler.get_order_by():\n                     raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')\n+        has_ordering = any((compiler.query.order_by for compiler in compilers))\n         parts = ()\n         for compiler in compilers:\n             try:\n@@ -277,7 +280,10 @@ class SQLCompiler:\n             if combinator:\n                 if not getattr(features, 'supports_select_{}'.format(combinator)):\n                     raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n+                saved_order_by = self.query.order_by\n+                self.query.order_by = ()\n                 result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+                self.query.order_by = saved_order_by\n             else:\n                 distinct_fields, distinct_params = self.get_distinct()\n                 from_, f_params = self.get_from_clause()\n", "normalized_occurrence": 1}
