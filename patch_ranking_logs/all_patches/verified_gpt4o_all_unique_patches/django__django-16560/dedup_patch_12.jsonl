{"model_name_or_path": "agentless", "instance_id": "django__django-16560", "model_patch": "diff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 8b23275..6cc2f9c 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -22,8 +22,8 @@ class BaseConstraint:\n \n     # RemovedInDjango60Warning: When the deprecation ends, replace with:\n     # def __init__(self, *, name, violation_error_message=None):\n-    def __init__(self, *args, name=None, violation_error_message=None):\n-        # RemovedInDjango60Warning.\n+    def __init__(self, *args, name=None, violation_error_message=None, violation_error_code=None):\n+        self.violation_error_code = violation_error_code\n         if name is None and not args:\n             raise TypeError(\n                 f\"{self.__class__.__name__}.__init__() missing 1 required keyword-only \"\n@@ -34,7 +34,7 @@ class BaseConstraint:\n             self.violation_error_message = violation_error_message\n         else:\n             self.violation_error_message = self.default_violation_error_message\n-        # RemovedInDjango60Warning.\n+        self.violation_error_code = violation_error_code\n         if args:\n             warnings.warn(\n                 f\"Passing positional arguments to {self.__class__.__name__} is \"\n@@ -74,7 +74,9 @@ class BaseConstraint:\n             and self.violation_error_message != self.default_violation_error_message\n         ):\n             kwargs[\"violation_error_message\"] = self.violation_error_message\n-        return (path, (), kwargs)\n+        if self.violation_error_code is not None:\n+            kwargs[\"violation_error_code\"] = self.violation_error_code\n+        return path, (), kwargs\n \n     def clone(self):\n         _, args, kwargs = self.deconstruct()\n@@ -82,13 +84,13 @@ class BaseConstraint:\n \n \n class CheckConstraint(BaseConstraint):\n-    def __init__(self, *, check, name, violation_error_message=None):\n+    def __init__(self, *, check, name, violation_error_message=None, violation_error_code=None):\n         self.check = check\n         if not getattr(check, \"conditional\", False):\n             raise TypeError(\n                 \"CheckConstraint.check must be a Q instance or boolean expression.\"\n             )\n-        super().__init__(name=name, violation_error_message=violation_error_message)\n+        super().__init__(name=name, violation_error_message=violation_error_message, violation_error_code=violation_error_code)\n \n     def _get_check_sql(self, model, schema_editor):\n         query = Query(model=model, alias_cols=False)\n@@ -112,7 +114,7 @@ class CheckConstraint(BaseConstraint):\n         against = instance._get_field_value_map(meta=model._meta, exclude=exclude)\n         try:\n             if not Q(self.check).check(against, using=using):\n-                raise ValidationError(self.get_violation_error_message())\n+                raise ValidationError(self.get_violation_error_message(), code=self.violation_error_code)\n         except FieldError:\n             pass\n \n@@ -164,6 +166,7 @@ class UniqueConstraint(BaseConstraint):\n         include=None,\n         opclasses=(),\n         violation_error_message=None,\n+        violation_error_code=None,\n     ):\n         if not name:\n             raise ValueError(\"A unique constraint must be named.\")\n@@ -213,7 +216,7 @@ class UniqueConstraint(BaseConstraint):\n             F(expression) if isinstance(expression, str) else expression\n             for expression in expressions\n         )\n-        super().__init__(name=name, violation_error_message=violation_error_message)\n+        super().__init__(name=name, violation_error_message=violation_error_message, violation_error_code=violation_error_code)\n \n     @property\n     def contains_expressions(self):\n@@ -385,14 +388,14 @@ class UniqueConstraint(BaseConstraint):\n         if not self.condition:\n             if queryset.exists():\n                 if self.expressions:\n-                    raise ValidationError(self.get_violation_error_message())\n+                    raise ValidationError(self.get_violation_error_message(), code=self.violation_error_code)\n                 # When fields are defined, use the unique_error_message() for\n                 # backward compatibility.\n                 for model, constraints in instance.get_constraints():\n                     for constraint in constraints:\n                         if constraint is self:\n                             raise ValidationError(\n-                                instance.unique_error_message(model, self.fields)\n+                                instance.unique_error_message(model, self.fields), code=self.violation_error_code\n                             )\n         else:\n             against = instance._get_field_value_map(meta=model._meta, exclude=exclude)\n@@ -400,6 +403,6 @@ class UniqueConstraint(BaseConstraint):\n                 if (self.condition & Exists(queryset.filter(self.condition))).check(\n                     against, using=using\n                 ):\n-                    raise ValidationError(self.get_violation_error_message())\n+                    raise ValidationError(self.get_violation_error_message(), code=self.violation_error_code)\n             except FieldError:\n-                pass\n+                pass\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 50c20cc..e84baf6 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -15,7 +15,8 @@ __all__ = ['BaseConstraint', 'CheckConstraint', 'Deferrable', 'UniqueConstraint'\n class BaseConstraint:\n     default_violation_error_message = _('Constraint “%(name)s” is violated.')\n     violation_error_message = None\n-    def __init__(self, *args, name=None, violation_error_message=None):\n+    def __init__(self, *args, name=None, violation_error_message=None, violation_error_code=None):\n+        self.violation_error_code = violation_error_code\n         if name is None and (not args):\n             raise TypeError(f\"{self.__class__.__name__}.__init__() missing 1 required keyword-only argument: 'name'\")\n         self.name = name\n@@ -23,6 +24,7 @@ class BaseConstraint:\n             self.violation_error_message = violation_error_message\n         else:\n             self.violation_error_message = self.default_violation_error_message\n+        self.violation_error_code = violation_error_code\n         if args:\n             warnings.warn(f'Passing positional arguments to {self.__class__.__name__} is deprecated.', RemovedInDjango60Warning, stacklevel=2)\n             for arg, attr in zip(args, ['name', 'violation_error_message']):\n@@ -47,16 +49,18 @@ class BaseConstraint:\n         kwargs = {'name': self.name}\n         if self.violation_error_message is not None and self.violation_error_message != self.default_violation_error_message:\n             kwargs['violation_error_message'] = self.violation_error_message\n+        if self.violation_error_code is not None:\n+            kwargs['violation_error_code'] = self.violation_error_code\n         return (path, (), kwargs)\n     def clone(self):\n         _, args, kwargs = self.deconstruct()\n         return self.__class__(*args, **kwargs)\n class CheckConstraint(BaseConstraint):\n-    def __init__(self, *, check, name, violation_error_message=None):\n+    def __init__(self, *, check, name, violation_error_message=None, violation_error_code=None):\n         self.check = check\n         if not getattr(check, 'conditional', False):\n             raise TypeError('CheckConstraint.check must be a Q instance or boolean expression.')\n-        super().__init__(name=name, violation_error_message=violation_error_message)\n+        super().__init__(name=name, violation_error_message=violation_error_message, violation_error_code=violation_error_code)\n     def _get_check_sql(self, model, schema_editor):\n         query = Query(model=model, alias_cols=False)\n         where = query.build_where(self.check)\n@@ -75,7 +79,7 @@ class CheckConstraint(BaseConstraint):\n         against = instance._get_field_value_map(meta=model._meta, exclude=exclude)\n         try:\n             if not Q(self.check).check(against, using=using):\n-                raise ValidationError(self.get_violation_error_message())\n+                raise ValidationError(self.get_violation_error_message(), code=self.violation_error_code)\n         except FieldError:\n             pass\n     def __repr__(self):\n@@ -94,7 +98,7 @@ class Deferrable(Enum):\n     def __repr__(self):\n         return f'{self.__class__.__qualname__}.{self._name_}'\n class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *expressions, fields=(), name=None, condition=None, deferrable=None, include=None, opclasses=(), violation_error_message=None):\n+    def __init__(self, *expressions, fields=(), name=None, condition=None, deferrable=None, include=None, opclasses=(), violation_error_message=None, violation_error_code=None):\n         if not name:\n             raise ValueError('A unique constraint must be named.')\n         if not expressions and (not fields):\n@@ -127,7 +131,7 @@ class UniqueConstraint(BaseConstraint):\n         self.include = tuple(include) if include else ()\n         self.opclasses = opclasses\n         self.expressions = tuple((F(expression) if isinstance(expression, str) else expression for expression in expressions))\n-        super().__init__(name=name, violation_error_message=violation_error_message)\n+        super().__init__(name=name, violation_error_message=violation_error_message, violation_error_code=violation_error_code)\n     @property\n     def contains_expressions(self):\n         return bool(self.expressions)\n@@ -219,15 +223,15 @@ class UniqueConstraint(BaseConstraint):\n         if not self.condition:\n             if queryset.exists():\n                 if self.expressions:\n-                    raise ValidationError(self.get_violation_error_message())\n+                    raise ValidationError(self.get_violation_error_message(), code=self.violation_error_code)\n                 for model, constraints in instance.get_constraints():\n                     for constraint in constraints:\n                         if constraint is self:\n-                            raise ValidationError(instance.unique_error_message(model, self.fields))\n+                            raise ValidationError(instance.unique_error_message(model, self.fields), code=self.violation_error_code)\n         else:\n             against = instance._get_field_value_map(meta=model._meta, exclude=exclude)\n             try:\n                 if (self.condition & Exists(queryset.filter(self.condition))).check(against, using=using):\n-                    raise ValidationError(self.get_violation_error_message())\n+                    raise ValidationError(self.get_violation_error_message(), code=self.violation_error_code)\n             except FieldError:\n                 pass\n\\ No newline at end of file\n", "normalized_occurrence": 2}
