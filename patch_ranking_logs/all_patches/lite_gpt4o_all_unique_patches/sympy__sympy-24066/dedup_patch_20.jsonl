{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-24066", "model_patch": "diff --git a/sympy/physics/units/unitsystem.py b/sympy/physics/units/unitsystem.py\nindex 4413d8e..7b15fa7 100644\n--- a/sympy/physics/units/unitsystem.py\n+++ b/sympy/physics/units/unitsystem.py\n@@ -184,16 +184,25 @@ class UnitSystem(_QuantityMapper):\n             return factor, dim\n         elif isinstance(expr, Derivative):\n             factor, dim = self._collect_factor_and_dimension(expr.args[0])\n-            for independent, count in expr.variable_count:\n-                ifactor, idim = self._collect_factor_and_dimension(independent)\n-                factor /= ifactor**count\n-                dim /= idim**count\n-            return factor, dim\n+            if isinstance(expr.func, FunctionClass):\n+                for independent, count in expr.variable_count:\n+                    ifactor, idim = self._collect_factor_and_dimension(independent)\n+                    factor /= ifactor**count\n+                    dim /= idim**count\n+                return factor, dim\n+            \n         elif isinstance(expr, Function):\n-            fds = [self._collect_factor_and_dimension(\n-                arg) for arg in expr.args]\n-            return (expr.func(*(f[0] for f in fds)),\n-                    *(d[1] for d in fds))\n+            fds = [self._collect_factor_and_dimension(arg) for arg in expr.args]\n+            factors, dims = zip(*fds)\n+            \n+            # If the original function is exponential, its argument must be dimensionless\n+            if expr.func == exp:\n+                if all(d.is_dimensionless for d in dims):\n+                    return expr.func(*factors), Dimension(1)\n+                else:\n+                    raise ValueError(f\"Dimension of argument to exp is not dimensionless: {dims}\")\n+                    \n+            return expr.func(*factors), Dimension(1)\n         elif isinstance(expr, Dimension):\n             return S.One, expr\n         else:\n@@ -203,4 +212,4 @@ class UnitSystem(_QuantityMapper):\n         \"\"\"\n         Return the units of the system that do not have a prefix.\n         \"\"\"\n-        return set(filter(lambda u: not u.is_prefixed and not u.is_physical_constant, self._units))\n+        return set(filter(lambda u: not u.is_prefixed and not u.is_physical_constant, self._units))\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/physics/units/unitsystem.py b/sympy/physics/units/unitsystem.py\nindex 33c8d4e..080fcd9 100644\n--- a/sympy/physics/units/unitsystem.py\n+++ b/sympy/physics/units/unitsystem.py\n@@ -110,14 +110,21 @@ class UnitSystem(_QuantityMapper):\n             return (factor, dim)\n         elif isinstance(expr, Derivative):\n             factor, dim = self._collect_factor_and_dimension(expr.args[0])\n-            for independent, count in expr.variable_count:\n-                ifactor, idim = self._collect_factor_and_dimension(independent)\n-                factor /= ifactor ** count\n-                dim /= idim ** count\n-            return (factor, dim)\n+            if isinstance(expr.func, FunctionClass):\n+                for independent, count in expr.variable_count:\n+                    ifactor, idim = self._collect_factor_and_dimension(independent)\n+                    factor /= ifactor ** count\n+                    dim /= idim ** count\n+                return (factor, dim)\n         elif isinstance(expr, Function):\n             fds = [self._collect_factor_and_dimension(arg) for arg in expr.args]\n-            return (expr.func(*(f[0] for f in fds)), *(d[1] for d in fds))\n+            factors, dims = zip(*fds)\n+            if expr.func == exp:\n+                if all((d.is_dimensionless for d in dims)):\n+                    return (expr.func(*factors), Dimension(1))\n+                else:\n+                    raise ValueError(f'Dimension of argument to exp is not dimensionless: {dims}')\n+            return (expr.func(*factors), Dimension(1))\n         elif isinstance(expr, Dimension):\n             return (S.One, expr)\n         else:\n", "normalized_occurrence": 1}
