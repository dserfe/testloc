{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-25638", "model_patch": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex db3f82e..cb6c761 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -78,6 +78,7 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+    ys = [pd.Series(y).array if isinstance(y, pd.Series) and hasattr(y, \"dtype\") and y.dtype.name in [\"Int64\", \"Float64\", \"boolean\"] else y for y in ys]\n     ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n@@ -340,7 +341,7 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n+    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str) and y.dtype.name not in [\"Int64\", \"Float64\", \"boolean\"]:\n         # [obj_1] and not [\"label_1\"]\n         return \"unknown\"\n \n@@ -358,13 +359,12 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n-    # Check multiclass\n-    first_row = y[0] if not issparse(y) else y.getrow(0).data\n-    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n-        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n+    # Check multiclass or binary after handling nullable dtypes\n+    if y.dtype.name in [\"Int64\", \"Float64\", \"boolean\"]:\n+        y = y.astype(\"float\" if y.dtype.name == \"Float64\" else \"int\")\n+    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(y[0] if not issparse(y) else y.getrow(0).data) > 1):\n         return \"multiclass\" + suffix\n-    else:\n-        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n+    return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n \n \n def _check_partial_fit_first_call(clf, classes=None):\n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex dee4b2a..63a4559 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,6 +20,7 @@ def unique_labels(*ys):\n     xp, is_array_api = get_namespace(*ys)\n     if not ys:\n         raise ValueError('No argument has been passed.')\n+    ys = [pd.Series(y).array if isinstance(y, pd.Series) and hasattr(y, 'dtype') and (y.dtype.name in ['Int64', 'Float64', 'boolean']) else y for y in ys]\n     ys_types = set((type_of_target(x) for x in ys))\n     if ys_types == {'binary', 'multiclass'}:\n         ys_types = {'multiclass'}\n@@ -91,7 +92,7 @@ def type_of_target(y, input_name=''):\n         if y.ndim == 1:\n             return 'binary'\n         return 'unknown'\n-    if not issparse(y) and y.dtype == object and (not isinstance(y.flat[0], str)):\n+    if not issparse(y) and y.dtype == object and (not isinstance(y.flat[0], str)) and (y.dtype.name not in ['Int64', 'Float64', 'boolean']):\n         return 'unknown'\n     if y.ndim == 2 and y.shape[1] > 1:\n         suffix = '-multioutput'\n@@ -102,11 +103,11 @@ def type_of_target(y, input_name=''):\n         if xp.any(data != data.astype(int)):\n             _assert_all_finite(data, input_name=input_name)\n             return 'continuous' + suffix\n-    first_row = y[0] if not issparse(y) else y.getrow(0).data\n-    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n+    if y.dtype.name in ['Int64', 'Float64', 'boolean']:\n+        y = y.astype('float' if y.dtype.name == 'Float64' else 'int')\n+    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(y[0] if not issparse(y) else y.getrow(0).data) > 1):\n         return 'multiclass' + suffix\n-    else:\n-        return 'binary'\n+    return 'binary'\n def _check_partial_fit_first_call(clf, classes=None):\n     if getattr(clf, 'classes_', None) is None and classes is None:\n         raise ValueError('classes must be passed on the first call to partial_fit.')\n", "normalized_occurrence": 1}
