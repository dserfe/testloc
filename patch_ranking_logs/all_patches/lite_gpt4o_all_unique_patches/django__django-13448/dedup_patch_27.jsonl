{"model_name_or_path": "agentless", "instance_id": "django__django-13448", "model_patch": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex d751f3a..ffbcf5c 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,7 +58,7 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n-        if self.connection.settings_dict['TEST']['MIGRATE']:\n+        if self.connection.settings_dict['TEST'].get('MIGRATE', True):\n             # We report migrate messages at one level lower than that\n             # requested. This ensures we don't get flooded with messages during\n             # testing (unless you really ask to be flooded).\n@@ -70,6 +70,9 @@ class BaseDatabaseCreation:\n                 run_syncdb=True,\n             )\n \n+        else:\n+            self._create_tables()\n+\n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n@@ -84,7 +87,16 @@ class BaseDatabaseCreation:\n \n         return test_database_name\n \n-    def set_as_test_mirror(self, primary_settings_dict):\n+    def _create_tables(self):\n+        \"\"\"\n+        Create the necessary tables manually when migrations are skipped.\n+        \"\"\"\n+        from django.core.management.commands.migrate import Command as MigrateCommand\n+        from django.db.migrations.executor import MigrationExecutor\n+\n+        executor = MigrationExecutor(self.connection)\n+        for migration in executor.loader.graph.leaf_nodes():\n+            MigrateCommand().sync_apps(self.connection, [migration[0]])\n         \"\"\"\n         Set this database up to be used in testing as a mirror of a primary\n         database whose settings are given.\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 4f2d479..4102757 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -26,14 +26,22 @@ class BaseDatabaseCreation:\n         self.connection.close()\n         settings.DATABASES[self.connection.alias]['NAME'] = test_database_name\n         self.connection.settings_dict['NAME'] = test_database_name\n-        if self.connection.settings_dict['TEST']['MIGRATE']:\n+        if self.connection.settings_dict['TEST'].get('MIGRATE', True):\n             call_command('migrate', verbosity=max(verbosity - 1, 0), interactive=False, database=self.connection.alias, run_syncdb=True)\n+        else:\n+            self._create_tables()\n         if serialize:\n             self.connection._test_serialized_contents = self.serialize_db_to_string()\n         call_command('createcachetable', database=self.connection.alias)\n         self.connection.ensure_connection()\n         return test_database_name\n-    def set_as_test_mirror(self, primary_settings_dict):\n+    def _create_tables(self):\n+        from django.core.management.commands.migrate import Command as MigrateCommand\n+        from django.db.migrations.executor import MigrationExecutor\n+        executor = MigrationExecutor(self.connection)\n+        for migration in executor.loader.graph.leaf_nodes():\n+            MigrateCommand().sync_apps(self.connection, [migration[0]])\n+        '\\n        Set this database up to be used in testing as a mirror of a primary\\n        database whose settings are given.\\n        '\n         self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n     def serialize_db_to_string(self):\n         def get_objects():\n", "normalized_occurrence": 1}
