{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13146", "model_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex e24efd1..c312025 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -642,6 +642,12 @@ def evalf_pow(v, prec, options):\n \n     target_prec = prec\n     base, exp = v.args\n+    \n+    # Convert floating point exponents to rationals for consistent evaluation\n+    if exp.is_Float:\n+        from sympy import nsimplify\n+        exp = nsimplify(exp, rational=True)\n+        v = v.func(base, exp)\n \n     # We handle x**n separately. This has two purposes: 1) it is much\n     # faster, because we avoid calling evalf on the exponent, and 2) it\n", "occurrence": 2, "normalized_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex 54c5b3f..433106c 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -357,6 +357,10 @@ def evalf_mul(v, prec, options):\n def evalf_pow(v, prec, options):\n     target_prec = prec\n     base, exp = v.args\n+    if exp.is_Float:\n+        from sympy import nsimplify\n+        exp = nsimplify(exp, rational=True)\n+        v = v.func(base, exp)\n     if exp.is_Integer:\n         p = exp.p\n         if not p:\n", "normalized_occurrence": 4}
