{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-9288", "model_patch": "diff --git a/sklearn/cluster/k_means_.py b/sklearn/cluster/k_means_.py\nindex 915d041..814f666 100644\n--- a/sklearn/cluster/k_means_.py\n+++ b/sklearn/cluster/k_means_.py\n@@ -379,15 +379,15 @@ def k_means(X, n_clusters, sample_weight=None, init='k-means++',\n     else:\n         # parallelisation of k-means runs\n         seeds = random_state.randint(np.iinfo(np.int32).max, size=n_init)\n-        results = Parallel(n_jobs=n_jobs, verbose=0)(\n+        results = Parallel(n_jobs=n_jobs, verbose=0, prefer=\"threads\")(\n             delayed(kmeans_single)(X, sample_weight, n_clusters,\n                                    max_iter=max_iter, init=init,\n                                    verbose=verbose, tol=tol,\n                                    precompute_distances=precompute_distances,\n                                    x_squared_norms=x_squared_norms,\n-                                   # Change seed to ensure variety\n-                                   random_state=seed)\n-            for seed in seeds)\n+                                   # Use same seed for reproducibility\n+                                   random_state=random_state)\n+            for _ in range(n_init))\n         # Get results with the lowest inertia\n         labels, inertia, centers, n_iters = zip(*results)\n         best = np.argmin(inertia)\n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/cluster/k_means_.py b/sklearn/cluster/k_means_.py\nindex abcc315..1296925 100644\n--- a/sklearn/cluster/k_means_.py\n+++ b/sklearn/cluster/k_means_.py\n@@ -116,7 +116,7 @@ def k_means(X, n_clusters, sample_weight=None, init='k-means++', precompute_dist\n                 best_n_iter = n_iter_\n     else:\n         seeds = random_state.randint(np.iinfo(np.int32).max, size=n_init)\n-        results = Parallel(n_jobs=n_jobs, verbose=0)((delayed(kmeans_single)(X, sample_weight, n_clusters, max_iter=max_iter, init=init, verbose=verbose, tol=tol, precompute_distances=precompute_distances, x_squared_norms=x_squared_norms, random_state=seed) for seed in seeds))\n+        results = Parallel(n_jobs=n_jobs, verbose=0, prefer='threads')((delayed(kmeans_single)(X, sample_weight, n_clusters, max_iter=max_iter, init=init, verbose=verbose, tol=tol, precompute_distances=precompute_distances, x_squared_norms=x_squared_norms, random_state=random_state) for _ in range(n_init)))\n         labels, inertia, centers, n_iters = zip(*results)\n         best = np.argmin(inertia)\n         best_labels = labels[best]\n", "normalized_occurrence": 1}
