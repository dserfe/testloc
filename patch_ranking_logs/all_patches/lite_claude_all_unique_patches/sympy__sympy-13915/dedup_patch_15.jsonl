{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13915", "model_patch": "diff --git a/sympy/core/basic.py b/sympy/core/basic.py\nindex 0977e81..e1fa06d 100644\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -1004,26 +1004,33 @@ class Basic(with_metaclass(ManagedProperties)):\n                 if not hasattr(arg, '_eval_subs'):\n                     continue\n                 arg = arg._subs(old, new, **hints)\n+                if arg is S.NaN:  # If any subexpression is undefined\n+                    return S.NaN\n                 if not _aresame(arg, args[i]):\n                     hit = True\n                     args[i] = arg\n             if hit:\n-                rv = self.func(*args)\n-                hack2 = hints.get('hack2', False)\n-                if hack2 and self.is_Mul and not rv.is_Mul:  # 2-arg hack\n-                    coeff = S.One\n-                    nonnumber = []\n-                    for i in args:\n-                        if i.is_Number:\n-                            coeff *= i\n+                try:\n+                    rv = self.func(*args)\n+                    if rv.has(S.NaN, S.ComplexInfinity):  # Check if result contains undefined values\n+                        return S.NaN\n+                    hack2 = hints.get('hack2', False)\n+                    if hack2 and self.is_Mul and not rv.is_Mul:  # 2-arg hack\n+                        coeff = S.One\n+                        nonnumber = []\n+                        for i in args:\n+                            if i.is_Number:\n+                                coeff *= i\n+                            else:\n+                                nonnumber.append(i)\n+                        nonnumber = self.func(*nonnumber)\n+                        if coeff is S.One:\n+                            return nonnumber\n                         else:\n-                            nonnumber.append(i)\n-                    nonnumber = self.func(*nonnumber)\n-                    if coeff is S.One:\n-                        return nonnumber\n-                    else:\n-                        return self.func(coeff, nonnumber, evaluate=False)\n-                return rv\n+                            return self.func(coeff, nonnumber, evaluate=False)\n+                    return rv\n+                except ZeroDivisionError:  # Handle explicit division by zero\n+                    return S.NaN\n             return self\n \n         if _aresame(self, old):\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/basic.py b/sympy/core/basic.py\nindex 782db85..04cf867 100644\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -339,26 +339,33 @@ class Basic(with_metaclass(ManagedProperties)):\n                 if not hasattr(arg, '_eval_subs'):\n                     continue\n                 arg = arg._subs(old, new, **hints)\n+                if arg is S.NaN:\n+                    return S.NaN\n                 if not _aresame(arg, args[i]):\n                     hit = True\n                     args[i] = arg\n             if hit:\n-                rv = self.func(*args)\n-                hack2 = hints.get('hack2', False)\n-                if hack2 and self.is_Mul and (not rv.is_Mul):\n-                    coeff = S.One\n-                    nonnumber = []\n-                    for i in args:\n-                        if i.is_Number:\n-                            coeff *= i\n+                try:\n+                    rv = self.func(*args)\n+                    if rv.has(S.NaN, S.ComplexInfinity):\n+                        return S.NaN\n+                    hack2 = hints.get('hack2', False)\n+                    if hack2 and self.is_Mul and (not rv.is_Mul):\n+                        coeff = S.One\n+                        nonnumber = []\n+                        for i in args:\n+                            if i.is_Number:\n+                                coeff *= i\n+                            else:\n+                                nonnumber.append(i)\n+                        nonnumber = self.func(*nonnumber)\n+                        if coeff is S.One:\n+                            return nonnumber\n                         else:\n-                            nonnumber.append(i)\n-                    nonnumber = self.func(*nonnumber)\n-                    if coeff is S.One:\n-                        return nonnumber\n-                    else:\n-                        return self.func(coeff, nonnumber, evaluate=False)\n-                return rv\n+                            return self.func(coeff, nonnumber, evaluate=False)\n+                    return rv\n+                except ZeroDivisionError:\n+                    return S.NaN\n             return self\n         if _aresame(self, old):\n             return new\n", "normalized_occurrence": 1}
