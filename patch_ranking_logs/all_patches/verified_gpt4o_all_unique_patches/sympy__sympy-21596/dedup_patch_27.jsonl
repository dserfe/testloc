{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-21596", "model_patch": "diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex 78d756e..ce31240 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -338,6 +338,10 @@ class Set(Basic, EvalfMixin):\n         return b\n \n     def _contains(self, other):\n+        from sympy import I, re, im\n+        from sympy.sets.sets import Reals\n+        if isinstance(other, (int, float)):\n+            return And(Equal(im(other), 0), Contains(re(other), self))\n         raise NotImplementedError(filldedent('''\n             (%s)._contains(%s) is not defined. This method, when\n             defined, will receive a sympified object. The method\n@@ -389,11 +393,10 @@ class Set(Basic, EvalfMixin):\n         if ret is not None:\n             return ret\n \n-        # Fall back on computing the intersection\n-        # XXX: We shouldn't do this. A query like this should be handled\n-        # without evaluating new Set objects. It should be the other way round\n-        # so that the intersect method uses is_subset for evaluation.\n-        if self.intersect(other) == self:\n+        # Intersect and check if the intersection is the same as self.\n+        # This handles cases where the sets might have complex numbers.\n+        intersection = self.intersect(other)\n+        if intersection == self and intersection.is_subset(Reals):\n             return True\n \n     def _eval_is_subset(self, other):\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex 09f6d6f..baddadc 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -114,6 +114,10 @@ class Set(Basic, EvalfMixin):\n             return c\n         return b\n     def _contains(self, other):\n+        from sympy import I, re, im\n+        from sympy.sets.sets import Reals\n+        if isinstance(other, (int, float)):\n+            return And(Equal(im(other), 0), Contains(re(other), self))\n         raise NotImplementedError(filldedent('\\n            (%s)._contains(%s) is not defined. This method, when\\n            defined, will receive a sympified object. The method\\n            should return True, False, None or something that\\n            expresses what must be true for the containment of that\\n            object in self to be evaluated. If None is returned\\n            then a generic Contains object will be returned\\n            by the ``contains`` method.' % (self, other)))\n     def is_subset(self, other):\n         if not isinstance(other, Set):\n@@ -137,7 +141,8 @@ class Set(Basic, EvalfMixin):\n         ret = is_subset_sets(self, other)\n         if ret is not None:\n             return ret\n-        if self.intersect(other) == self:\n+        intersection = self.intersect(other)\n+        if intersection == self and intersection.is_subset(Reals):\n             return True\n     def _eval_is_subset(self, other):\n         return None\n", "normalized_occurrence": 1}
