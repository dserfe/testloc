{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13779", "model_patch": "diff --git a/sklearn/ensemble/voting.py b/sklearn/ensemble/voting.py\nindex 858d868..48e22cb 100644\n--- a/sklearn/ensemble/voting.py\n+++ b/sklearn/ensemble/voting.py\n@@ -29,6 +29,8 @@ from ..utils import Bunch\n \n def _parallel_fit_estimator(estimator, X, y, sample_weight=None):\n     \"\"\"Private function used to fit an estimator within a job.\"\"\"\n+    if estimator is None:\n+        return None\n     if sample_weight is not None:\n         estimator.fit(X, y, sample_weight=sample_weight)\n     else:\n@@ -76,16 +78,10 @@ class _BaseVoting(_BaseComposition, TransformerMixin):\n                              '; got %d weights, %d estimators'\n                              % (len(self.weights), len(self.estimators)))\n \n-        if sample_weight is not None:\n-            for name, step in self.estimators:\n-                if not has_fit_parameter(step, 'sample_weight'):\n-                    raise ValueError('Underlying estimator \\'%s\\' does not'\n-                                     ' support sample weights.' % name)\n-\n-        names, clfs = zip(*self.estimators)\n+        names, clfs = zip(*valid_estimators)\n         self._validate_names(names)\n \n-        n_isnone = np.sum([clf is None for _, clf in self.estimators])\n+        n_isnone = np.sum([clf is None for _, clf in valid_estimators])\n         if n_isnone == len(self.estimators):\n             raise ValueError('All estimators are None. At least one is '\n                              'required!')\n", "occurrence": 1, "normalized_patch": "diff --git a/sklearn/ensemble/voting.py b/sklearn/ensemble/voting.py\nindex c17361f..3cac97e 100644\n--- a/sklearn/ensemble/voting.py\n+++ b/sklearn/ensemble/voting.py\n@@ -10,6 +10,8 @@ from ..utils.validation import has_fit_parameter, check_is_fitted\n from ..utils.metaestimators import _BaseComposition\n from ..utils import Bunch\n def _parallel_fit_estimator(estimator, X, y, sample_weight=None):\n+    if estimator is None:\n+        return None\n     if sample_weight is not None:\n         estimator.fit(X, y, sample_weight=sample_weight)\n     else:\n@@ -33,13 +35,9 @@ class _BaseVoting(_BaseComposition, TransformerMixin):\n             raise AttributeError('Invalid `estimators` attribute, `estimators` should be a list of (string, estimator) tuples')\n         if self.weights is not None and len(self.weights) != len(self.estimators):\n             raise ValueError('Number of `estimators` and weights must be equal; got %d weights, %d estimators' % (len(self.weights), len(self.estimators)))\n-        if sample_weight is not None:\n-            for name, step in self.estimators:\n-                if not has_fit_parameter(step, 'sample_weight'):\n-                    raise ValueError(\"Underlying estimator '%s' does not support sample weights.\" % name)\n-        names, clfs = zip(*self.estimators)\n+        names, clfs = zip(*valid_estimators)\n         self._validate_names(names)\n-        n_isnone = np.sum([clf is None for _, clf in self.estimators])\n+        n_isnone = np.sum([clf is None for _, clf in valid_estimators])\n         if n_isnone == len(self.estimators):\n             raise ValueError('All estimators are None. At least one is required!')\n         self.estimators_ = Parallel(n_jobs=self.n_jobs)((delayed(_parallel_fit_estimator)(clone(clf), X, y, sample_weight=sample_weight) for clf in clfs if clf is not None))\n", "normalized_occurrence": 1}
