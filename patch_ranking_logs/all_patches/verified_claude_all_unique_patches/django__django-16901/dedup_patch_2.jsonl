{"model_name_or_path": "agentless_claude", "instance_id": "django__django-16901", "model_patch": "diff --git a/django/db/backends/base/operations.py b/django/db/backends/base/operations.py\nindex 5801e03..249dfae 100644\n--- a/django/db/backends/base/operations.py\n+++ b/django/db/backends/base/operations.py\n@@ -668,8 +668,23 @@ class BaseDatabaseOperations:\n         can vary between backends (e.g., Oracle with %% and &) and between\n         subexpression types (e.g., date expressions).\n         \"\"\"\n-        conn = \" %s \" % connector\n-        return conn.join(sub_expressions)\n+        if connector == '^' and len(sub_expressions) > 2:\n+            # For XOR with more than 2 expressions, we need to ensure odd number of true values\n+            # Build this as: (a <> b) OR ((a = b) AND c) for 3 expressions\n+            # This gives us the correct odd-number-of-trues behavior\n+            result = []\n+            first = sub_expressions[0]\n+            for i, expr in enumerate(sub_expressions[1:], 1):\n+                if i == 1:\n+                    # First pair uses <>\n+                    result.append(f\"({first} <> {expr})\")\n+                else:\n+                    # Additional terms use: AND previous_result = next_term\n+                    result.append(f\"(({' = '.join(sub_expressions[:i])}) AND {expr})\")\n+            return ' OR '.join(result)\n+        else:\n+            conn = \" %s \" % connector\n+            return conn.join(sub_expressions)\n \n     def combine_duration_expression(self, connector, sub_expressions):\n         return self.combine_expression(connector, sub_expressions)\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/backends/base/operations.py b/django/db/backends/base/operations.py\nindex ba948a6..496c6e5 100644\n--- a/django/db/backends/base/operations.py\n+++ b/django/db/backends/base/operations.py\n@@ -215,8 +215,18 @@ class BaseDatabaseOperations:\n     def conditional_expression_supported_in_where_clause(self, expression):\n         return True\n     def combine_expression(self, connector, sub_expressions):\n-        conn = ' %s ' % connector\n-        return conn.join(sub_expressions)\n+        if connector == '^' and len(sub_expressions) > 2:\n+            result = []\n+            first = sub_expressions[0]\n+            for i, expr in enumerate(sub_expressions[1:], 1):\n+                if i == 1:\n+                    result.append(f'({first} <> {expr})')\n+                else:\n+                    result.append(f\"(({' = '.join(sub_expressions[:i])}) AND {expr})\")\n+            return ' OR '.join(result)\n+        else:\n+            conn = ' %s ' % connector\n+            return conn.join(sub_expressions)\n     def combine_duration_expression(self, connector, sub_expressions):\n         return self.combine_expression(connector, sub_expressions)\n     def binary_placeholder_sql(self, value):\n", "normalized_occurrence": 1}
