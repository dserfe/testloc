{"model_name_or_path": "agentless_claude", "instance_id": "pylint-dev__pylint-7114", "model_patch": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex a7d6e52..2e54102 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -16,7 +16,12 @@ from pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict\n \n def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n     def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n-        return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n+        # A path is a package if it either:\n+        # 1. Has an __init__.py (traditional package)\n+        # 2. Is marked as a namespace package\n+        if is_namespace:\n+            return True\n+        return modutils.check_modpath_has_init(inner_path, parts)\n \n     return modutils.modpath_from_file_with_callback(\n         filename, path=path, is_package_cb=_is_package_cb\n@@ -24,10 +29,10 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n \n \n def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n+    \"\"\"Get the python path for the given filepath.\n \n-    This is not true since python 3.3 and is causing problem.\n+    Handles both traditional packages (with __init__.py) and namespace packages\n+    (without __init__.py, as per PEP 420).\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n", "occurrence": 1, "normalized_patch": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex a1d3fbd..31ed2eb 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -7,7 +7,9 @@ from astroid import modutils\n from pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict\n def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n     def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n-        return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n+        if is_namespace:\n+            return True\n+        return modutils.check_modpath_has_init(inner_path, parts)\n     return modutils.modpath_from_file_with_callback(filename, path=path, is_package_cb=_is_package_cb)\n def get_python_path(filepath: str) -> str:\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n", "normalized_occurrence": 2}
