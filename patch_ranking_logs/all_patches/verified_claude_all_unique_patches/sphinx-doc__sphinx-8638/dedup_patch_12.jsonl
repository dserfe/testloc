{"model_name_or_path": "agentless_claude", "instance_id": "sphinx-doc__sphinx-8638", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex ec7a051..65bbeae 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -773,6 +773,11 @@ class PyDecoratorMethod(PyMethod):\n class PyAttribute(PyObject):\n     \"\"\"Description of an attribute.\"\"\"\n \n+    def _is_instance_var(self) -> bool:\n+        \"\"\"Check if this is an instance variable based on context.\"\"\"\n+        return (hasattr(self, 'objtype') and self.objtype == 'attribute' and\n+                hasattr(self, '_datadescriptor') and not self._datadescriptor)\n+\n     option_spec = PyObject.option_spec.copy()\n     option_spec.update({\n         'type': directives.unchanged,\n@@ -791,6 +796,10 @@ class PyAttribute(PyObject):\n         if value:\n             signode += addnodes.desc_annotation(value, ' = ' + value)\n \n+        # Add instance variable marker if applicable\n+        if self._is_instance_var():\n+            signode['instance_var'] = True\n+\n         return fullname, prefix\n \n     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n@@ -805,7 +814,11 @@ class PyAttribute(PyObject):\n             else:\n                 return name\n \n-        return _('%s (%s attribute)') % (attrname, clsname)\n+        # Add instance variable indicator to prevent cross-linking\n+        if self._is_instance_var():\n+            return _('%s (%s instance attribute)') % (attrname, clsname)\n+        else:\n+            return _('%s (%s attribute)') % (attrname, clsname)\n \n \n class PyDecoratorMixin:\n", "occurrence": 1, "normalized_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 06b9e34..b3b440d 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -476,6 +476,8 @@ class PyDecoratorMethod(PyMethod):\n     def needs_arglist(self) -> bool:\n         return False\n class PyAttribute(PyObject):\n+    def _is_instance_var(self) -> bool:\n+        return hasattr(self, 'objtype') and self.objtype == 'attribute' and hasattr(self, '_datadescriptor') and (not self._datadescriptor)\n     option_spec = PyObject.option_spec.copy()\n     option_spec.update({'type': directives.unchanged, 'value': directives.unchanged})\n     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n@@ -487,6 +489,8 @@ class PyAttribute(PyObject):\n         value = self.options.get('value')\n         if value:\n             signode += addnodes.desc_annotation(value, ' = ' + value)\n+        if self._is_instance_var():\n+            signode['instance_var'] = True\n         return (fullname, prefix)\n     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n         name, cls = name_cls\n@@ -499,7 +503,10 @@ class PyAttribute(PyObject):\n                 return _('%s (in module %s)') % (name, modname)\n             else:\n                 return name\n-        return _('%s (%s attribute)') % (attrname, clsname)\n+        if self._is_instance_var():\n+            return _('%s (%s instance attribute)') % (attrname, clsname)\n+        else:\n+            return _('%s (%s attribute)') % (attrname, clsname)\n class PyDecoratorMixin:\n     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n         for cls in self.__class__.__mro__:\n", "normalized_occurrence": 1}
