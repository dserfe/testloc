diff --git a/sympy/matrices/normalforms.py b/sympy/matrices/normalforms.py
index d5302ed..db3d655 100644
--- a/sympy/matrices/normalforms.py
+++ b/sympy/matrices/normalforms.py
@@ -67,61 +67,11 @@ def invariant_factors(m, domain=None):
     return factors
 
 
-def hermite_normal_form(A, *, D=None, check_rank=False):
-    r"""
-    Compute the Hermite Normal Form of a Matrix *A* of integers.
 
-    Examples
-    ========
-
-    >>> from sympy import Matrix
-    >>> from sympy.matrices.normalforms import hermite_normal_form
-    >>> m = Matrix([[12, 6, 4], [3, 9, 6], [2, 16, 14]])
-    >>> print(hermite_normal_form(m))
-    Matrix([[10, 0, 2], [0, 15, 3], [0, 0, 2]])
-
-    Parameters
-    ==========
-
-    A : $m \times n$ ``Matrix`` of integers.
-
-    D : int, optional
-        Let $W$ be the HNF of *A*. If known in advance, a positive integer *D*
-        being any multiple of $\det(W)$ may be provided. In this case, if *A*
-        also has rank $m$, then we may use an alternative algorithm that works
-        mod *D* in order to prevent coefficient explosion.
-
-    check_rank : boolean, optional (default=False)
-        The basic assumption is that, if you pass a value for *D*, then
-        you already believe that *A* has rank $m$, so we do not waste time
-        checking it for you. If you do want this to be checked (and the
-        ordinary, non-modulo *D* algorithm to be used if the check fails), then
-        set *check_rank* to ``True``.
-
-    Returns
-    =======
-
-    ``Matrix``
-        The HNF of matrix *A*.
-
-    Raises
-    ======
-
-    DMDomainError
-        If the domain of the matrix is not :ref:`ZZ`.
-
-    DMShapeError
-        If the mod *D* algorithm is used but the matrix has more rows than
-        columns.
-
-    References
-    ==========
-
-    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*
-       (See Algorithms 2.4.5 and 2.4.8.)
-
-    """
     # Accept any of Python int, SymPy Integer, and ZZ itself:
     if D is not None and not ZZ.of_type(D):
         D = ZZ(int(D))
-    return _hnf(A._rep, D=D, check_rank=check_rank).to_Matrix()
+    # Force check_rank=False when using transpose method to avoid row removal
+    if isinstance(A._rep, DomainMatrix) and A._rep.shape[0] < A._rep.shape[1]:
+        check_rank = False
+    return _hnf(A._rep, D=D, check_rank=check_rank).to_Matrix()
