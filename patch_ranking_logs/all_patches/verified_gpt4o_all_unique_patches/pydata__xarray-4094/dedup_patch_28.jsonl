{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4094", "model_patch": "diff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 7838e8d..93d8022 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -1469,13 +1469,17 @@ class Variable(\n                 \"equal the size of the old dimension\"\n             )\n \n-        other_dims = [d for d in self.dims if d != old_dim]\n-        dim_order = other_dims + [old_dim]\n-        reordered = self.transpose(*dim_order)\n+        if len(self.dims) == 1 and old_dim == self.dims[0]:\n+            new_data = self.data.reshape(new_dim_sizes)\n+            new_dims = new_dim_names\n+        else:\n+            other_dims = [d for d in self.dims if d != old_dim]\n+            dim_order = other_dims + [old_dim]\n+            reordered = self.transpose(*dim_order)\n \n-        new_shape = reordered.shape[: len(other_dims)] + new_dim_sizes\n-        new_data = reordered.data.reshape(new_shape)\n-        new_dims = reordered.dims[: len(other_dims)] + new_dim_names\n+            new_shape = reordered.shape[: len(other_dims)] + new_dim_sizes\n+            new_data = reordered.data.reshape(new_shape)\n+            new_dims = reordered.dims[: len(other_dims)] + new_dim_names\n \n         return Variable(new_dims, new_data, self._attrs, self._encoding, fastpath=True)\n \n", "occurrence": 1, "normalized_patch": "diff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 44b3a8e..013a526 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -1115,12 +1115,16 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic, utils.NdimSi\n             raise ValueError('cannot create a new dimension with the same name as an existing dimension')\n         if np.prod(new_dim_sizes) != self.sizes[old_dim]:\n             raise ValueError('the product of the new dimension sizes must equal the size of the old dimension')\n-        other_dims = [d for d in self.dims if d != old_dim]\n-        dim_order = other_dims + [old_dim]\n-        reordered = self.transpose(*dim_order)\n-        new_shape = reordered.shape[:len(other_dims)] + new_dim_sizes\n-        new_data = reordered.data.reshape(new_shape)\n-        new_dims = reordered.dims[:len(other_dims)] + new_dim_names\n+        if len(self.dims) == 1 and old_dim == self.dims[0]:\n+            new_data = self.data.reshape(new_dim_sizes)\n+            new_dims = new_dim_names\n+        else:\n+            other_dims = [d for d in self.dims if d != old_dim]\n+            dim_order = other_dims + [old_dim]\n+            reordered = self.transpose(*dim_order)\n+            new_shape = reordered.shape[:len(other_dims)] + new_dim_sizes\n+            new_data = reordered.data.reshape(new_shape)\n+            new_dims = reordered.dims[:len(other_dims)] + new_dim_names\n         return Variable(new_dims, new_data, self._attrs, self._encoding, fastpath=True)\n \n     def unstack(self, dimensions=None, **dimensions_kwargs):\n", "normalized_occurrence": 1}
