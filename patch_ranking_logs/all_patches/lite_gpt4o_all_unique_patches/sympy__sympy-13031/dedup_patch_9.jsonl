{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13031", "model_patch": "diff --git a/sympy/matrices/dense.py b/sympy/matrices/dense.py\nindex 7b0ad01..7fd5567 100644\n--- a/sympy/matrices/dense.py\n+++ b/sympy/matrices/dense.py\n@@ -170,29 +170,32 @@ class DenseMatrix(MatrixBase):\n         new_mat_cols = other.cols\n \n         # preallocate the array\n-        new_mat = [S.Zero]*new_mat_rows*new_mat_cols\n-\n-        # if we multiply an n x 0 with a 0 x m, the\n-        # expected behavior is to produce an n x m matrix of zeros\n-        if self.cols != 0 and other.rows != 0:\n-            # cache self._mat and other._mat for performance\n-            mat = self._mat\n-            other_mat = other._mat\n-            for i in range(len(new_mat)):\n-                row, col = i // new_mat_cols, i % new_mat_cols\n-                row_indices = range(self_cols*row, self_cols*(row+1))\n-                col_indices = range(col, other_len, other_cols)\n-                vec = (mat[a]*other_mat[b] for a,b in zip(row_indices, col_indices))\n-                try:\n-                    new_mat[i] = Add(*vec)\n-                except (TypeError, SympifyError):\n-                    # Block matrices don't work with `sum` or `Add` (ISSUE #11599)\n-                    # They don't work with `sum` because `sum` tries to add `0`\n-                    # initially, and for a matrix, that is a mix of a scalar and\n-                    # a matrix, which raises a TypeError. Fall back to a\n-                    # block-matrix-safe way to multiply if the `sum` fails.\n+        if self.rows == 0:\n+            new_mat = [S.Zero]*self.rows*sum(m.shape[1] for m in args)\n+        else:\n+            new_mat = [S.Zero]*new_mat_rows*new_mat_cols\n+\n+            # if we multiply an n x 0 with a 0 x m, the\n+            # expected behavior is to produce an n x m matrix of zeros\n+            if self.cols != 0 and other.rows != 0:\n+                # cache self._mat and other._mat for performance\n+                mat = self._mat\n+                other_mat = other._mat\n+                for i in range(len(new_mat)):\n+                    row, col = i // new_mat_cols, i % new_mat_cols\n+                    row_indices = range(self_cols*row, self_cols*(row+1))\n+                    col_indices = range(col, other_len, other_cols)\n                     vec = (mat[a]*other_mat[b] for a,b in zip(row_indices, col_indices))\n-                    new_mat[i] = reduce(lambda a,b: a + b, vec)\n+                    try:\n+                        new_mat[i] = Add(*vec)\n+                    except (TypeError, SympifyError):\n+                        # Block matrices don't work with `sum` or `Add` (ISSUE #11599)\n+                        # They don't work with `sum` because `sum` tries to add `0`\n+                        # initially, and for a matrix, that is a mix of a scalar and\n+                        # a matrix, which raises a TypeError. Fall back to a\n+                        # block-matrix-safe way to multiply if the `sum` fails.\n+                        vec = (mat[a]*other_mat[b] for a,b in zip(row_indices, col_indices))\n+                        new_mat[i] = reduce(lambda a,b: a + b, vec)\n         return classof(self, other)._new(new_mat_rows, new_mat_cols, new_mat, copy=False)\n \n     def _eval_matrix_mul_elementwise(self, other):\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/matrices/dense.py b/sympy/matrices/dense.py\nindex edd691e..e108cc0 100644\n--- a/sympy/matrices/dense.py\n+++ b/sympy/matrices/dense.py\n@@ -91,20 +91,23 @@ class DenseMatrix(MatrixBase):\n         other_len = other_rows * other_cols\n         new_mat_rows = self.rows\n         new_mat_cols = other.cols\n-        new_mat = [S.Zero] * new_mat_rows * new_mat_cols\n-        if self.cols != 0 and other.rows != 0:\n-            mat = self._mat\n-            other_mat = other._mat\n-            for i in range(len(new_mat)):\n-                row, col = (i // new_mat_cols, i % new_mat_cols)\n-                row_indices = range(self_cols * row, self_cols * (row + 1))\n-                col_indices = range(col, other_len, other_cols)\n-                vec = (mat[a] * other_mat[b] for a, b in zip(row_indices, col_indices))\n-                try:\n-                    new_mat[i] = Add(*vec)\n-                except (TypeError, SympifyError):\n+        if self.rows == 0:\n+            new_mat = [S.Zero] * self.rows * sum((m.shape[1] for m in args))\n+        else:\n+            new_mat = [S.Zero] * new_mat_rows * new_mat_cols\n+            if self.cols != 0 and other.rows != 0:\n+                mat = self._mat\n+                other_mat = other._mat\n+                for i in range(len(new_mat)):\n+                    row, col = (i // new_mat_cols, i % new_mat_cols)\n+                    row_indices = range(self_cols * row, self_cols * (row + 1))\n+                    col_indices = range(col, other_len, other_cols)\n                     vec = (mat[a] * other_mat[b] for a, b in zip(row_indices, col_indices))\n-                    new_mat[i] = reduce(lambda a, b: a + b, vec)\n+                    try:\n+                        new_mat[i] = Add(*vec)\n+                    except (TypeError, SympifyError):\n+                        vec = (mat[a] * other_mat[b] for a, b in zip(row_indices, col_indices))\n+                        new_mat[i] = reduce(lambda a, b: a + b, vec)\n         return classof(self, other)._new(new_mat_rows, new_mat_cols, new_mat, copy=False)\n     def _eval_matrix_mul_elementwise(self, other):\n         mat = [a * b for a, b in zip(self._mat, other._mat)]\n", "normalized_occurrence": 1}
