{"model_name_or_path": "agentless", "instance_id": "django__django-11740", "model_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 816737e..7d4a98e 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -101,6 +101,18 @@ class MigrationAutodetector:\n         return fields_def\n \n     def _detect_changes(self, convert_apps=None, graph=None):\n+        def generate_dependencies(self):\n+            \"\"\"\n+            Generate dependencies for foreign keys.\n+            \"\"\"\n+            for al, mn in sorted(self.kept_model_keys):\n+                old_model_state = self.from_state.models[(al, mn)]\n+                new_model_state = self.to_state.models[(al, mn)]\n+                for field in new_model_state.fields.values():\n+                    if field.remote_field and field.remote_field.model:\n+                        dep_app_label = field.remote_field.model._meta.app_label\n+                        dep_model_name = field.remote_field.model._meta.model_name\n+                        self.add_dependency(dep_app_label, dep_model_name)\n         \"\"\"\n         Return a dict of migration plans which will achieve the\n         change from from_state to to_state. The dict has app labels\n@@ -180,6 +192,7 @@ class MigrationAutodetector:\n         self.generate_removed_constraints()\n         self.generate_removed_indexes()\n         # Generate field operations\n+        self.generate_dependencies()\n         self.generate_renamed_fields()\n         self.generate_removed_fields()\n         self.generate_added_fields()\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 9fda64b..a8f6eff 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -52,6 +52,16 @@ class MigrationAutodetector:\n             fields_def.append(deconstruction)\n         return fields_def\n     def _detect_changes(self, convert_apps=None, graph=None):\n+        def generate_dependencies(self):\n+            for al, mn in sorted(self.kept_model_keys):\n+                old_model_state = self.from_state.models[al, mn]\n+                new_model_state = self.to_state.models[al, mn]\n+                for field in new_model_state.fields.values():\n+                    if field.remote_field and field.remote_field.model:\n+                        dep_app_label = field.remote_field.model._meta.app_label\n+                        dep_model_name = field.remote_field.model._meta.model_name\n+                        self.add_dependency(dep_app_label, dep_model_name)\n+        \"\\n        Return a dict of migration plans which will achieve the\\n        change from from_state to to_state. The dict has app labels\\n        as keys and a list of migrations as values.\\n\\n        The resulting migrations aren't specially named, but the names\\n        do matter for dependencies inside the set.\\n\\n        convert_apps is the list of apps to convert to use migrations\\n        (i.e. to make initial migrations for, in the usual case)\\n\\n        graph is an optional argument that, if provided, can help improve\\n        dependency generation and avoid potential circular dependencies.\\n        \"\n         self.generated_operations = {}\n         self.altered_indexes = {}\n         self.altered_constraints = {}\n@@ -94,6 +104,7 @@ class MigrationAutodetector:\n         self.create_altered_constraints()\n         self.generate_removed_constraints()\n         self.generate_removed_indexes()\n+        self.generate_dependencies()\n         self.generate_renamed_fields()\n         self.generate_removed_fields()\n         self.generate_added_fields()\n", "normalized_occurrence": 1}
