{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-23824", "model_patch": "diff --git a/sympy/physics/hep/gamma_matrices.py b/sympy/physics/hep/gamma_matrices.py\nindex 8ce17be..8d1d100 100644\n--- a/sympy/physics/hep/gamma_matrices.py\n+++ b/sympy/physics/hep/gamma_matrices.py\n@@ -692,9 +692,9 @@ def kahane_simplify(expression):\n     # power of two factor, as described in Kahane's paper:\n     resulting_coeff *= 2**(number_of_contractions)\n \n-    # If `first_dum_pos` is not zero, it means that there are trailing free gamma\n+    # If `first_dum_pos` is not zero, it means that there are leading free gamma\n     # matrices in front of `expression`, so multiply by them:\n-    for i in range(0, first_dum_pos):\n+    for i in reversed(range(0, first_dum_pos)):\n         [ri.insert(0, free_pos[i]) for ri in resulting_indices]\n \n     resulting_expr = S.Zero\n@@ -714,4 +714,4 @@ def kahane_simplify(expression):\n         pass\n     else:\n         t = eye(4)*t\n-    return t\n+    return t\n", "occurrence": 2, "normalized_patch": "diff --git a/sympy/physics/hep/gamma_matrices.py b/sympy/physics/hep/gamma_matrices.py\nindex a91f01b..353b646 100644\n--- a/sympy/physics/hep/gamma_matrices.py\n+++ b/sympy/physics/hep/gamma_matrices.py\n@@ -313,7 +313,7 @@ def kahane_simplify(expression):\n             resulting_indices = [expri + ri for ri in resulting_indices for expri in (expr1, expr2)]\n     resulting_coeff *= -1 if (number_of_contractions - connected_components + 1) % 2 else 1\n     resulting_coeff *= 2 ** number_of_contractions\n-    for i in range(0, first_dum_pos):\n+    for i in reversed(range(0, first_dum_pos)):\n         [ri.insert(0, free_pos[i]) for ri in resulting_indices]\n     resulting_expr = S.Zero\n     for i in resulting_indices:\n", "normalized_occurrence": 3}
