{"model_name_or_path": "agentless", "instance_id": "django__django-11149", "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex acc7653..9032b1c 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -2044,58 +2044,61 @@ class InlineModelAdmin(BaseModelAdmin):\n             **kwargs,\n         }\n \n-        base_model_form = defaults['form']\n-        can_change = self.has_change_permission(request, obj) if request else True\n-        can_add = self.has_add_permission(request, obj) if request else True\n-\n-        class DeleteProtectedModelForm(base_model_form):\n-\n-            def hand_clean_DELETE(self):\n-                \"\"\"\n-                We don't validate the 'DELETE' field itself because on\n-                templates it's not rendered using the field information, but\n-                just using a generic \"deletion_field\" of the InlineModelAdmin.\n-                \"\"\"\n-                if self.cleaned_data.get(DELETION_FIELD_NAME, False):\n-                    using = router.db_for_write(self._meta.model)\n-                    collector = NestedObjects(using=using)\n-                    if self.instance._state.adding:\n-                        return\n-                    collector.collect([self.instance])\n-                    if collector.protected:\n-                        objs = []\n-                        for p in collector.protected:\n-                            objs.append(\n-                                # Translators: Model verbose name and instance representation,\n-                                # suitable to be an item in a list.\n-                                _('%(class_name)s %(instance)s') % {\n-                                    'class_name': p._meta.verbose_name,\n-                                    'instance': p}\n-                            )\n-                        params = {\n-                            'class_name': self._meta.model._meta.verbose_name,\n-                            'instance': self.instance,\n-                            'related_objects': get_text_list(objs, _('and')),\n-                        }\n-                        msg = _(\"Deleting %(class_name)s %(instance)s would require \"\n-                                \"deleting the following protected related objects: \"\n-                                \"%(related_objects)s\")\n-                        raise ValidationError(msg, code='deleting_protected', params=params)\n-\n-            def is_valid(self):\n-                result = super().is_valid()\n-                self.hand_clean_DELETE()\n-                return result\n-\n-            def has_changed(self):\n-                # Protect against unauthorized edits.\n-                if not can_change and not self.instance._state.adding:\n-                    return False\n-                if not can_add and self.instance._state.adding:\n-                    return False\n-                return super().has_changed()\n-\n-        defaults['form'] = DeleteProtectedModelForm\n+        if not self.has_change_permission(request, obj):\n+            defaults['form'] = readonly_inlineformset_factory(self.parent_model, self.model, **defaults)\n+        else:\n+            base_model_form = defaults['form']\n+            can_change = self.has_change_permission(request, obj) if request else True\n+            can_add = self.has_add_permission(request, obj) if request else True\n+\n+            class DeleteProtectedModelForm(base_model_form):\n+\n+                def hand_clean_DELETE(self):\n+                    \"\"\"\n+                    We don't validate the 'DELETE' field itself because on\n+                    templates it's not rendered using the field information, but\n+                    just using a generic \"deletion_field\" of the InlineModelAdmin.\n+                    \"\"\"\n+                    if self.cleaned_data.get(DELETION_FIELD_NAME, False):\n+                        using = router.db_for_write(self._meta.model)\n+                        collector = NestedObjects(using=using)\n+                        if self.instance._state.adding:\n+                            return\n+                        collector.collect([self.instance])\n+                        if collector.protected:\n+                            objs = []\n+                            for p in collector.protected:\n+                                objs.append(\n+                                    # Translators: Model verbose name and instance representation,\n+                                    # suitable to be an item in a list.\n+                                    _('%(class_name)s %(instance)s') % {\n+                                        'class_name': p._meta.verbose_name,\n+                                        'instance': p}\n+                                )\n+                            params = {\n+                                'class_name': self._meta.model._meta.verbose_name,\n+                                'instance': self.instance,\n+                                'related_objects': get_text_list(objs, _('and')),\n+                            }\n+                            msg = _(\"Deleting %(class_name)s %(instance)s would require \"\n+                                    \"deleting the following protected related objects: \"\n+                                    \"%(related_objects)s\")\n+                            raise ValidationError(msg, code='deleting_protected', params=params)\n+\n+                def is_valid(self):\n+                    result = super().is_valid()\n+                    self.hand_clean_DELETE()\n+                    return result\n+\n+                def has_changed(self):\n+                    # Protect against unauthorized edits.\n+                    if not can_change and not self.instance._state.adding:\n+                        return False\n+                    if not can_add and self.instance._state.adding:\n+                        return False\n+                    return super().has_changed()\n+\n+            defaults['form'] = DeleteProtectedModelForm\n \n         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):\n             defaults['fields'] = forms.ALL_FIELDS\n", "occurrence": 1, "normalized_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex b043b1a..f932d85 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -1001,35 +1001,38 @@ class InlineModelAdmin(BaseModelAdmin):\n         exclude = exclude or None\n         can_delete = self.can_delete and self.has_delete_permission(request, obj)\n         defaults = {'form': self.form, 'formset': self.formset, 'fk_name': self.fk_name, 'fields': fields, 'exclude': exclude, 'formfield_callback': partial(self.formfield_for_dbfield, request=request), 'extra': self.get_extra(request, obj, **kwargs), 'min_num': self.get_min_num(request, obj, **kwargs), 'max_num': self.get_max_num(request, obj, **kwargs), 'can_delete': can_delete, **kwargs}\n-        base_model_form = defaults['form']\n-        can_change = self.has_change_permission(request, obj) if request else True\n-        can_add = self.has_add_permission(request, obj) if request else True\n-        class DeleteProtectedModelForm(base_model_form):\n-            def hand_clean_DELETE(self):\n-                if self.cleaned_data.get(DELETION_FIELD_NAME, False):\n-                    using = router.db_for_write(self._meta.model)\n-                    collector = NestedObjects(using=using)\n-                    if self.instance._state.adding:\n-                        return\n-                    collector.collect([self.instance])\n-                    if collector.protected:\n-                        objs = []\n-                        for p in collector.protected:\n-                            objs.append(_('%(class_name)s %(instance)s') % {'class_name': p._meta.verbose_name, 'instance': p})\n-                        params = {'class_name': self._meta.model._meta.verbose_name, 'instance': self.instance, 'related_objects': get_text_list(objs, _('and'))}\n-                        msg = _('Deleting %(class_name)s %(instance)s would require deleting the following protected related objects: %(related_objects)s')\n-                        raise ValidationError(msg, code='deleting_protected', params=params)\n-            def is_valid(self):\n-                result = super().is_valid()\n-                self.hand_clean_DELETE()\n-                return result\n-            def has_changed(self):\n-                if not can_change and (not self.instance._state.adding):\n-                    return False\n-                if not can_add and self.instance._state.adding:\n-                    return False\n-                return super().has_changed()\n-        defaults['form'] = DeleteProtectedModelForm\n+        if not self.has_change_permission(request, obj):\n+            defaults['form'] = readonly_inlineformset_factory(self.parent_model, self.model, **defaults)\n+        else:\n+            base_model_form = defaults['form']\n+            can_change = self.has_change_permission(request, obj) if request else True\n+            can_add = self.has_add_permission(request, obj) if request else True\n+            class DeleteProtectedModelForm(base_model_form):\n+                def hand_clean_DELETE(self):\n+                    if self.cleaned_data.get(DELETION_FIELD_NAME, False):\n+                        using = router.db_for_write(self._meta.model)\n+                        collector = NestedObjects(using=using)\n+                        if self.instance._state.adding:\n+                            return\n+                        collector.collect([self.instance])\n+                        if collector.protected:\n+                            objs = []\n+                            for p in collector.protected:\n+                                objs.append(_('%(class_name)s %(instance)s') % {'class_name': p._meta.verbose_name, 'instance': p})\n+                            params = {'class_name': self._meta.model._meta.verbose_name, 'instance': self.instance, 'related_objects': get_text_list(objs, _('and'))}\n+                            msg = _('Deleting %(class_name)s %(instance)s would require deleting the following protected related objects: %(related_objects)s')\n+                            raise ValidationError(msg, code='deleting_protected', params=params)\n+                def is_valid(self):\n+                    result = super().is_valid()\n+                    self.hand_clean_DELETE()\n+                    return result\n+                def has_changed(self):\n+                    if not can_change and (not self.instance._state.adding):\n+                        return False\n+                    if not can_add and self.instance._state.adding:\n+                        return False\n+                    return super().has_changed()\n+            defaults['form'] = DeleteProtectedModelForm\n         if defaults['fields'] is None and (not modelform_defines_fields(defaults['form'])):\n             defaults['fields'] = forms.ALL_FIELDS\n         return inlineformset_factory(self.parent_model, self.model, **defaults)\n", "normalized_occurrence": 1}
