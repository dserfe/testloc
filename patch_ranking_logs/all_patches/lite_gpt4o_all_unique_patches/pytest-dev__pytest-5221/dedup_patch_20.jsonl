{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-5221", "model_patch": "diff --git a/src/_pytest/terminal.py b/src/_pytest/terminal.py\nindex 400ae0b..0ebff43 100644\n--- a/src/_pytest/terminal.py\n+++ b/src/_pytest/terminal.py\n@@ -620,40 +620,19 @@ class TerminalReporter(object):\n                 for rep in self.stats.get(\"failed\"):\n                     rep.toterminal(self._tw)\n \n-    def _printcollecteditems(self, items):\n-        # to print out items and their parent collectors\n-        # we take care to leave out Instances aka ()\n-        # because later versions are going to get rid of them anyway\n-        if self.config.option.verbose < 0:\n-            if self.config.option.verbose < -1:\n-                counts = {}\n-                for item in items:\n-                    name = item.nodeid.split(\"::\", 1)[0]\n-                    counts[name] = counts.get(name, 0) + 1\n-                for name, count in sorted(counts.items()):\n-                    self._tw.line(\"%s: %d\" % (name, count))\n-            else:\n-                for item in items:\n-                    self._tw.line(item.nodeid)\n-            return\n-        stack = []\n-        indent = \"\"\n+    def _print_fixture(self, fixturedef):\n+        \"\"\"Print fixture information including scope.\"\"\"\n+        self._tw.write(fixturedef.argname)\n+        self._tw.write(\" [scope: %s]\" % fixturedef.scope)\n+        self._tw.line()\n+\n+    def pytest_report_collectionfinish(self, config, startdir, items):\n+        \"\"\"Extend to show fixture scope information.\"\"\"\n         for item in items:\n-            needed_collectors = item.listchain()[1:]  # strip root node\n-            while stack:\n-                if stack == needed_collectors[: len(stack)]:\n-                    break\n-                stack.pop()\n-            for col in needed_collectors[len(stack) :]:\n-                stack.append(col)\n-                if col.name == \"()\":  # Skip Instances.\n-                    continue\n-                indent = (len(stack) - 1) * \"  \"\n-                self._tw.line(\"%s%s\" % (indent, col))\n-                if self.config.option.verbose >= 1:\n-                    if hasattr(col, \"_obj\") and col._obj.__doc__:\n-                        for line in col._obj.__doc__.strip().splitlines():\n-                            self._tw.line(\"%s%s\" % (indent + \"  \", line.strip()))\n+            if hasattr(item, \"_fixturedefs\"):\n+                for fixturedef in item._fixturedefs.values():\n+                    self._print_fixture(fixturedef)\n+        return self.config.hook.pytest_report_header(config=config, startdir=startdir)\n \n     @pytest.hookimpl(hookwrapper=True)\n     def pytest_sessionfinish(self, exitstatus):\n", "occurrence": 1, "normalized_patch": "diff --git a/src/_pytest/terminal.py b/src/_pytest/terminal.py\nindex 17fce8c..e072eba 100644\n--- a/src/_pytest/terminal.py\n+++ b/src/_pytest/terminal.py\n@@ -396,37 +396,16 @@ class TerminalReporter(object):\n                 self._tw.sep('!', 'collection failures')\n                 for rep in self.stats.get('failed'):\n                     rep.toterminal(self._tw)\n-    def _printcollecteditems(self, items):\n-        if self.config.option.verbose < 0:\n-            if self.config.option.verbose < -1:\n-                counts = {}\n-                for item in items:\n-                    name = item.nodeid.split('::', 1)[0]\n-                    counts[name] = counts.get(name, 0) + 1\n-                for name, count in sorted(counts.items()):\n-                    self._tw.line('%s: %d' % (name, count))\n-            else:\n-                for item in items:\n-                    self._tw.line(item.nodeid)\n-            return\n-        stack = []\n-        indent = ''\n+    def _print_fixture(self, fixturedef):\n+        self._tw.write(fixturedef.argname)\n+        self._tw.write(' [scope: %s]' % fixturedef.scope)\n+        self._tw.line()\n+    def pytest_report_collectionfinish(self, config, startdir, items):\n         for item in items:\n-            needed_collectors = item.listchain()[1:]\n-            while stack:\n-                if stack == needed_collectors[:len(stack)]:\n-                    break\n-                stack.pop()\n-            for col in needed_collectors[len(stack):]:\n-                stack.append(col)\n-                if col.name == '()':\n-                    continue\n-                indent = (len(stack) - 1) * '  '\n-                self._tw.line('%s%s' % (indent, col))\n-                if self.config.option.verbose >= 1:\n-                    if hasattr(col, '_obj') and col._obj.__doc__:\n-                        for line in col._obj.__doc__.strip().splitlines():\n-                            self._tw.line('%s%s' % (indent + '  ', line.strip()))\n+            if hasattr(item, '_fixturedefs'):\n+                for fixturedef in item._fixturedefs.values():\n+                    self._print_fixture(fixturedef)\n+        return self.config.hook.pytest_report_header(config=config, startdir=startdir)\n     @pytest.hookimpl(hookwrapper=True)\n     def pytest_sessionfinish(self, exitstatus):\n         outcome = (yield)\n", "normalized_occurrence": 1}
