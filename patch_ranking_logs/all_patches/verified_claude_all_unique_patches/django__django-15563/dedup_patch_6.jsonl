{"model_name_or_path": "agentless_claude", "instance_id": "django__django-15563", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex df46b1e..0b3727a 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -982,11 +982,57 @@ class QuerySet:\n         \"\"\"\n         Update all elements in the current QuerySet, setting all the given\n         fields to the appropriate values.\n+\n+        For multi-table inheritance, ensures updates are applied to the correct\n+        parent tables using the appropriate relationships.\n         \"\"\"\n         self._not_support_combined_queries(\"update\")\n         if self.query.is_sliced:\n             raise TypeError(\"Cannot update a query once a slice has been taken.\")\n         self._for_write = True\n+        \n+        # Get the model class and its parents\n+        model = self.model\n+        parents = [b for b in model.__bases__ if hasattr(b, '_meta') and not b._meta.abstract]\n+        \n+        # Handle multi-table inheritance\n+        if len(parents) > 1:\n+            # Group updates by parent model\n+            updates_by_parent = {}\n+            for field_name, value in kwargs.items():\n+                # Find which parent owns this field\n+                field_found = False\n+                for parent in parents:\n+                    if field_name in parent._meta.fields.keys():\n+                        if parent not in updates_by_parent:\n+                            updates_by_parent[parent] = {}\n+                        updates_by_parent[parent][field_name] = value\n+                        field_found = True\n+                        break\n+                if not field_found:\n+                    updates_by_parent[model] = {field_name: value}\n+            \n+            # Perform updates for each parent separately\n+            total_rows = 0\n+            for parent_model, parent_updates in updates_by_parent.items():\n+                if not parent_updates:\n+                    continue\n+                    \n+                # Create a query for this parent's updates\n+                parent_query = self.query.chain(sql.UpdateQuery)\n+                parent_query.model = parent_model\n+                parent_query.add_update_values(parent_updates)\n+                parent_query.annotations = {}\n+                \n+                # Execute the update\n+                with transaction.mark_for_rollback_on_error(using=self.db):\n+                    rows = parent_query.get_compiler(self.db).execute_sql(CURSOR)\n+                total_rows = max(total_rows, rows or 0)\n+            \n+            self._result_cache = None\n+            return total_rows\n+        \n+        # Single inheritance or non-inherited model - use original logic\n         query = self.query.chain(sql.UpdateQuery)\n         query.add_update_values(kwargs)\n         # Clear any annotations so that they won't be present in subqueries.\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 1c22d92..a1236bf 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -532,6 +532,34 @@ class QuerySet:\n         if self.query.is_sliced:\n             raise TypeError('Cannot update a query once a slice has been taken.')\n         self._for_write = True\n+        model = self.model\n+        parents = [b for b in model.__bases__ if hasattr(b, '_meta') and (not b._meta.abstract)]\n+        if len(parents) > 1:\n+            updates_by_parent = {}\n+            for field_name, value in kwargs.items():\n+                field_found = False\n+                for parent in parents:\n+                    if field_name in parent._meta.fields.keys():\n+                        if parent not in updates_by_parent:\n+                            updates_by_parent[parent] = {}\n+                        updates_by_parent[parent][field_name] = value\n+                        field_found = True\n+                        break\n+                if not field_found:\n+                    updates_by_parent[model] = {field_name: value}\n+            total_rows = 0\n+            for parent_model, parent_updates in updates_by_parent.items():\n+                if not parent_updates:\n+                    continue\n+                parent_query = self.query.chain(sql.UpdateQuery)\n+                parent_query.model = parent_model\n+                parent_query.add_update_values(parent_updates)\n+                parent_query.annotations = {}\n+                with transaction.mark_for_rollback_on_error(using=self.db):\n+                    rows = parent_query.get_compiler(self.db).execute_sql(CURSOR)\n+                total_rows = max(total_rows, rows or 0)\n+            self._result_cache = None\n+            return total_rows\n         query = self.query.chain(sql.UpdateQuery)\n         query.add_update_values(kwargs)\n         query.annotations = {}\n", "normalized_occurrence": 1}
