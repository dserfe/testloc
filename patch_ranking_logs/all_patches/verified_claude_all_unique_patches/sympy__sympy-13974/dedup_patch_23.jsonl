{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13974", "model_patch": "diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py\nindex 153c783..d763655 100644\n--- a/sympy/physics/quantum/tensorproduct.py\n+++ b/sympy/physics/quantum/tensorproduct.py\n@@ -272,10 +272,9 @@ def tensor_product_simp_Mul(e):\n     \"\"\"Simplify a Mul with TensorProducts.\n \n     Current the main use of this is to simplify a ``Mul`` of ``TensorProduct``s\n-    to a ``TensorProduct`` of ``Muls``. It currently only works for relatively\n-    simple cases where the initial ``Mul`` only has scalars and raw\n-    ``TensorProduct``s, not ``Add``, ``Pow``, ``Commutator``s of\n-    ``TensorProduct``s.\n+    to a ``TensorProduct`` of ``Muls``. It handles cases where the initial ``Mul``\n+    contains scalars and raw ``TensorProduct``s, including repeated TensorProducts\n+    that should be combined into powers within each tensor factor.\n \n     Parameters\n     ==========\n@@ -339,8 +338,21 @@ def tensor_product_simp_Mul(e):\n                 # TensorProduct\n                 for i in range(len(new_args)):\n                     new_args[i] = new_args[i] * next\n-            current = next\n-        return Mul(*c_part) * TensorProduct(*new_args)\n+            # Count occurrences of the same TensorProduct\n+            tp_args = {}\n+            for i, arg in enumerate(current.args):\n+                if arg not in tp_args:\n+                    tp_args[arg] = 0\n+                tp_args[arg] += 1\n+            # Create new args with powers if needed\n+            powered_args = []\n+            for arg, count in tp_args.items():\n+                if count > 1:\n+                    powered_args.append(arg**count)\n+                else:\n+                    powered_args.append(arg)\n+            current = TensorProduct(*powered_args)\n+            return Mul(*c_part) * current\n     else:\n         return e\n \n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py\nindex e23a275..923054f 100644\n--- a/sympy/physics/quantum/tensorproduct.py\n+++ b/sympy/physics/quantum/tensorproduct.py\n@@ -153,8 +153,19 @@ def tensor_product_simp_Mul(e):\n             else:\n                 for i in range(len(new_args)):\n                     new_args[i] = new_args[i] * next\n-            current = next\n-        return Mul(*c_part) * TensorProduct(*new_args)\n+            tp_args = {}\n+            for i, arg in enumerate(current.args):\n+                if arg not in tp_args:\n+                    tp_args[arg] = 0\n+                tp_args[arg] += 1\n+            powered_args = []\n+            for arg, count in tp_args.items():\n+                if count > 1:\n+                    powered_args.append(arg ** count)\n+                else:\n+                    powered_args.append(arg)\n+            current = TensorProduct(*powered_args)\n+            return Mul(*c_part) * current\n     else:\n         return e\n def tensor_product_simp(e, **hints):\n", "normalized_occurrence": 1}
