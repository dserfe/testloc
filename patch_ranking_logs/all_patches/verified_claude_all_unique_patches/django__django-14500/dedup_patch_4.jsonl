{"model_name_or_path": "agentless_claude", "instance_id": "django__django-14500", "model_patch": "diff --git a/django/db/migrations/executor.py b/django/db/migrations/executor.py\nindex 9e05ef1..68f8dd6 100644\n--- a/django/db/migrations/executor.py\n+++ b/django/db/migrations/executor.py\n@@ -163,10 +163,18 @@ class MigrationExecutor:\n         # Holds all migration states prior to the migrations being unapplied\n         states = {}\n         state = self._create_project_state()\n-        applied_migrations = {\n-            self.loader.graph.nodes[key] for key in self.loader.applied_migrations\n-            if key in self.loader.graph.nodes\n-        }\n+        # Get the set of applied migrations while handling squashed migrations\n+        applied_migrations = set()\n+        for key in self.loader.applied_migrations:\n+            if key not in self.loader.graph.nodes:\n+                continue\n+            migration = self.loader.graph.nodes[key]\n+            # For squashed migrations, only include if all replaced migrations are applied\n+            if hasattr(migration, 'replaces'):\n+                if all(replaced in self.loader.applied_migrations for replaced in migration.replaces):\n+                    applied_migrations.add(migration)\n+            else:\n+                applied_migrations.add(migration)\n         if self.progress_callback:\n             self.progress_callback(\"render_start\")\n         for migration, _ in full_plan:\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/migrations/executor.py b/django/db/migrations/executor.py\nindex d5a1e7d..677843d 100644\n--- a/django/db/migrations/executor.py\n+++ b/django/db/migrations/executor.py\n@@ -85,7 +85,16 @@ class MigrationExecutor:\n         migrations_to_run = {m[0] for m in plan}\n         states = {}\n         state = self._create_project_state()\n-        applied_migrations = {self.loader.graph.nodes[key] for key in self.loader.applied_migrations if key in self.loader.graph.nodes}\n+        applied_migrations = set()\n+        for key in self.loader.applied_migrations:\n+            if key not in self.loader.graph.nodes:\n+                continue\n+            migration = self.loader.graph.nodes[key]\n+            if hasattr(migration, 'replaces'):\n+                if all((replaced in self.loader.applied_migrations for replaced in migration.replaces)):\n+                    applied_migrations.add(migration)\n+            else:\n+                applied_migrations.add(migration)\n         if self.progress_callback:\n             self.progress_callback('render_start')\n         for migration, _ in full_plan:\n", "normalized_occurrence": 1}
