{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-12907", "model_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex d6e9246..4b0c412 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -186,34 +186,39 @@ def _coord_matrix(model, pos, noutp):\n         is a left or right child.\n \n     \"\"\"\n-    if isinstance(model, Mapping):\n-        axes = []\n-        for i in model.mapping:\n-            axis = np.zeros((model.n_inputs,))\n-            axis[i] = 1\n-            axes.append(axis)\n-        m = np.vstack(axes)\n-        mat = np.zeros((noutp, model.n_inputs))\n-        if pos == 'left':\n-            mat[: model.n_outputs, :model.n_inputs] = m\n-        else:\n-            mat[-model.n_outputs:, -model.n_inputs:] = m\n-        return mat\n-    if not model.separable:\n-        # this does not work for more than 2 coordinates\n-        mat = np.zeros((noutp, model.n_inputs))\n-        if pos == 'left':\n-            mat[:model.n_outputs, : model.n_inputs] = 1\n-        else:\n-            mat[-model.n_outputs:, -model.n_inputs:] = 1\n+    if isinstance(model, CompoundModel):\n+        left_matrix = _coord_matrix(model.left, pos, noutp)\n+        right_matrix = _coord_matrix(model.right, pos, noutp)\n+        return _operators[model.op](left_matrix, right_matrix)\n     else:\n-        mat = np.zeros((noutp, model.n_inputs))\n+        if isinstance(model, Mapping):\n+            axes = []\n+            for i in model.mapping:\n+                axis = np.zeros((model.n_inputs,))\n+                axis[i] = 1\n+                axes.append(axis)\n+            m = np.vstack(axes)\n+            mat = np.zeros((noutp, model.n_inputs))\n+            if pos == 'left':\n+                mat[: model.n_outputs, :model.n_inputs] = m\n+            else:\n+                mat[-model.n_outputs:, -model.n_inputs:] = m\n+            return mat\n+        if not model.separable:\n+            # this does not work for more than 2 coordinates\n+            mat = np.zeros((noutp, model.n_inputs))\n+            if pos == 'left':\n+                mat[:model.n_outputs, : model.n_inputs] = 1\n+            else:\n+                mat[-model.n_outputs:, -model.n_inputs:] = 1\n+        else:\n+            mat = np.zeros((noutp, model.n_inputs))\n \n-        for i in range(model.n_inputs):\n-            mat[i, i] = 1\n-        if pos == 'right':\n-            mat = np.roll(mat, (noutp - model.n_outputs))\n-    return mat\n+            for i in range(model.n_inputs):\n+                mat[i, i] = 1\n+            if pos == 'right':\n+                mat = np.roll(mat, (noutp - model.n_outputs))\n+        return mat\n \n \n def _cstack(left, right):\n@@ -314,4 +319,4 @@ def _separable(transform):\n # Maps modeling operators to a function computing and represents the\n # relationship of axes as an array of 0-es and 1-s\n _operators = {'&': _cstack, '|': _cdot, '+': _arith_oper, '-': _arith_oper,\n-              '*': _arith_oper, '/': _arith_oper, '**': _arith_oper}\n+              '*': _arith_oper, '/': _arith_oper, '**': _arith_oper}\n", "occurrence": 1, "normalized_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex 198a838..853776a 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -41,32 +41,37 @@ def _arith_oper(left, right):\n     result = np.ones((left_outputs, left_inputs))\n     return result\n def _coord_matrix(model, pos, noutp):\n-    if isinstance(model, Mapping):\n-        axes = []\n-        for i in model.mapping:\n-            axis = np.zeros((model.n_inputs,))\n-            axis[i] = 1\n-            axes.append(axis)\n-        m = np.vstack(axes)\n-        mat = np.zeros((noutp, model.n_inputs))\n-        if pos == 'left':\n-            mat[:model.n_outputs, :model.n_inputs] = m\n+    if isinstance(model, CompoundModel):\n+        left_matrix = _coord_matrix(model.left, pos, noutp)\n+        right_matrix = _coord_matrix(model.right, pos, noutp)\n+        return _operators[model.op](left_matrix, right_matrix)\n+    else:\n+        if isinstance(model, Mapping):\n+            axes = []\n+            for i in model.mapping:\n+                axis = np.zeros((model.n_inputs,))\n+                axis[i] = 1\n+                axes.append(axis)\n+            m = np.vstack(axes)\n+            mat = np.zeros((noutp, model.n_inputs))\n+            if pos == 'left':\n+                mat[:model.n_outputs, :model.n_inputs] = m\n+            else:\n+                mat[-model.n_outputs:, -model.n_inputs:] = m\n+            return mat\n+        if not model.separable:\n+            mat = np.zeros((noutp, model.n_inputs))\n+            if pos == 'left':\n+                mat[:model.n_outputs, :model.n_inputs] = 1\n+            else:\n+                mat[-model.n_outputs:, -model.n_inputs:] = 1\n         else:\n-            mat[-model.n_outputs:, -model.n_inputs:] = m\n+            mat = np.zeros((noutp, model.n_inputs))\n+            for i in range(model.n_inputs):\n+                mat[i, i] = 1\n+            if pos == 'right':\n+                mat = np.roll(mat, noutp - model.n_outputs)\n         return mat\n-    if not model.separable:\n-        mat = np.zeros((noutp, model.n_inputs))\n-        if pos == 'left':\n-            mat[:model.n_outputs, :model.n_inputs] = 1\n-        else:\n-            mat[-model.n_outputs:, -model.n_inputs:] = 1\n-    else:\n-        mat = np.zeros((noutp, model.n_inputs))\n-        for i in range(model.n_inputs):\n-            mat[i, i] = 1\n-        if pos == 'right':\n-            mat = np.roll(mat, noutp - model.n_outputs)\n-    return mat\n def _cstack(left, right):\n     noutp = _compute_n_outputs(left, right)\n     if isinstance(left, Model):\n", "normalized_occurrence": 1}
