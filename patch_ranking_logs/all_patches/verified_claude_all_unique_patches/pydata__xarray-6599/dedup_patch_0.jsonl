{"model_name_or_path": "agentless_claude", "instance_id": "pydata__xarray-6599", "model_patch": "diff --git a/xarray/core/duck_array_ops.py b/xarray/core/duck_array_ops.py\nindex 3ef7ed0..16d0029 100644\n--- a/xarray/core/duck_array_ops.py\n+++ b/xarray/core/duck_array_ops.py\n@@ -423,7 +423,7 @@ def datetime_to_numeric(array, offset=None, datetime_unit=None, dtype=float):\n     # TODO: make this function dask-compatible?\n     # Set offset to minimum if not given\n     if offset is None:\n-        if array.dtype.kind in \"Mm\":\n+        if array.dtype.kind == \"M\":  # datetime64 only\n             offset = _datetime_nanmin(array)\n         else:\n             offset = min(array)\n@@ -431,7 +431,11 @@ def datetime_to_numeric(array, offset=None, datetime_unit=None, dtype=float):\n     # Compute timedelta object.\n     # For np.datetime64, this can silently yield garbage due to overflow.\n     # One option is to enforce 1970-01-01 as the universal offset.\n-    array = array - offset\n+    if array.dtype.kind == \"m\":  # timedelta64\n+        # Don't subtract offset for timedelta arrays\n+        pass\n+    else:\n+        array = array - offset\n \n     # Scalar is converted to 0d-array\n     if not hasattr(array, \"dtype\"):\n", "occurrence": 1, "normalized_patch": "diff --git a/xarray/core/duck_array_ops.py b/xarray/core/duck_array_ops.py\nindex 003b4fa..6676ea7 100644\n--- a/xarray/core/duck_array_ops.py\n+++ b/xarray/core/duck_array_ops.py\n@@ -227,11 +227,14 @@ def _datetime_nanmin(array):\n     return array.astype(dtype)\n def datetime_to_numeric(array, offset=None, datetime_unit=None, dtype=float):\n     if offset is None:\n-        if array.dtype.kind in 'Mm':\n+        if array.dtype.kind == 'M':\n             offset = _datetime_nanmin(array)\n         else:\n             offset = min(array)\n-    array = array - offset\n+    if array.dtype.kind == 'm':\n+        pass\n+    else:\n+        array = array - offset\n     if not hasattr(array, 'dtype'):\n         array = np.array(array)\n     if array.dtype.kind in 'O':\n", "normalized_occurrence": 1}
