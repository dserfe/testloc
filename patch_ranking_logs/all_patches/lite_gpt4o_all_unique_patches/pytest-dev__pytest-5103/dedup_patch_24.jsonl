{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-5103", "model_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 4810cdd..9e8f3cb 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -965,6 +965,47 @@ warn_explicit(\n         return res, explanation\n \n     def visit_Call_35(self, call):\n+        def unroll_iterable_for_all_any(call, func_name):\n+            func_name_node = ast.Name(id=func_name, ctx=ast.Load())\n+            if isinstance(call.func, ast.Name) and call.func.id == func_name:\n+                if len(call.args) == 1 and isinstance(call.args[0], ast.GeneratorExp):\n+                    generator = call.args[0]\n+                    variable_name = self.variable()\n+                    loop_body = []\n+                    for expr in generator.elt:\n+                        res, expl = self.visit(expr)\n+                        loop_body.append(\n+                            ast.If(\n+                                test=ast.UnaryOp(op=ast.Not(), operand=res),\n+                                body=[ast.Raise(\n+                                    exc=ast.Call(\n+                                        func=ast.Name(id='AssertionError', ctx=ast.Load()),\n+                                        args=[ast.Str(s=f\"assert {func_name}({expl})\")],\n+                                        keywords=[]\n+                                    ),\n+                                    cause=None\n+                                )],\n+                                orelse=[]\n+                            )\n+                        )\n+                    loop = ast.For(\n+                        target=generator.target,\n+                        iter=generator.iter,\n+                        body=loop_body,\n+                        orelse=[]\n+                    )\n+                    return [loop]\n+            return None\n+\n+        # Unroll 'all' calls\n+        unrolled = unroll_iterable_for_all_any(call, 'all')\n+        if unrolled:\n+            return unrolled\n+\n+        # Unroll 'any' calls\n+        unrolled = unroll_iterable_for_all_any(call, 'any')\n+        if unrolled:\n+            return unrolled\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n@@ -998,6 +1039,47 @@ warn_explicit(\n         return new_starred, \"*\" + expl\n \n     def visit_Call_legacy(self, call):\n+        def unroll_iterable_for_all_any(call, func_name):\n+            func_name_node = ast.Name(id=func_name, ctx=ast.Load())\n+            if isinstance(call.func, ast.Name) and call.func.id == func_name:\n+                if len(call.args) == 1 and isinstance(call.args[0], ast.GeneratorExp):\n+                    generator = call.args[0]\n+                    variable_name = self.variable()\n+                    loop_body = []\n+                    for expr in generator.elt:\n+                        res, expl = self.visit(expr)\n+                        loop_body.append(\n+                            ast.If(\n+                                test=ast.UnaryOp(op=ast.Not(), operand=res),\n+                                body=[ast.Raise(\n+                                    exc=ast.Call(\n+                                        func=ast.Name(id='AssertionError', ctx=ast.Load()),\n+                                        args=[ast.Str(s=f\"assert {func_name}({expl})\")],\n+                                        keywords=[]\n+                                    ),\n+                                    cause=None\n+                                )],\n+                                orelse=[]\n+                            )\n+                        )\n+                    loop = ast.For(\n+                        target=generator.target,\n+                        iter=generator.iter,\n+                        body=loop_body,\n+                        orelse=[]\n+                    )\n+                    return [loop]\n+            return None\n+\n+        # Unroll 'all' calls\n+        unrolled = unroll_iterable_for_all_any(call, 'all')\n+        if unrolled:\n+            return unrolled\n+\n+        # Unroll 'any' calls\n+        unrolled = unroll_iterable_for_all_any(call, 'any')\n+        if unrolled:\n+            return unrolled\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n@@ -1081,4 +1163,4 @@ warn_explicit(\n             res = ast.BoolOp(ast.And(), load_names)\n         else:\n             res = load_names[0]\n-        return res, self.explanation_param(self.pop_format_context(expl_call))\n+        return res, self.explanation_param(self.pop_format_context(expl_call))\n", "occurrence": 1, "normalized_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2ada5b2..05d8c19 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -544,6 +544,26 @@ class AssertionRewriter(ast.NodeVisitor):\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return (res, explanation)\n     def visit_Call_35(self, call):\n+        def unroll_iterable_for_all_any(call, func_name):\n+            func_name_node = ast.Name(id=func_name, ctx=ast.Load())\n+            if isinstance(call.func, ast.Name) and call.func.id == func_name:\n+                if len(call.args) == 1 and isinstance(call.args[0], ast.GeneratorExp):\n+                    generator = call.args[0]\n+                    variable_name = self.variable()\n+                    loop_body = []\n+                    for expr in generator.elt:\n+                        res, expl = self.visit(expr)\n+                        loop_body.append(ast.If(test=ast.UnaryOp(op=ast.Not(), operand=res), body=[ast.Raise(exc=ast.Call(func=ast.Name(id='AssertionError', ctx=ast.Load()), args=[ast.Str(s=f'assert {func_name}({expl})')], keywords=[]), cause=None)], orelse=[]))\n+                    loop = ast.For(target=generator.target, iter=generator.iter, body=loop_body, orelse=[])\n+                    return [loop]\n+            return None\n+        unrolled = unroll_iterable_for_all_any(call, 'all')\n+        if unrolled:\n+            return unrolled\n+        unrolled = unroll_iterable_for_all_any(call, 'any')\n+        if unrolled:\n+            return unrolled\n+        '\\n        visit `ast.Call` nodes on Python3.5 and after\\n        '\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -570,6 +590,26 @@ class AssertionRewriter(ast.NodeVisitor):\n         new_starred = ast.Starred(res, starred.ctx)\n         return (new_starred, '*' + expl)\n     def visit_Call_legacy(self, call):\n+        def unroll_iterable_for_all_any(call, func_name):\n+            func_name_node = ast.Name(id=func_name, ctx=ast.Load())\n+            if isinstance(call.func, ast.Name) and call.func.id == func_name:\n+                if len(call.args) == 1 and isinstance(call.args[0], ast.GeneratorExp):\n+                    generator = call.args[0]\n+                    variable_name = self.variable()\n+                    loop_body = []\n+                    for expr in generator.elt:\n+                        res, expl = self.visit(expr)\n+                        loop_body.append(ast.If(test=ast.UnaryOp(op=ast.Not(), operand=res), body=[ast.Raise(exc=ast.Call(func=ast.Name(id='AssertionError', ctx=ast.Load()), args=[ast.Str(s=f'assert {func_name}({expl})')], keywords=[]), cause=None)], orelse=[]))\n+                    loop = ast.For(target=generator.target, iter=generator.iter, body=loop_body, orelse=[])\n+                    return [loop]\n+            return None\n+        unrolled = unroll_iterable_for_all_any(call, 'all')\n+        if unrolled:\n+            return unrolled\n+        unrolled = unroll_iterable_for_all_any(call, 'any')\n+        if unrolled:\n+            return unrolled\n+        '\\n        visit `ast.Call nodes on 3.4 and below`\\n        '\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n", "normalized_occurrence": 1}
