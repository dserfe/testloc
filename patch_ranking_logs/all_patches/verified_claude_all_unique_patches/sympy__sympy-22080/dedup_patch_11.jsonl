{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-22080", "model_patch": "diff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex ca33049..356c069 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.numbers import nan\n from .function import Function\n from .kind import NumberKind\n@@ -138,6 +139,11 @@ class Mod(Function):\n                 both_l[isinstance(arg, cls)].append(arg)\n \n             if mod_l and all(inner.args[1] == q for inner in mod_l):\n+                # Do not attempt to distribute multiplication over Mod\n+                # when modules=[] is used with lambdify\n+                if getattr(cls, '_no_distribute', False):\n+                    return None\n+\n                 # finding distributive term\n                 non_mod_l = [cls(x, q) for x in non_mod_l]\n                 mod = []\n@@ -240,4 +246,4 @@ class Mod(Function):\n \n     def _eval_rewrite_as_floor(self, a, b, **kwargs):\n         from sympy.functions.elementary.integers import floor\n-        return a - b*floor(a/b)\n+        return a - b*floor(a/b)\ndiff --git a/sympy/utilities/lambdify.py b/sympy/utilities/lambdify.py\nindex ae1df59..da980e1 100644\n--- a/sympy/utilities/lambdify.py\n+++ b/sympy/utilities/lambdify.py\n@@ -818,6 +818,11 @@ def lambdify(args: Iterable, expr, modules=None, printer=None, use_imps=True,\n             if isinstance(m, dict):\n                 for k in m:\n                     user_functions[k] = k\n+        \n+        # Prevent distribution of multiplication over Mod when modules=[]\n+        if not namespaces or (len(namespaces) == 1 and isinstance(namespaces[0], dict)):\n+            from sympy.core.mod import Mod\n+            Mod._no_distribute = True\n         printer = Printer({'fully_qualified_modules': False, 'inline': True,\n                            'allow_unknown_functions': True,\n                            'user_functions': user_functions})\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex 57d2396..048d010 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -85,6 +85,8 @@ class Mod(Function):\n             for arg in p.args:\n                 both_l[isinstance(arg, cls)].append(arg)\n             if mod_l and all((inner.args[1] == q for inner in mod_l)):\n+                if getattr(cls, '_no_distribute', False):\n+                    return None\n                 non_mod_l = [cls(x, q) for x in non_mod_l]\n                 mod = []\n                 non_mod = []\ndiff --git a/sympy/utilities/lambdify.py b/sympy/utilities/lambdify.py\nindex c5ff69c..b7badcd 100644\n--- a/sympy/utilities/lambdify.py\n+++ b/sympy/utilities/lambdify.py\n@@ -117,6 +117,9 @@ def lambdify(args: Iterable, expr, modules=None, printer=None, use_imps=True, du\n             if isinstance(m, dict):\n                 for k in m:\n                     user_functions[k] = k\n+        if not namespaces or (len(namespaces) == 1 and isinstance(namespaces[0], dict)):\n+            from sympy.core.mod import Mod\n+            Mod._no_distribute = True\n         printer = Printer({'fully_qualified_modules': False, 'inline': True, 'allow_unknown_functions': True, 'user_functions': user_functions})\n     if isinstance(args, set):\n         SymPyDeprecationWarning(feature='The list of arguments is a `set`. This leads to unpredictable results', useinstead=': Convert set into list or tuple', issue=20013, deprecated_since_version='1.6.3').warn()\n", "normalized_occurrence": 1}
