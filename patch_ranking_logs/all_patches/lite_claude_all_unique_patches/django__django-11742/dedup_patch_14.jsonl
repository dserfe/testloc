{"model_name_or_path": "agentless_claude", "instance_id": "django__django-11742", "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 16823e9..6444448 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,55 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n-    def _check_choices(self):\n-        if not self.choices:\n-            return []\n-\n-        def is_value(value, accept_promise=True):\n-            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n-\n-        if is_value(self.choices, accept_promise=False):\n-            return [\n-                checks.Error(\n-                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n-                    obj=self,\n-                    id='fields.E004',\n-                )\n-            ]\n \n-        # Expect [group_name, [value, display]]\n-        for choices_group in self.choices:\n-            try:\n-                group_name, group_choices = choices_group\n-            except (TypeError, ValueError):\n-                # Containing non-pairs\n-                break\n-            try:\n-                if not all(\n-                    is_value(value) and is_value(human_name)\n-                    for value, human_name in group_choices\n-                ):\n-                    break\n-            except (TypeError, ValueError):\n-                # No groups, choices in the form [value, display]\n-                value, human_name = group_name, group_choices\n-                if not is_value(value) or not is_value(human_name):\n-                    break\n-\n-            # Special case: choices=['ab']\n-            if isinstance(choices_group, str):\n-                break\n-        else:\n-            return []\n-\n-        return [\n-            checks.Error(\n-                \"'choices' must be an iterable containing \"\n-                \"(actual value, human readable name) tuples.\",\n-                obj=self,\n-                id='fields.E005',\n-            )\n-        ]\n \n     def _check_db_index(self):\n         if self.db_index not in (None, True, False):\n", "occurrence": 2, "normalized_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex adca252..3de1f7f 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -117,30 +117,6 @@ class Field(RegisterLookupMixin):\n             return [checks.Error(\"'pk' is a reserved word that cannot be used as a field name.\", obj=self, id='fields.E003')]\n         else:\n             return []\n-    def _check_choices(self):\n-        if not self.choices:\n-            return []\n-        def is_value(value, accept_promise=True):\n-            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n-        if is_value(self.choices, accept_promise=False):\n-            return [checks.Error(\"'choices' must be an iterable (e.g., a list or tuple).\", obj=self, id='fields.E004')]\n-        for choices_group in self.choices:\n-            try:\n-                group_name, group_choices = choices_group\n-            except (TypeError, ValueError):\n-                break\n-            try:\n-                if not all((is_value(value) and is_value(human_name) for value, human_name in group_choices)):\n-                    break\n-            except (TypeError, ValueError):\n-                value, human_name = (group_name, group_choices)\n-                if not is_value(value) or not is_value(human_name):\n-                    break\n-            if isinstance(choices_group, str):\n-                break\n-        else:\n-            return []\n-        return [checks.Error(\"'choices' must be an iterable containing (actual value, human readable name) tuples.\", obj=self, id='fields.E005')]\n     def _check_db_index(self):\n         if self.db_index not in (None, True, False):\n             return [checks.Error(\"'db_index' must be None, True or False.\", obj=self, id='fields.E006')]\n", "normalized_occurrence": 2}
