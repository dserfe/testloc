{"model_name_or_path": "agentless_claude", "instance_id": "matplotlib__matplotlib-20488", "model_patch": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex bbcae54..31d05eb 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1551,6 +1551,32 @@ class LogNorm(Normalize):\n         # docstring inherited.\n         super().autoscale_None(np.ma.masked_less_equal(A, 0, copy=False))\n \n+    def __call__(self, value, clip=None):\n+        \"\"\"\n+        Normalize *value* data in the ``[vmin, vmax]`` interval into the\n+        ``[0.0, 1.0]`` interval and return it.\n+        \"\"\"\n+        value, is_scalar = self.process_value(value)\n+        self.autoscale_None(value)\n+        \n+        if self.vmin <= 0:\n+            raise ValueError(\"vmin must be positive for LogNorm\")\n+            \n+        if self.vmin > self.vmax:\n+            raise ValueError(\"vmin must be less than or equal to vmax\")\n+            \n+        if self.vmin == self.vmax:\n+            return np.full_like(value, 0)\n+            \n+        if clip is None:\n+            clip = self.clip\n+            \n+        if clip:\n+            value = np.clip(value, self.vmin, self.vmax)\n+            \n+        result = super().__call__(value, clip=clip)\n+        return result\n+\n \n @_make_norm_from_scale(\n     scale.SymmetricalLogScale,\n", "normalized_patch": "--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n+    def __call__(self, value, clip=None):\n+        \"\"\"\n+        Normalize *value* data in the ``[vmin, vmax]`` interval into the\n+        ``[0.0, 1.0]`` interval and return it.\n+        \"\"\"\n+        value, is_scalar = self.process_value(value)\n+        self.autoscale_None(value)\n+        if self.vmin <= 0:\n+            raise ValueError('vmin must be positive for LogNorm')\n+        if self.vmin > self.vmax:\n+            raise ValueError('vmin must be less than or equal to vmax')\n+        if self.vmin == self.vmax:\n+            return np.full_like(value, 0)\n+        if clip is None:\n+            clip = self.clip\n+        if clip:\n+            value = np.clip(value, self.vmin, self.vmax)\n+        result = super().__call__(value, clip=clip)\n+        return result\n+", "normalized_occurrence": 1}
