{"model_name_or_path": "agentless", "instance_id": "django__django-14411", "model_patch": "diff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex ab619c1..e3addb8 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -306,14 +306,17 @@ def _get_non_gfk_field(opts, name):\n \n     return field\n \n+def _is_non_labelable_widget(widget):\n+    return isinstance(widget, ReadOnlyPasswordHashWidget)\n \n-def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n+def label_for_field(name, model, model_admin=None, return_attr=False, form=None, widget=None):\n     \"\"\"\n     Return a sensible label for a field name. The name can be a callable,\n     property (but not created with @property decorator), or the name of an\n     object's attribute, as well as a model field. If return_attr is True, also\n     return the resolved attribute (which could be a callable). This will be\n-    None if (and only if) the name refers to a field.\n+    None if (and only if) the name refers to a field. If widget is non-labelable,\n+    do not include 'for' attribute in the label.\n     \"\"\"\n     attr = None\n     try:\n@@ -363,9 +366,10 @@ def label_for_field(name, model, model_admin=None, return_attr=False, form=None)\n \n     if return_attr:\n         return (label, attr)\n-    else:\n-        return label\n \n+    if widget and _is_non_labelable_widget(widget):\n+        return label\n+    return {'label': label, 'for': name}\n \n def help_text_for_field(name, model):\n     help_text = \"\"\n", "occurrence": 1, "normalized_patch": "diff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex 2428fd0..d7187a3 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -178,7 +178,9 @@ def _get_non_gfk_field(opts, name):\n     if field.is_relation and (not field.many_to_many) and hasattr(field, 'attname') and (field.attname == name):\n         raise FieldIsAForeignKeyColumnName()\n     return field\n-def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n+def _is_non_labelable_widget(widget):\n+    return isinstance(widget, ReadOnlyPasswordHashWidget)\n+def label_for_field(name, model, model_admin=None, return_attr=False, form=None, widget=None):\n     attr = None\n     try:\n         field = _get_non_gfk_field(model._meta, name)\n@@ -222,8 +224,9 @@ def label_for_field(name, model, model_admin=None, return_attr=False, form=None)\n         attr = name\n     if return_attr:\n         return (label, attr)\n-    else:\n+    if widget and _is_non_labelable_widget(widget):\n         return label\n+    return {'label': label, 'for': name}\n def help_text_for_field(name, model):\n     help_text = ''\n     try:\n", "normalized_occurrence": 1}
