{"model_name_or_path": "agentless", "instance_id": "django__django-16560", "model_patch": "diff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 8b23275..180a228 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -59,11 +59,14 @@ class BaseConstraint:\n     def remove_sql(self, model, schema_editor):\n         raise NotImplementedError(\"This method must be implemented by a subclass.\")\n \n-    def validate(self, model, instance, exclude=None, using=DEFAULT_DB_ALIAS):\n+    def validate(self, model, instance, exclude=None, using=DEFAULT_DB_ALIAS, code=None):\n         raise NotImplementedError(\"This method must be implemented by a subclass.\")\n \n-    def get_violation_error_message(self):\n-        return self.violation_error_message % {\"name\": self.name}\n+    def get_violation_error_message(self, code=None):\n+        return {\n+            'message': self.violation_error_message % {\"name\": self.name},\n+            'code': code\n+        }\n \n     def deconstruct(self):\n         path = \"%s.%s\" % (self.__class__.__module__, self.__class__.__name__)\n@@ -112,7 +115,8 @@ class CheckConstraint(BaseConstraint):\n         against = instance._get_field_value_map(meta=model._meta, exclude=exclude)\n         try:\n             if not Q(self.check).check(against, using=using):\n-                raise ValidationError(self.get_violation_error_message())\n+                violation = self.get_violation_error_message()\n+                raise ValidationError(violation['message'], code=violation['code'] or 'check_constraint_violation')\n         except FieldError:\n             pass\n \n@@ -385,14 +389,16 @@ class UniqueConstraint(BaseConstraint):\n         if not self.condition:\n             if queryset.exists():\n                 if self.expressions:\n-                    raise ValidationError(self.get_violation_error_message())\n+                    violation = self.get_violation_error_message()\n+                    raise ValidationError(violation['message'], code=violation['code'] or 'unique_constraint_violation')\n                 # When fields are defined, use the unique_error_message() for\n                 # backward compatibility.\n                 for model, constraints in instance.get_constraints():\n                     for constraint in constraints:\n                         if constraint is self:\n                             raise ValidationError(\n-                                instance.unique_error_message(model, self.fields)\n+                                instance.unique_error_message(model, self.fields),\n+                                code='unique_constraint_violation'\n                             )\n         else:\n             against = instance._get_field_value_map(meta=model._meta, exclude=exclude)\n@@ -400,6 +406,7 @@ class UniqueConstraint(BaseConstraint):\n                 if (self.condition & Exists(queryset.filter(self.condition))).check(\n                     against, using=using\n                 ):\n-                    raise ValidationError(self.get_violation_error_message())\n+                    violation = self.get_violation_error_message()\n+                    raise ValidationError(violation['message'], code=violation['code'] or 'unique_constraint_violation')\n             except FieldError:\n-                pass\n+                pass\n", "occurrence": 1, "normalized_patch": "diff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 50c20cc..5b03793 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -37,10 +37,10 @@ class BaseConstraint:\n         raise NotImplementedError('This method must be implemented by a subclass.')\n     def remove_sql(self, model, schema_editor):\n         raise NotImplementedError('This method must be implemented by a subclass.')\n-    def validate(self, model, instance, exclude=None, using=DEFAULT_DB_ALIAS):\n+    def validate(self, model, instance, exclude=None, using=DEFAULT_DB_ALIAS, code=None):\n         raise NotImplementedError('This method must be implemented by a subclass.')\n-    def get_violation_error_message(self):\n-        return self.violation_error_message % {'name': self.name}\n+    def get_violation_error_message(self, code=None):\n+        return {'message': self.violation_error_message % {'name': self.name}, 'code': code}\n     def deconstruct(self):\n         path = '%s.%s' % (self.__class__.__module__, self.__class__.__name__)\n         path = path.replace('django.db.models.constraints', 'django.db.models')\n@@ -75,7 +75,8 @@ class CheckConstraint(BaseConstraint):\n         against = instance._get_field_value_map(meta=model._meta, exclude=exclude)\n         try:\n             if not Q(self.check).check(against, using=using):\n-                raise ValidationError(self.get_violation_error_message())\n+                violation = self.get_violation_error_message()\n+                raise ValidationError(violation['message'], code=violation['code'] or 'check_constraint_violation')\n         except FieldError:\n             pass\n     def __repr__(self):\n@@ -219,15 +220,17 @@ class UniqueConstraint(BaseConstraint):\n         if not self.condition:\n             if queryset.exists():\n                 if self.expressions:\n-                    raise ValidationError(self.get_violation_error_message())\n+                    violation = self.get_violation_error_message()\n+                    raise ValidationError(violation['message'], code=violation['code'] or 'unique_constraint_violation')\n                 for model, constraints in instance.get_constraints():\n                     for constraint in constraints:\n                         if constraint is self:\n-                            raise ValidationError(instance.unique_error_message(model, self.fields))\n+                            raise ValidationError(instance.unique_error_message(model, self.fields), code='unique_constraint_violation')\n         else:\n             against = instance._get_field_value_map(meta=model._meta, exclude=exclude)\n             try:\n                 if (self.condition & Exists(queryset.filter(self.condition))).check(against, using=using):\n-                    raise ValidationError(self.get_violation_error_message())\n+                    violation = self.get_violation_error_message()\n+                    raise ValidationError(violation['message'], code=violation['code'] or 'unique_constraint_violation')\n             except FieldError:\n                 pass\n\\ No newline at end of file\n", "normalized_occurrence": 1}
