{"model_name_or_path": "agentless_claude", "instance_id": "matplotlib__matplotlib-24149", "model_patch": "diff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 63a9e60..2adc498 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -1714,13 +1714,16 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n \n     This is an type-independent way of obtaining the first non-None element,\n     supporting both index access and the iterator protocol.\n-    The first non-None element will be obtained when skip_none is True.\n+    When skip_nonfinite is True, returns the first finite value.\n+    When skip_nonfinite is False, returns the first value even if it's non-finite.\n     \"\"\"\n     def safe_isfinite(val):\n         if val is None:\n             return False\n         try:\n-            return np.isfinite(val) if np.isscalar(val) else True\n+            if skip_nonfinite:\n+                return np.isfinite(val) if np.isscalar(val) else True\n+            return True  # When skip_nonfinite is False, accept any non-None value\n         except TypeError:\n             # This is something that numpy can not make heads or tails\n             # of, assume \"finite\"\n", "occurrence": 1, "normalized_patch": "diff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex d655165..e1f73e7 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -734,7 +734,9 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n         if val is None:\n             return False\n         try:\n-            return np.isfinite(val) if np.isscalar(val) else True\n+            if skip_nonfinite:\n+                return np.isfinite(val) if np.isscalar(val) else True\n+            return True\n         except TypeError:\n             return True\n     if skip_nonfinite is False:\n", "normalized_occurrence": 1}
