{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-7373", "model_patch": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 74f45dd..085842f 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -18,17 +18,11 @@ from _pytest.store import StoreKey\n evalcache_key = StoreKey[Dict[str, Any]]()\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n+def evaluate_expr(expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +92,7 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+                        result = evaluate_expr(expr, d)\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n@@ -132,4 +126,4 @@ class MarkEvaluator:\n                 return \"\"\n             else:\n                 return \"condition: \" + str(self.expr)\n-        return expl\n+        return expl\n", "occurrence": 1, "normalized_patch": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 678113f..2454466 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -13,16 +13,10 @@ from _pytest.config import Config\n from _pytest.nodes import Item\n from _pytest.store import StoreKey\n evalcache_key = StoreKey[Dict[str, Any]]()\n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n-        exprcode = _pytest._code.compile(expr, mode='eval')\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+def evaluate_expr(expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    exprcode = _pytest._code.compile(expr, mode='eval')\n+    return eval(exprcode, d)\n class MarkEvaluator:\n     def __init__(self, item: Item, name: str) -> None:\n         self.item = item\n@@ -74,7 +68,7 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+                        result = evaluate_expr(expr, d)\n                     else:\n                         if 'reason' not in mark.kwargs:\n                             msg = 'you need to specify reason=STRING when using booleans as conditions.'\n", "normalized_occurrence": 1}
