{"model_name_or_path": "agentless_claude", "instance_id": "sympy__sympy-13146", "model_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex e24efd1..396d55d 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -643,6 +643,13 @@ def evalf_pow(v, prec, options):\n     target_prec = prec\n     base, exp = v.args\n \n+    # Convert float exponents to rational if possible\n+    if exp.is_Float:\n+        from sympy.core.numbers import Float\n+        r = Float(exp).as_rational()\n+        if r is not None:\n+            exp = r\n+\n     # We handle x**n separately. This has two purposes: 1) it is much\n     # faster, because we avoid calling evalf on the exponent, and 2) it\n     # allows better handling of real/imaginary parts that are exactly zero\n", "occurrence": 1, "normalized_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex 54c5b3f..1746854 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -357,6 +357,11 @@ def evalf_mul(v, prec, options):\n def evalf_pow(v, prec, options):\n     target_prec = prec\n     base, exp = v.args\n+    if exp.is_Float:\n+        from sympy.core.numbers import Float\n+        r = Float(exp).as_rational()\n+        if r is not None:\n+            exp = r\n     if exp.is_Integer:\n         p = exp.p\n         if not p:\n", "normalized_occurrence": 1}
