{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23299", "model_patch": "diff --git a/lib/matplotlib/_pylab_helpers.py b/lib/matplotlib/_pylab_helpers.py\nindex 3123d3a..5a4fe4e 100644\n--- a/lib/matplotlib/_pylab_helpers.py\n+++ b/lib/matplotlib/_pylab_helpers.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Manage figures for the pyplot interface.\n \"\"\"\n@@ -7,7 +8,10 @@ from collections import OrderedDict\n import gc\n \n \n+import threading\n+\n class Gcf:\n+    _lock = threading.Lock()\n     \"\"\"\n     Singleton to maintain the relation between figures and their managers, and\n     keep track of and \"active\" figure and manager.\n@@ -37,9 +41,10 @@ class Gcf:\n         If manager number *num* exists, make it the active one and return it;\n         otherwise return *None*.\n         \"\"\"\n-        manager = cls.figs.get(num, None)\n-        if manager is not None:\n-            cls.set_active(manager)\n+        with cls._lock:\n+            manager = cls.figs.get(num, None)\n+            if manager is not None:\n+                cls.set_active(manager)\n         return manager\n \n     @classmethod\n@@ -53,23 +58,24 @@ class Gcf:\n         It is recommended to pass a manager instance, to avoid confusion when\n         two managers share the same number.\n         \"\"\"\n-        if all(hasattr(num, attr) for attr in [\"num\", \"destroy\"]):\n-            manager = num\n-            if cls.figs.get(manager.num) is manager:\n-                cls.figs.pop(manager.num)\n-        else:\n-            try:\n-                manager = cls.figs.pop(num)\n-            except KeyError:\n-                return\n-        if hasattr(manager, \"_cidgcf\"):\n-            manager.canvas.mpl_disconnect(manager._cidgcf)\n-        manager.destroy()\n-        del manager, num\n-        # Full cyclic garbage collection may be too expensive to do on every\n-        # figure destruction, so we collect only the youngest two generations.\n-        # see: https://github.com/matplotlib/matplotlib/pull/3045\n-        gc.collect(1)\n+        with cls._lock:\n+            if all(hasattr(num, attr) for attr in [\"num\", \"destroy\"]):\n+                manager = num\n+                if cls.figs.get(manager.num) is manager:\n+                    cls.figs.pop(manager.num)\n+            else:\n+                try:\n+                    manager = cls.figs.pop(num)\n+                except KeyError:\n+                    return\n+            if hasattr(manager, \"_cidgcf\"):\n+                manager.canvas.mpl_disconnect(manager._cidgcf)\n+            manager.destroy()\n+            del manager, num\n+            # Full cyclic garbage collection may be too expensive to do on every\n+            # figure destruction, so we collect only the youngest two generations.\n+            # see: https://github.com/matplotlib/matplotlib/pull/3045\n+            gc.collect(1)\n \n     @classmethod\n     def destroy_fig(cls, fig):\n@@ -85,31 +91,36 @@ class Gcf:\n         # Reimport gc in case the module globals have already been removed\n         # during interpreter shutdown.\n         import gc\n-        for manager in list(cls.figs.values()):\n-            manager.canvas.mpl_disconnect(manager._cidgcf)\n-            manager.destroy()\n-        cls.figs.clear()\n-        gc.collect(1)\n+        with cls._lock:\n+            for manager in list(cls.figs.values()):\n+                manager.canvas.mpl_disconnect(manager._cidgcf)\n+                manager.destroy()\n+            cls.figs.clear()\n+            gc.collect(1)\n \n     @classmethod\n     def has_fignum(cls, num):\n         \"\"\"Return whether figure number *num* exists.\"\"\"\n-        return num in cls.figs\n+        with cls._lock:\n+            return num in cls.figs\n \n     @classmethod\n     def get_all_fig_managers(cls):\n         \"\"\"Return a list of figure managers.\"\"\"\n-        return list(cls.figs.values())\n+        with cls._lock:\n+            return list(cls.figs.values())\n \n     @classmethod\n     def get_num_fig_managers(cls):\n         \"\"\"Return the number of figures being managed.\"\"\"\n-        return len(cls.figs)\n+        with cls._lock:\n+            return len(cls.figs)\n \n     @classmethod\n     def get_active(cls):\n         \"\"\"Return the active manager, or *None* if there is no manager.\"\"\"\n-        return next(reversed(cls.figs.values())) if cls.figs else None\n+        with cls._lock:\n+            return next(reversed(cls.figs.values())) if cls.figs else None\n \n     @classmethod\n     def _set_new_active_manager(cls, manager):\n@@ -141,4 +152,4 @@ class Gcf:\n                 manager.canvas.draw_idle()\n \n \n-atexit.register(Gcf.destroy_all)\n+atexit.register(Gcf.destroy_all)\n", "occurrence": 1, "normalized_patch": "diff --git a/lib/matplotlib/_pylab_helpers.py b/lib/matplotlib/_pylab_helpers.py\nindex 75c28d8..2feaef4 100644\n--- a/lib/matplotlib/_pylab_helpers.py\n+++ b/lib/matplotlib/_pylab_helpers.py\n@@ -1,30 +1,34 @@\n import atexit\n from collections import OrderedDict\n import gc\n+import threading\n class Gcf:\n+    _lock = threading.Lock()\n     figs = OrderedDict()\n     @classmethod\n     def get_fig_manager(cls, num):\n-        manager = cls.figs.get(num, None)\n-        if manager is not None:\n-            cls.set_active(manager)\n+        with cls._lock:\n+            manager = cls.figs.get(num, None)\n+            if manager is not None:\n+                cls.set_active(manager)\n         return manager\n     @classmethod\n     def destroy(cls, num):\n-        if all((hasattr(num, attr) for attr in ['num', 'destroy'])):\n-            manager = num\n-            if cls.figs.get(manager.num) is manager:\n-                cls.figs.pop(manager.num)\n-        else:\n-            try:\n-                manager = cls.figs.pop(num)\n-            except KeyError:\n-                return\n-        if hasattr(manager, '_cidgcf'):\n-            manager.canvas.mpl_disconnect(manager._cidgcf)\n-        manager.destroy()\n-        del manager, num\n-        gc.collect(1)\n+        with cls._lock:\n+            if all((hasattr(num, attr) for attr in ['num', 'destroy'])):\n+                manager = num\n+                if cls.figs.get(manager.num) is manager:\n+                    cls.figs.pop(manager.num)\n+            else:\n+                try:\n+                    manager = cls.figs.pop(num)\n+                except KeyError:\n+                    return\n+            if hasattr(manager, '_cidgcf'):\n+                manager.canvas.mpl_disconnect(manager._cidgcf)\n+            manager.destroy()\n+            del manager, num\n+            gc.collect(1)\n     @classmethod\n     def destroy_fig(cls, fig):\n         num = next((manager.num for manager in cls.figs.values() if manager.canvas.figure == fig), None)\n@@ -33,23 +37,28 @@ class Gcf:\n     @classmethod\n     def destroy_all(cls):\n         import gc\n-        for manager in list(cls.figs.values()):\n-            manager.canvas.mpl_disconnect(manager._cidgcf)\n-            manager.destroy()\n-        cls.figs.clear()\n-        gc.collect(1)\n+        with cls._lock:\n+            for manager in list(cls.figs.values()):\n+                manager.canvas.mpl_disconnect(manager._cidgcf)\n+                manager.destroy()\n+            cls.figs.clear()\n+            gc.collect(1)\n     @classmethod\n     def has_fignum(cls, num):\n-        return num in cls.figs\n+        with cls._lock:\n+            return num in cls.figs\n     @classmethod\n     def get_all_fig_managers(cls):\n-        return list(cls.figs.values())\n+        with cls._lock:\n+            return list(cls.figs.values())\n     @classmethod\n     def get_num_fig_managers(cls):\n-        return len(cls.figs)\n+        with cls._lock:\n+            return len(cls.figs)\n     @classmethod\n     def get_active(cls):\n-        return next(reversed(cls.figs.values())) if cls.figs else None\n+        with cls._lock:\n+            return next(reversed(cls.figs.values())) if cls.figs else None\n     @classmethod\n     def _set_new_active_manager(cls, manager):\n         if not hasattr(manager, '_cidgcf'):\n", "normalized_occurrence": 1}
